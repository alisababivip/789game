var lC = Object.defineProperty,
    hC = Object.defineProperties;
var uC = Object.getOwnPropertyDescriptors;
var Il = Object.getOwnPropertySymbols;
var ev = Object.prototype.hasOwnProperty,
    rv = Object.prototype.propertyIsEnumerable;
var tv = (re, ye, Te) => ye in re ? lC(re, ye, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: Te
    }) : re[ye] = Te,
    Kr = (re, ye) => {
        for (var Te in ye || (ye = {})) ev.call(ye, Te) && tv(re, Te, ye[Te]);
        if (Il)
            for (var Te of Il(ye)) rv.call(ye, Te) && tv(re, Te, ye[Te]);
        return re
    },
    Qd = (re, ye) => hC(re, uC(ye));
var Kd = (re, ye) => {
    var Te = {};
    for (var ie in re) ev.call(re, ie) && ye.indexOf(ie) < 0 && (Te[ie] = re[ie]);
    if (re != null && Il)
        for (var ie of Il(re)) ye.indexOf(ie) < 0 && rv.call(re, ie) && (Te[ie] = re[ie]);
    return Te
};
import {
    _ as cC
} from "./chunk-cf010ec4.js";
import {
    R as Ir,
    r as Ee
} from "./chunk-73e80d68.js";
import {
    j as iv
} from "./chunk-a4af42e8.js";
import {
    n as nv,
    e as dC,
    s as pC,
    __tla as fC
} from "./chunk-64278058.js";
let Zd, ma, Re, Kt, ga, Zr, ss, ya, Rl, as, Ml, Jd, tp, Dl, ep, dr, Ye, rp, va, mn, Ft, Nl, gn, pi, yn, ip, Zt, Ol, Ll, np, Bl, Z, kl, V, sp, ap, op, os, ls, qe, Fl, pr, ee, fr, Wt, sv, lp, Ul, Ut, Fi, hp, hs, vn, Gl, up, cp, us, zl, Jr, cs, Ge, dp, Hl, av, pp, ov, lv, Ui, xa, ae, fp, jl, _a, Wl, ba, mp, gp, Ea, hv, Xl, fi, $l, ti, Ta, Vl, uv, wa, Oe, ds, xn, Yl, mi, Qe, ql, Ql, Kl, gt, _n, yp, Zl, Ke, Jl, vp, th, xp, eh, ei, rh, ih, _p, Gi, ps, dt, nh, bp, Ep, fs, ms, oe, gi, Q, Ze, Sa, sh, ah, Vt, oh, lh, hh, cv, gs, dv, uh, Tp, bt, yi, ch, dh, zi, ph, bn, wp, fh, ze, Aa, Rr, le, En, mh, Mr, gh, Sp, Ap, Pp, pv, Dr, Cp, Pa, ut, vi, mr, fv, Ca, yh, Ia, Nr, Ra, Ma, Ip, mv, Gt, gr, ys, Rp, Mp, Dp, Np, Op, Lp, Tn, Bp, kp, Fp, Up, Gp, zp, et, Hp, Hi, jp, gv, yv, vs, Wp, xi, Xp, vh, xh, $p, _h, xs, Vp, Or, Da, Yp, _s, qp, _i, bh, Qp, Kp, Zp, Jp, tf, lt, Eh, ef, rf, nf, sf, af, Je, Th, of , Na, Oa, wh, Sh, bs, lf, mt, hf, Ah, Ph, yr, uf, cf, df, wn, pf, Ch, tr, ji, Es, mC = Promise.all([(() => {
    try {
        return fC
    } catch (re) {}
})()]).then(async () => {
    var re = "[object String]";
    wh = function(t) {
        return typeof t == "string" || !nv(t) && dC(t) && pC(t) == re
    };
    var ye = Object.defineProperty,
        Te = (t, e, r) => e in t ? ye(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: r
        }) : t[e] = r,
        ie = (t, e, r) => (Te(t, typeof e != "symbol" ? e + "" : e, r), r);

    function vv(t, e) {
        for (var r = 0; r < e.length; r++) {
            const i = e[r];
            if (typeof i != "string" && !Array.isArray(i)) {
                for (const n in i)
                    if (n !== "default" && !(n in t)) {
                        const a = Object.getOwnPropertyDescriptor(i, n);
                        a && Object.defineProperty(t, n, a.get ? a : {
                            enumerable: !0,
                            get: () => i[n]
                        })
                    }
            }
        }
        return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }))
    }
    pi = (t => (t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2", t))(pi || {}), uh = (t => (t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS", t))(uh || {}), Oa = (t => (t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL", t))(Oa || {}), ut = (t => (t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR", t))(ut || {}), Ye = (t => (t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", t))(Ye || {}), V = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(V || {}), Gi = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(Gi || {}), dt = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(dt || {}), Aa = (t => (t[t.FLOAT = 0] = "FLOAT", t[t.INT = 1] = "INT", t[t.UINT = 2] = "UINT", t))(Aa || {}), Rr = (t => (t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR", t))(Rr || {}), Nr = (t => (t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", t))(Nr || {}), fr = (t => (t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON", t[t.ON_MANUAL = 3] = "ON_MANUAL", t))(fr || {}), tr = (t => (t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", t))(tr || {}), yr = (t => (t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT", t))(yr || {}), ba = (t => (t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL", t))(ba || {}), Ge = (t => (t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp", t))(Ge || {}), ee = (t => (t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE", t[t.COLOR = 4] = "COLOR", t))(ee || {}), df = (t => (t[t.RED = 1] = "RED", t[t.GREEN = 2] = "GREEN", t[t.BLUE = 4] = "BLUE", t[t.ALPHA = 8] = "ALPHA", t))(df || {}), Wt = (t => (t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH", t))(Wt || {}), dr = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(dr || {}), hf = {
        createCanvas: (t, e) => {
            const r = document.createElement("canvas");
            return r.width = t, r.height = e, r
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => {
            var t;
            return (t = document.baseURI) != null ? t : window.location.href
        },
        getFontFaceSet: () => document.fonts,
        fetch: (t, e) => fetch(t, e),
        parseXML: t => new DOMParser().parseFromString(t, "text/xml")
    }, et = {
        ADAPTER: hf,
        RESOLUTION: 1,
        RENDER_OPTIONS: {
            view: null,
            width: 800,
            height: 600,
            autoDensity: !1,
            backgroundColor: 0,
            backgroundAlpha: 1,
            clearBeforeRender: !0,
            antialias: !1,
            premultipliedAlpha: !0,
            preserveDrawingBuffer: !1,
            hello: !1
        },
        CREATE_IMAGE_BITMAP: !1,
        ROUND_PIXELS: !1
    };
    var Ih = /iPhone/i,
        mf = /iPod/i,
        gf = /iPad/i,
        yf = /\biOS-universal(?:.+)Mac\b/i,
        Rh = /\bAndroid(?:.+)Mobile\b/i,
        vf = /Android/i,
        Sn = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
        Ba = /Silk/i,
        ri = /Windows Phone/i,
        xf = /\bWindows(?:.+)ARM\b/i,
        _f = /BlackBerry/i,
        bf = /BB10/i,
        Ef = /Opera Mini/i,
        Tf = /\b(CriOS|Chrome)(?:.+)Mobile/i,
        wf = /Mobile(?:.+)Firefox\b/i,
        Sf = function(t) {
            return typeof t < "u" && t.platform === "MacIntel" && typeof t.maxTouchPoints == "number" && t.maxTouchPoints > 1 && typeof MSStream > "u"
        };

    function xv(t) {
        return function(e) {
            return e.test(t)
        }
    }

    function _v(t) {
        var e = {
            userAgent: "",
            platform: "",
            maxTouchPoints: 0
        };
        !t && typeof navigator < "u" ? e = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            maxTouchPoints: navigator.maxTouchPoints || 0
        } : typeof t == "string" ? e.userAgent = t : t && t.userAgent && (e = {
            userAgent: t.userAgent,
            platform: t.platform,
            maxTouchPoints: t.maxTouchPoints || 0
        });
        var r = e.userAgent,
            i = r.split("[FBAN");
        typeof i[1] < "u" && (r = i[0]), i = r.split("Twitter"), typeof i[1] < "u" && (r = i[0]);
        var n = xv(r),
            a = {
                apple: {
                    phone: n(Ih) && !n(ri),
                    ipod: n(mf),
                    tablet: !n(Ih) && (n(gf) || Sf(e)) && !n(ri),
                    universal: n(yf),
                    device: (n(Ih) || n(mf) || n(gf) || n(yf) || Sf(e)) && !n(ri)
                },
                amazon: {
                    phone: n(Sn),
                    tablet: !n(Sn) && n(Ba),
                    device: n(Sn) || n(Ba)
                },
                android: {
                    phone: !n(ri) && n(Sn) || !n(ri) && n(Rh),
                    tablet: !n(ri) && !n(Sn) && !n(Rh) && (n(Ba) || n(vf)),
                    device: !n(ri) && (n(Sn) || n(Ba) || n(Rh) || n(vf)) || n(/\bokhttp\b/i)
                },
                windows: {
                    phone: n(ri),
                    tablet: n(xf),
                    device: n(ri) || n(xf)
                },
                other: {
                    blackberry: n(_f),
                    blackberry10: n(bf),
                    opera: n(Ef),
                    firefox: n(wf),
                    chrome: n(Tf),
                    device: n(_f) || n(bf) || n(Ef) || n(wf) || n(Tf)
                },
                any: !1,
                phone: !1,
                tablet: !1
            };
        return a.any = a.apple.device || a.android.device || a.windows.device || a.other.device, a.phone = a.apple.phone || a.android.phone || a.windows.phone, a.tablet = a.apple.tablet || a.android.tablet || a.windows.tablet, a
    }
    gr = _v(globalThis.navigator), et.RETINA_PREFIX = /@([0-9\.]+)x/, et.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
    var Mh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function ka(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }

    function Af(t) {
        if (t.__esModule) return t;
        var e = t.default;
        if (typeof e == "function") {
            var r = function i() {
                return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
            };
            r.prototype = e.prototype
        } else r = {};
        return Object.defineProperty(r, "__esModule", {
            value: !0
        }), Object.keys(t).forEach(function(i) {
            var n = Object.getOwnPropertyDescriptor(t, i);
            Object.defineProperty(r, i, n.get ? n : {
                enumerable: !0,
                get: function() {
                    return t[i]
                }
            })
        }), r
    }
    var Pf = {
        exports: {}
    };
    (function(t) {
        var e = Object.prototype.hasOwnProperty,
            r = "~";

        function i() {}
        Object.create && (i.prototype = Object.create(null), new i().__proto__ || (r = !1));

        function n(c, d, f) {
            this.fn = c, this.context = d, this.once = f || !1
        }

        function a(c, d, f, g, y) {
            if (typeof f != "function") throw new TypeError("The listener must be a function");
            var x = new n(f, g || c, y),
                _ = r ? r + d : d;
            return c._events[_] ? c._events[_].fn ? c._events[_] = [c._events[_], x] : c._events[_].push(x) : (c._events[_] = x, c._eventsCount++), c
        }

        function l(c, d) {
            --c._eventsCount === 0 ? c._events = new i : delete c._events[d]
        }

        function h() {
            this._events = new i, this._eventsCount = 0
        }
        h.prototype.eventNames = function() {
            var c = [],
                d, f;
            if (this._eventsCount === 0) return c;
            for (f in d = this._events) e.call(d, f) && c.push(r ? f.slice(1) : f);
            return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(d)) : c
        }, h.prototype.listeners = function(c) {
            var d = r ? r + c : c,
                f = this._events[d];
            if (!f) return [];
            if (f.fn) return [f.fn];
            for (var g = 0, y = f.length, x = new Array(y); g < y; g++) x[g] = f[g].fn;
            return x
        }, h.prototype.listenerCount = function(c) {
            var d = r ? r + c : c,
                f = this._events[d];
            return f ? f.fn ? 1 : f.length : 0
        }, h.prototype.emit = function(c, d, f, g, y, x) {
            var _ = r ? r + c : c;
            if (!this._events[_]) return !1;
            var E = this._events[_],
                w = arguments.length,
                I, S;
            if (E.fn) {
                switch (E.once && this.removeListener(c, E.fn, void 0, !0), w) {
                    case 1:
                        return E.fn.call(E.context), !0;
                    case 2:
                        return E.fn.call(E.context, d), !0;
                    case 3:
                        return E.fn.call(E.context, d, f), !0;
                    case 4:
                        return E.fn.call(E.context, d, f, g), !0;
                    case 5:
                        return E.fn.call(E.context, d, f, g, y), !0;
                    case 6:
                        return E.fn.call(E.context, d, f, g, y, x), !0
                }
                for (S = 1, I = new Array(w - 1); S < w; S++) I[S - 1] = arguments[S];
                E.fn.apply(E.context, I)
            } else {
                var T = E.length,
                    P;
                for (S = 0; S < T; S++) switch (E[S].once && this.removeListener(c, E[S].fn, void 0, !0), w) {
                    case 1:
                        E[S].fn.call(E[S].context);
                        break;
                    case 2:
                        E[S].fn.call(E[S].context, d);
                        break;
                    case 3:
                        E[S].fn.call(E[S].context, d, f);
                        break;
                    case 4:
                        E[S].fn.call(E[S].context, d, f, g);
                        break;
                    default:
                        if (!I)
                            for (P = 1, I = new Array(w - 1); P < w; P++) I[P - 1] = arguments[P];
                        E[S].fn.apply(E[S].context, I)
                }
            }
            return !0
        }, h.prototype.on = function(c, d, f) {
            return a(this, c, d, f, !1)
        }, h.prototype.once = function(c, d, f) {
            return a(this, c, d, f, !0)
        }, h.prototype.removeListener = function(c, d, f, g) {
            var y = r ? r + c : c;
            if (!this._events[y]) return this;
            if (!d) return l(this, y), this;
            var x = this._events[y];
            if (x.fn) x.fn === d && (!g || x.once) && (!f || x.context === f) && l(this, y);
            else {
                for (var _ = 0, E = [], w = x.length; _ < w; _++)(x[_].fn !== d || g && !x[_].once || f && x[_].context !== f) && E.push(x[_]);
                E.length ? this._events[y] = E.length === 1 ? E[0] : E : l(this, y)
            }
            return this
        }, h.prototype.removeAllListeners = function(c) {
            var d;
            return c ? (d = r ? r + c : c, this._events[d] && l(this, d)) : (this._events = new i, this._eventsCount = 0), this
        }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = r, h.EventEmitter = h, t.exports = h
    })(Pf);
    var bv = Pf.exports;
    const An = ka(bv);
    var Dh = {
        exports: {}
    };
    Dh.exports = Fa, Dh.exports.default = Fa;

    function Fa(t, e, r) {
        r = r || 2;
        var i = e && e.length,
            n = i ? e[0] * r : t.length,
            a = Cf(t, 0, n, r, !0),
            l = [];
        if (!a || a.next === a.prev) return l;
        var h, c, d, f, g, y, x;
        if (i && (a = Av(t, e, a, r)), t.length > 80 * r) {
            h = d = t[0], c = f = t[1];
            for (var _ = r; _ < n; _ += r) g = t[_], y = t[_ + 1], g < h && (h = g), y < c && (c = y), g > d && (d = g), y > f && (f = y);
            x = Math.max(d - h, f - c), x = x !== 0 ? 32767 / x : 0
        }
        return Ts(a, l, r, h, c, x, 0), l
    }

    function Cf(t, e, r, i, n) {
        var a, l;
        if (n === Lh(t, e, r, i) > 0)
            for (a = e; a < r; a += i) l = Mf(a, t[a], t[a + 1], l);
        else
            for (a = r - i; a >= e; a -= i) l = Mf(a, t[a], t[a + 1], l);
        return l && Ua(l, l.next) && (Ss(l), l = l.next), l
    }

    function Wi(t, e) {
        if (!t) return t;
        e || (e = t);
        var r = t,
            i;
        do
            if (i = !1, !r.steiner && (Ua(r, r.next) || Xt(r.prev, r, r.next) === 0)) {
                if (Ss(r), r = e = r.prev, r === r.next) break;
                i = !0
            } else r = r.next; while (i || r !== e);
        return e
    }

    function Ts(t, e, r, i, n, a, l) {
        if (t) {
            !l && a && Mv(t, i, n, a);
            for (var h = t, c, d; t.prev !== t.next;) {
                if (c = t.prev, d = t.next, a ? Tv(t, i, n, a) : Ev(t)) {
                    e.push(c.i / r | 0), e.push(t.i / r | 0), e.push(d.i / r | 0), Ss(t), t = d.next, h = d.next;
                    continue
                }
                if (t = d, t === h) {
                    l ? l === 1 ? (t = wv(Wi(t), e, r), Ts(t, e, r, i, n, a, 2)) : l === 2 && Sv(t, e, r, i, n, a) : Ts(Wi(t), e, r, i, n, a, 1);
                    break
                }
            }
        }
    }

    function Ev(t) {
        var e = t.prev,
            r = t,
            i = t.next;
        if (Xt(e, r, i) >= 0) return !1;
        for (var n = e.x, a = r.x, l = i.x, h = e.y, c = r.y, d = i.y, f = n < a ? n < l ? n : l : a < l ? a : l, g = h < c ? h < d ? h : d : c < d ? c : d, y = n > a ? n > l ? n : l : a > l ? a : l, x = h > c ? h > d ? h : d : c > d ? c : d, _ = i.next; _ !== e;) {
            if (_.x >= f && _.x <= y && _.y >= g && _.y <= x && Pn(n, h, a, c, l, d, _.x, _.y) && Xt(_.prev, _, _.next) >= 0) return !1;
            _ = _.next
        }
        return !0
    }

    function Tv(t, e, r, i) {
        var n = t.prev,
            a = t,
            l = t.next;
        if (Xt(n, a, l) >= 0) return !1;
        for (var h = n.x, c = a.x, d = l.x, f = n.y, g = a.y, y = l.y, x = h < c ? h < d ? h : d : c < d ? c : d, _ = f < g ? f < y ? f : y : g < y ? g : y, E = h > c ? h > d ? h : d : c > d ? c : d, w = f > g ? f > y ? f : y : g > y ? g : y, I = Nh(x, _, e, r, i), S = Nh(E, w, e, r, i), T = t.prevZ, P = t.nextZ; T && T.z >= I && P && P.z <= S;) {
            if (T.x >= x && T.x <= E && T.y >= _ && T.y <= w && T !== n && T !== l && Pn(h, f, c, g, d, y, T.x, T.y) && Xt(T.prev, T, T.next) >= 0 || (T = T.prevZ, P.x >= x && P.x <= E && P.y >= _ && P.y <= w && P !== n && P !== l && Pn(h, f, c, g, d, y, P.x, P.y) && Xt(P.prev, P, P.next) >= 0)) return !1;
            P = P.nextZ
        }
        for (; T && T.z >= I;) {
            if (T.x >= x && T.x <= E && T.y >= _ && T.y <= w && T !== n && T !== l && Pn(h, f, c, g, d, y, T.x, T.y) && Xt(T.prev, T, T.next) >= 0) return !1;
            T = T.prevZ
        }
        for (; P && P.z <= S;) {
            if (P.x >= x && P.x <= E && P.y >= _ && P.y <= w && P !== n && P !== l && Pn(h, f, c, g, d, y, P.x, P.y) && Xt(P.prev, P, P.next) >= 0) return !1;
            P = P.nextZ
        }
        return !0
    }

    function wv(t, e, r) {
        var i = t;
        do {
            var n = i.prev,
                a = i.next.next;
            !Ua(n, a) && If(n, i, i.next, a) && ws(n, a) && ws(a, n) && (e.push(n.i / r | 0), e.push(i.i / r | 0), e.push(a.i / r | 0), Ss(i), Ss(i.next), i = t = a), i = i.next
        } while (i !== t);
        return Wi(i)
    }

    function Sv(t, e, r, i, n, a) {
        var l = t;
        do {
            for (var h = l.next.next; h !== l.prev;) {
                if (l.i !== h.i && Ov(l, h)) {
                    var c = Rf(l, h);
                    l = Wi(l, l.next), c = Wi(c, c.next), Ts(l, e, r, i, n, a, 0), Ts(c, e, r, i, n, a, 0);
                    return
                }
                h = h.next
            }
            l = l.next
        } while (l !== t)
    }

    function Av(t, e, r, i) {
        var n = [],
            a, l, h, c, d;
        for (a = 0, l = e.length; a < l; a++) h = e[a] * i, c = a < l - 1 ? e[a + 1] * i : t.length, d = Cf(t, h, c, i, !1), d === d.next && (d.steiner = !0), n.push(Nv(d));
        for (n.sort(Pv), a = 0; a < n.length; a++) r = Cv(n[a], r);
        return r
    }

    function Pv(t, e) {
        return t.x - e.x
    }

    function Cv(t, e) {
        var r = Iv(t, e);
        if (!r) return e;
        var i = Rf(r, t);
        return Wi(i, i.next), Wi(r, r.next)
    }

    function Iv(t, e) {
        var r = e,
            i = t.x,
            n = t.y,
            a = -1 / 0,
            l;
        do {
            if (n <= r.y && n >= r.next.y && r.next.y !== r.y) {
                var h = r.x + (n - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                if (h <= i && h > a && (a = h, l = r.x < r.next.x ? r : r.next, h === i)) return l
            }
            r = r.next
        } while (r !== e);
        if (!l) return null;
        var c = l,
            d = l.x,
            f = l.y,
            g = 1 / 0,
            y;
        r = l;
        do i >= r.x && r.x >= d && i !== r.x && Pn(n < f ? i : a, n, d, f, n < f ? a : i, n, r.x, r.y) && (y = Math.abs(n - r.y) / (i - r.x), ws(r, t) && (y < g || y === g && (r.x > l.x || r.x === l.x && Rv(l, r))) && (l = r, g = y)), r = r.next; while (r !== c);
        return l
    }

    function Rv(t, e) {
        return Xt(t.prev, t, e.prev) < 0 && Xt(e.next, t, t.next) < 0
    }

    function Mv(t, e, r, i) {
        var n = t;
        do n.z === 0 && (n.z = Nh(n.x, n.y, e, r, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next; while (n !== t);
        n.prevZ.nextZ = null, n.prevZ = null, Dv(n)
    }

    function Dv(t) {
        var e, r, i, n, a, l, h, c, d = 1;
        do {
            for (r = t, t = null, a = null, l = 0; r;) {
                for (l++, i = r, h = 0, e = 0; e < d && (h++, i = i.nextZ, !!i); e++);
                for (c = d; h > 0 || c > 0 && i;) h !== 0 && (c === 0 || !i || r.z <= i.z) ? (n = r, r = r.nextZ, h--) : (n = i, i = i.nextZ, c--), a ? a.nextZ = n : t = n, n.prevZ = a, a = n;
                r = i
            }
            a.nextZ = null, d *= 2
        } while (l > 1);
        return t
    }

    function Nh(t, e, r, i, n) {
        return t = (t - r) * n | 0, e = (e - i) * n | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1
    }

    function Nv(t) {
        var e = t,
            r = t;
        do(e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next; while (e !== t);
        return r
    }

    function Pn(t, e, r, i, n, a, l, h) {
        return (n - l) * (e - h) >= (t - l) * (a - h) && (t - l) * (i - h) >= (r - l) * (e - h) && (r - l) * (a - h) >= (n - l) * (i - h)
    }

    function Ov(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !Lv(t, e) && (ws(t, e) && ws(e, t) && Bv(t, e) && (Xt(t.prev, t, e.prev) || Xt(t, e.prev, e)) || Ua(t, e) && Xt(t.prev, t, t.next) > 0 && Xt(e.prev, e, e.next) > 0)
    }

    function Xt(t, e, r) {
        return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y)
    }

    function Ua(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function If(t, e, r, i) {
        var n = za(Xt(t, e, r)),
            a = za(Xt(t, e, i)),
            l = za(Xt(r, i, t)),
            h = za(Xt(r, i, e));
        return !!(n !== a && l !== h || n === 0 && Ga(t, r, e) || a === 0 && Ga(t, i, e) || l === 0 && Ga(r, t, i) || h === 0 && Ga(r, e, i))
    }

    function Ga(t, e, r) {
        return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y)
    }

    function za(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }

    function Lv(t, e) {
        var r = t;
        do {
            if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && If(r, r.next, t, e)) return !0;
            r = r.next
        } while (r !== t);
        return !1
    }

    function ws(t, e) {
        return Xt(t.prev, t, t.next) < 0 ? Xt(t, e, t.next) >= 0 && Xt(t, t.prev, e) >= 0 : Xt(t, e, t.prev) < 0 || Xt(t, t.next, e) < 0
    }

    function Bv(t, e) {
        var r = t,
            i = !1,
            n = (t.x + e.x) / 2,
            a = (t.y + e.y) / 2;
        do r.y > a != r.next.y > a && r.next.y !== r.y && n < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next; while (r !== t);
        return i
    }

    function Rf(t, e) {
        var r = new Oh(t.i, t.x, t.y),
            i = new Oh(e.i, e.x, e.y),
            n = t.next,
            a = e.prev;
        return t.next = e, e.prev = t, r.next = n, n.prev = r, i.next = r, r.prev = i, a.next = i, i.prev = a, i
    }

    function Mf(t, e, r, i) {
        var n = new Oh(t, e, r);
        return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n
    }

    function Ss(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function Oh(t, e, r) {
        this.i = t, this.x = e, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }
    Fa.deviation = function(t, e, r, i) {
        var n = e && e.length,
            a = n ? e[0] * r : t.length,
            l = Math.abs(Lh(t, 0, a, r));
        if (n)
            for (var h = 0, c = e.length; h < c; h++) {
                var d = e[h] * r,
                    f = h < c - 1 ? e[h + 1] * r : t.length;
                l -= Math.abs(Lh(t, d, f, r))
            }
        var g = 0;
        for (h = 0; h < i.length; h += 3) {
            var y = i[h] * r,
                x = i[h + 1] * r,
                _ = i[h + 2] * r;
            g += Math.abs((t[y] - t[_]) * (t[x + 1] - t[y + 1]) - (t[y] - t[x]) * (t[_ + 1] - t[y + 1]))
        }
        return l === 0 && g === 0 ? 0 : Math.abs((g - l) / l)
    };

    function Lh(t, e, r, i) {
        for (var n = 0, a = e, l = r - i; a < r; a += i) n += (t[l] - t[a]) * (t[a + 1] + t[l + 1]), l = a;
        return n
    }
    Fa.flatten = function(t) {
        for (var e = t[0][0].length, r = {
                vertices: [],
                holes: [],
                dimensions: e
            }, i = 0, n = 0; n < t.length; n++) {
            for (var a = 0; a < t[n].length; a++)
                for (var l = 0; l < e; l++) r.vertices.push(t[n][a][l]);
            n > 0 && (i += t[n - 1].length, r.holes.push(i))
        }
        return r
    };
    var kv = Dh.exports;
    const Df = ka(kv);
    var Ha = {
        exports: {}
    };
    Ha.exports,
        function(t, e) {
            (function(r) {
                var i = e && !e.nodeType && e,
                    n = t && !t.nodeType && t,
                    a = typeof Mh == "object" && Mh;
                (a.global === a || a.window === a || a.self === a) && (r = a);
                var l, h = 2147483647,
                    c = 36,
                    d = 1,
                    f = 26,
                    g = 38,
                    y = 700,
                    x = 72,
                    _ = 128,
                    E = "-",
                    w = /^xn--/,
                    I = /[^\x20-\x7E]/,
                    S = /[\x2E\u3002\uFF0E\uFF61]/g,
                    T = {
                        overflow: "Overflow: input needs wider integers to process",
                        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                        "invalid-input": "Invalid input"
                    },
                    P = c - d,
                    z = Math.floor,
                    X = String.fromCharCode,
                    O;

                function M(D) {
                    throw new RangeError(T[D])
                }

                function $(D, tt) {
                    for (var ht = D.length, _t = []; ht--;) _t[ht] = tt(D[ht]);
                    return _t
                }

                function nt(D, tt) {
                    var ht = D.split("@"),
                        _t = "";
                    ht.length > 1 && (_t = ht[0] + "@", D = ht[1]), D = D.replace(S, ".");
                    var vt = D.split("."),
                        Nt = $(vt, tt).join(".");
                    return _t + Nt
                }

                function Y(D) {
                    for (var tt = [], ht = 0, _t = D.length, vt, Nt; ht < _t;) vt = D.charCodeAt(ht++), vt >= 55296 && vt <= 56319 && ht < _t ? (Nt = D.charCodeAt(ht++), (Nt & 64512) == 56320 ? tt.push(((vt & 1023) << 10) + (Nt & 1023) + 65536) : (tt.push(vt), ht--)) : tt.push(vt);
                    return tt
                }

                function q(D) {
                    return $(D, function(tt) {
                        var ht = "";
                        return tt > 65535 && (tt -= 65536, ht += X(tt >>> 10 & 1023 | 55296), tt = 56320 | tt & 1023), ht += X(tt), ht
                    }).join("")
                }

                function B(D) {
                    return D - 48 < 10 ? D - 22 : D - 65 < 26 ? D - 65 : D - 97 < 26 ? D - 97 : c
                }

                function G(D, tt) {
                    return D + 22 + 75 * (D < 26) - ((tt != 0) << 5)
                }

                function pt(D, tt, ht) {
                    var _t = 0;
                    for (D = ht ? z(D / y) : D >> 1, D += z(D / tt); D > P * f >> 1; _t += c) D = z(D / P);
                    return z(_t + (P + 1) * D / (D + g))
                }

                function ft(D) {
                    var tt = [],
                        ht = D.length,
                        _t, vt = 0,
                        Nt = _,
                        Ct = x,
                        Ot, de, xe, qt, xt, kt, St, rr, ir;
                    for (Ot = D.lastIndexOf(E), Ot < 0 && (Ot = 0), de = 0; de < Ot; ++de) D.charCodeAt(de) >= 128 && M("not-basic"), tt.push(D.charCodeAt(de));
                    for (xe = Ot > 0 ? Ot + 1 : 0; xe < ht;) {
                        for (qt = vt, xt = 1, kt = c; xe >= ht && M("invalid-input"), St = B(D.charCodeAt(xe++)), (St >= c || St > z((h - vt) / xt)) && M("overflow"), vt += St * xt, rr = kt <= Ct ? d : kt >= Ct + f ? f : kt - Ct, !(St < rr); kt += c) ir = c - rr, xt > z(h / ir) && M("overflow"), xt *= ir;
                        _t = tt.length + 1, Ct = pt(vt - qt, _t, qt == 0), z(vt / _t) > h - Nt && M("overflow"), Nt += z(vt / _t), vt %= _t, tt.splice(vt++, 0, Nt)
                    }
                    return q(tt)
                }

                function J(D) {
                    var tt, ht, _t, vt, Nt, Ct, Ot, de, xe, qt, xt, kt = [],
                        St, rr, ir, sn;
                    for (D = Y(D), St = D.length, tt = _, ht = 0, Nt = x, Ct = 0; Ct < St; ++Ct) xt = D[Ct], xt < 128 && kt.push(X(xt));
                    for (_t = vt = kt.length, vt && kt.push(E); _t < St;) {
                        for (Ot = h, Ct = 0; Ct < St; ++Ct) xt = D[Ct], xt >= tt && xt < Ot && (Ot = xt);
                        for (rr = _t + 1, Ot - tt > z((h - ht) / rr) && M("overflow"), ht += (Ot - tt) * rr, tt = Ot, Ct = 0; Ct < St; ++Ct)
                            if (xt = D[Ct], xt < tt && ++ht > h && M("overflow"), xt == tt) {
                                for (de = ht, xe = c; qt = xe <= Nt ? d : xe >= Nt + f ? f : xe - Nt, !(de < qt); xe += c) sn = de - qt, ir = c - qt, kt.push(X(G(qt + sn % ir, 0))), de = z(sn / ir);
                                kt.push(X(G(de, 0))), Nt = pt(ht, rr, _t == vt), ht = 0, ++_t
                            }++ht, ++tt
                    }
                    return kt.join("")
                }

                function j(D) {
                    return nt(D, function(tt) {
                        return w.test(tt) ? ft(tt.slice(4).toLowerCase()) : tt
                    })
                }

                function rt(D) {
                    return nt(D, function(tt) {
                        return I.test(tt) ? "xn--" + J(tt) : tt
                    })
                }
                if (l = {
                        version: "1.4.1",
                        ucs2: {
                            decode: Y,
                            encode: q
                        },
                        decode: ft,
                        encode: J,
                        toASCII: rt,
                        toUnicode: j
                    }, i && n)
                    if (t.exports == i) n.exports = l;
                    else
                        for (O in l) l.hasOwnProperty(O) && (i[O] = l[O]);
                else r.punycode = l
            })(Mh)
        }(Ha, Ha.exports);
    var Fv = Ha.exports,
        Uv = function() {
            if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
            if (typeof Symbol.iterator == "symbol") return !0;
            var t = {},
                e = Symbol("test"),
                r = Object(e);
            if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
            var i = 42;
            t[e] = i;
            for (e in t) return !1;
            if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return !1;
            var n = Object.getOwnPropertySymbols(t);
            if (n.length !== 1 || n[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
            if (typeof Object.getOwnPropertyDescriptor == "function") {
                var a = Object.getOwnPropertyDescriptor(t, e);
                if (a.value !== i || a.enumerable !== !0) return !1
            }
            return !0
        },
        Nf = typeof Symbol < "u" && Symbol,
        Gv = Uv,
        zv = function() {
            return typeof Nf != "function" || typeof Symbol != "function" || typeof Nf("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : Gv()
        },
        Of = {
            foo: {}
        },
        Hv = Object,
        jv = function() {
            return {
                __proto__: Of
            }.foo === Of.foo && !({
                    __proto__: null
                }
                instanceof Hv)
        },
        Wv = "Function.prototype.bind called on incompatible ",
        Bh = Array.prototype.slice,
        Xv = Object.prototype.toString,
        $v = "[object Function]",
        Vv = function(t) {
            var e = this;
            if (typeof e != "function" || Xv.call(e) !== $v) throw new TypeError(Wv + e);
            for (var r = Bh.call(arguments, 1), i, n = function() {
                    if (this instanceof i) {
                        var d = e.apply(this, r.concat(Bh.call(arguments)));
                        return Object(d) === d ? d : this
                    } else return e.apply(t, r.concat(Bh.call(arguments)))
                }, a = Math.max(0, e.length - r.length), l = [], h = 0; h < a; h++) l.push("$" + h);
            if (i = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(n), e.prototype) {
                var c = function() {};
                c.prototype = e.prototype, i.prototype = new c, c.prototype = null
            }
            return i
        },
        Yv = Vv,
        kh = Function.prototype.bind || Yv,
        qv = kh,
        Qv = qv.call(Function.call, Object.prototype.hasOwnProperty),
        Et, Cn = SyntaxError,
        Lf = Function,
        In = TypeError,
        Fh = function(t) {
            try {
                return Lf('"use strict"; return (' + t + ").constructor;")()
            } catch (e) {}
        },
        Xi = Object.getOwnPropertyDescriptor;
    if (Xi) try {
        Xi({}, "")
    } catch (t) {
        Xi = null
    }
    var Uh = function() {
            throw new In
        },
        Kv = Xi ? function() {
            try {
                return arguments.callee, Uh
            } catch (t) {
                try {
                    return Xi(arguments, "callee").get
                } catch (e) {
                    return Uh
                }
            }
        }() : Uh,
        Rn = zv(),
        Zv = jv(),
        he = Object.getPrototypeOf || (Zv ? function(t) {
            return t.__proto__
        } : null),
        Mn = {},
        Jv = typeof Uint8Array > "u" || !he ? Et : he(Uint8Array),
        $i = {
            "%AggregateError%": typeof AggregateError > "u" ? Et : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Et : ArrayBuffer,
            "%ArrayIteratorPrototype%": Rn && he ? he([][Symbol.iterator]()) : Et,
            "%AsyncFromSyncIteratorPrototype%": Et,
            "%AsyncFunction%": Mn,
            "%AsyncGenerator%": Mn,
            "%AsyncGeneratorFunction%": Mn,
            "%AsyncIteratorPrototype%": Mn,
            "%Atomics%": typeof Atomics > "u" ? Et : Atomics,
            "%BigInt%": typeof BigInt > "u" ? Et : BigInt,
            "%BigInt64Array%": typeof BigInt64Array > "u" ? Et : BigInt64Array,
            "%BigUint64Array%": typeof BigUint64Array > "u" ? Et : BigUint64Array,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView > "u" ? Et : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            "%EvalError%": EvalError,
            "%Float32Array%": typeof Float32Array > "u" ? Et : Float32Array,
            "%Float64Array%": typeof Float64Array > "u" ? Et : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Et : FinalizationRegistry,
            "%Function%": Lf,
            "%GeneratorFunction%": Mn,
            "%Int8Array%": typeof Int8Array > "u" ? Et : Int8Array,
            "%Int16Array%": typeof Int16Array > "u" ? Et : Int16Array,
            "%Int32Array%": typeof Int32Array > "u" ? Et : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": Rn && he ? he(he([][Symbol.iterator]())) : Et,
            "%JSON%": typeof JSON == "object" ? JSON : Et,
            "%Map%": typeof Map > "u" ? Et : Map,
            "%MapIteratorPrototype%": typeof Map > "u" || !Rn || !he ? Et : he(new Map()[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise > "u" ? Et : Promise,
            "%Proxy%": typeof Proxy > "u" ? Et : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect > "u" ? Et : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set > "u" ? Et : Set,
            "%SetIteratorPrototype%": typeof Set > "u" || !Rn || !he ? Et : he(new Set()[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Et : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": Rn && he ? he("" [Symbol.iterator]()) : Et,
            "%Symbol%": Rn ? Symbol : Et,
            "%SyntaxError%": Cn,
            "%ThrowTypeError%": Kv,
            "%TypedArray%": Jv,
            "%TypeError%": In,
            "%Uint8Array%": typeof Uint8Array > "u" ? Et : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Et : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array > "u" ? Et : Uint16Array,
            "%Uint32Array%": typeof Uint32Array > "u" ? Et : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap > "u" ? Et : WeakMap,
            "%WeakRef%": typeof WeakRef > "u" ? Et : WeakRef,
            "%WeakSet%": typeof WeakSet > "u" ? Et : WeakSet
        };
    if (he) try {
        null.error
    } catch (t) {
        var tx = he(he(t));
        $i["%Error.prototype%"] = tx
    }
    var ex = function t(e) {
            var r;
            if (e === "%AsyncFunction%") r = Fh("async function () {}");
            else if (e === "%GeneratorFunction%") r = Fh("function* () {}");
            else if (e === "%AsyncGeneratorFunction%") r = Fh("async function* () {}");
            else if (e === "%AsyncGenerator%") {
                var i = t("%AsyncGeneratorFunction%");
                i && (r = i.prototype)
            } else if (e === "%AsyncIteratorPrototype%") {
                var n = t("%AsyncGenerator%");
                n && he && (r = he(n.prototype))
            }
            return $i[e] = r, r
        },
        Bf = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
        },
        As = kh,
        ja = Qv,
        rx = As.call(Function.call, Array.prototype.concat),
        ix = As.call(Function.apply, Array.prototype.splice),
        kf = As.call(Function.call, String.prototype.replace),
        Wa = As.call(Function.call, String.prototype.slice),
        nx = As.call(Function.call, RegExp.prototype.exec),
        sx = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        ax = /\\(\\)?/g,
        ox = function(t) {
            var e = Wa(t, 0, 1),
                r = Wa(t, -1);
            if (e === "%" && r !== "%") throw new Cn("invalid intrinsic syntax, expected closing `%`");
            if (r === "%" && e !== "%") throw new Cn("invalid intrinsic syntax, expected opening `%`");
            var i = [];
            return kf(t, sx, function(n, a, l, h) {
                i[i.length] = l ? kf(h, ax, "$1") : a || n
            }), i
        },
        lx = function(t, e) {
            var r = t,
                i;
            if (ja(Bf, r) && (i = Bf[r], r = "%" + i[0] + "%"), ja($i, r)) {
                var n = $i[r];
                if (n === Mn && (n = ex(r)), typeof n > "u" && !e) throw new In("intrinsic " + t + " exists, but is not available. Please file an issue!");
                return {
                    alias: i,
                    name: r,
                    value: n
                }
            }
            throw new Cn("intrinsic " + t + " does not exist!")
        },
        Gh = function(t, e) {
            if (typeof t != "string" || t.length === 0) throw new In("intrinsic name must be a non-empty string");
            if (arguments.length > 1 && typeof e != "boolean") throw new In('"allowMissing" argument must be a boolean');
            if (nx(/^%?[^%]*%?$/, t) === null) throw new Cn("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
            var r = ox(t),
                i = r.length > 0 ? r[0] : "",
                n = lx("%" + i + "%", e),
                a = n.name,
                l = n.value,
                h = !1,
                c = n.alias;
            c && (i = c[0], ix(r, rx([0, 1], c)));
            for (var d = 1, f = !0; d < r.length; d += 1) {
                var g = r[d],
                    y = Wa(g, 0, 1),
                    x = Wa(g, -1);
                if ((y === '"' || y === "'" || y === "`" || x === '"' || x === "'" || x === "`") && y !== x) throw new Cn("property names with quotes must have matching quotes");
                if ((g === "constructor" || !f) && (h = !0), i += "." + g, a = "%" + i + "%", ja($i, a)) l = $i[a];
                else if (l != null) {
                    if (!(g in l)) {
                        if (!e) throw new In("base intrinsic for " + t + " exists, but the property is not available.");
                        return
                    }
                    if (Xi && d + 1 >= r.length) {
                        var _ = Xi(l, g);
                        f = !!_, f && "get" in _ && !("originalValue" in _.get) ? l = _.get : l = l[g]
                    } else f = ja(l, g), l = l[g];
                    f && !h && ($i[a] = l)
                }
            }
            return l
        },
        Ff = {
            exports: {}
        };
    (function(t) {
        var e = kh,
            r = Gh,
            i = r("%Function.prototype.apply%"),
            n = r("%Function.prototype.call%"),
            a = r("%Reflect.apply%", !0) || e.call(n, i),
            l = r("%Object.getOwnPropertyDescriptor%", !0),
            h = r("%Object.defineProperty%", !0),
            c = r("%Math.max%");
        if (h) try {
            h({}, "a", {
                value: 1
            })
        } catch (f) {
            h = null
        }
        t.exports = function(f) {
            var g = a(e, n, arguments);
            if (l && h) {
                var y = l(g, "length");
                y.configurable && h(g, "length", {
                    value: 1 + c(0, f.length - (arguments.length - 1))
                })
            }
            return g
        };
        var d = function() {
            return a(e, i, arguments)
        };
        h ? h(t.exports, "apply", {
            value: d
        }) : t.exports.apply = d
    })(Ff);
    var hx = Ff.exports,
        Uf = Gh,
        Gf = hx,
        ux = Gf(Uf("String.prototype.indexOf")),
        cx = function(t, e) {
            var r = Uf(t, !!e);
            return typeof r == "function" && ux(t, ".prototype.") > -1 ? Gf(r) : r
        };
    const dx = {},
        px = Object.freeze(Object.defineProperty({
            __proto__: null,
            default: dx
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        fx = Af(px);
    var zh = typeof Map == "function" && Map.prototype,
        Hh = Object.getOwnPropertyDescriptor && zh ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
        Xa = zh && Hh && typeof Hh.get == "function" ? Hh.get : null,
        zf = zh && Map.prototype.forEach,
        jh = typeof Set == "function" && Set.prototype,
        Wh = Object.getOwnPropertyDescriptor && jh ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
        $a = jh && Wh && typeof Wh.get == "function" ? Wh.get : null,
        Hf = jh && Set.prototype.forEach,
        mx = typeof WeakMap == "function" && WeakMap.prototype,
        Ps = mx ? WeakMap.prototype.has : null,
        gx = typeof WeakSet == "function" && WeakSet.prototype,
        Cs = gx ? WeakSet.prototype.has : null,
        yx = typeof WeakRef == "function" && WeakRef.prototype,
        jf = yx ? WeakRef.prototype.deref : null,
        vx = Boolean.prototype.valueOf,
        xx = Object.prototype.toString,
        _x = Function.prototype.toString,
        bx = String.prototype.match,
        Xh = String.prototype.slice,
        bi = String.prototype.replace,
        Ex = String.prototype.toUpperCase,
        Wf = String.prototype.toLowerCase,
        Xf = RegExp.prototype.test,
        $f = Array.prototype.concat,
        Lr = Array.prototype.join,
        Tx = Array.prototype.slice,
        Vf = Math.floor,
        $h = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
        Vh = Object.getOwnPropertySymbols,
        Yh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
        Dn = typeof Symbol == "function" && typeof Symbol.iterator == "object",
        we = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Dn || "symbol") ? Symbol.toStringTag : null,
        Yf = Object.prototype.propertyIsEnumerable,
        qf = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
            return t.__proto__
        } : null);

    function Qf(t, e) {
        if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || Xf.call(/e/, e)) return e;
        var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof t == "number") {
            var i = t < 0 ? -Vf(-t) : Vf(t);
            if (i !== t) {
                var n = String(i),
                    a = Xh.call(e, n.length + 1);
                return bi.call(n, r, "$&_") + "." + bi.call(bi.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
            }
        }
        return bi.call(e, r, "$&_")
    }
    var qh = fx,
        Kf = qh.custom,
        Zf = em(Kf) ? Kf : null,
        wx = function t(e, r, i, n) {
            var a = r || {};
            if (Ei(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
            if (Ei(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
            var l = Ei(a, "customInspect") ? a.customInspect : !0;
            if (typeof l != "boolean" && l !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
            if (Ei(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
            if (Ei(a, "numericSeparator") && typeof a.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
            var h = a.numericSeparator;
            if (typeof e > "u") return "undefined";
            if (e === null) return "null";
            if (typeof e == "boolean") return e ? "true" : "false";
            if (typeof e == "string") return im(e, a);
            if (typeof e == "number") {
                if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
                var c = String(e);
                return h ? Qf(e, c) : c
            }
            if (typeof e == "bigint") {
                var d = String(e) + "n";
                return h ? Qf(e, d) : d
            }
            var f = typeof a.depth > "u" ? 5 : a.depth;
            if (typeof i > "u" && (i = 0), i >= f && f > 0 && typeof e == "object") return Qh(e) ? "[Array]" : "[Object]";
            var g = Hx(a, i);
            if (typeof n > "u") n = [];
            else if (rm(n, e) >= 0) return "[Circular]";

            function y(B, G, pt) {
                if (G && (n = Tx.call(n), n.push(G)), pt) {
                    var ft = {
                        depth: a.depth
                    };
                    return Ei(a, "quoteStyle") && (ft.quoteStyle = a.quoteStyle), t(B, ft, i + 1, n)
                }
                return t(B, a, i + 1, n)
            }
            if (typeof e == "function" && !tm(e)) {
                var x = Nx(e),
                    _ = Va(e, y);
                return "[Function" + (x ? ": " + x : " (anonymous)") + "]" + (_.length > 0 ? " { " + Lr.call(_, ", ") + " }" : "")
            }
            if (em(e)) {
                var E = Dn ? bi.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : Yh.call(e);
                return typeof e == "object" && !Dn ? Is(E) : E
            }
            if (Ux(e)) {
                for (var w = "<" + Wf.call(String(e.nodeName)), I = e.attributes || [], S = 0; S < I.length; S++) w += " " + I[S].name + "=" + Jf(Sx(I[S].value), "double", a);
                return w += ">", e.childNodes && e.childNodes.length && (w += "..."), w += "</" + Wf.call(String(e.nodeName)) + ">", w
            }
            if (Qh(e)) {
                if (e.length === 0) return "[]";
                var T = Va(e, y);
                return g && !zx(T) ? "[" + Zh(T, g) + "]" : "[ " + Lr.call(T, ", ") + " ]"
            }
            if (Px(e)) {
                var P = Va(e, y);
                return !("cause" in Error.prototype) && "cause" in e && !Yf.call(e, "cause") ? "{ [" + String(e) + "] " + Lr.call($f.call("[cause]: " + y(e.cause), P), ", ") + " }" : P.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Lr.call(P, ", ") + " }"
            }
            if (typeof e == "object" && l) {
                if (Zf && typeof e[Zf] == "function" && qh) return qh(e, {
                    depth: f - i
                });
                if (l !== "symbol" && typeof e.inspect == "function") return e.inspect()
            }
            if (Ox(e)) {
                var z = [];
                return zf && zf.call(e, function(B, G) {
                    z.push(y(G, e, !0) + " => " + y(B, e))
                }), nm("Map", Xa.call(e), z, g)
            }
            if (kx(e)) {
                var X = [];
                return Hf && Hf.call(e, function(B) {
                    X.push(y(B, e))
                }), nm("Set", $a.call(e), X, g)
            }
            if (Lx(e)) return Kh("WeakMap");
            if (Fx(e)) return Kh("WeakSet");
            if (Bx(e)) return Kh("WeakRef");
            if (Ix(e)) return Is(y(Number(e)));
            if (Mx(e)) return Is(y($h.call(e)));
            if (Rx(e)) return Is(vx.call(e));
            if (Cx(e)) return Is(y(String(e)));
            if (!Ax(e) && !tm(e)) {
                var O = Va(e, y),
                    M = qf ? qf(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                    $ = e instanceof Object ? "" : "null prototype",
                    nt = !M && we && Object(e) === e && we in e ? Xh.call(Ti(e), 8, -1) : $ ? "Object" : "",
                    Y = M || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                    q = Y + (nt || $ ? "[" + Lr.call($f.call([], nt || [], $ || []), ": ") + "] " : "");
                return O.length === 0 ? q + "{}" : g ? q + "{" + Zh(O, g) + "}" : q + "{ " + Lr.call(O, ", ") + " }"
            }
            return String(e)
        };

    function Jf(t, e, r) {
        var i = (r.quoteStyle || e) === "double" ? '"' : "'";
        return i + t + i
    }

    function Sx(t) {
        return bi.call(String(t), /"/g, "&quot;")
    }

    function Qh(t) {
        return Ti(t) === "[object Array]" && (!we || !(typeof t == "object" && we in t))
    }

    function Ax(t) {
        return Ti(t) === "[object Date]" && (!we || !(typeof t == "object" && we in t))
    }

    function tm(t) {
        return Ti(t) === "[object RegExp]" && (!we || !(typeof t == "object" && we in t))
    }

    function Px(t) {
        return Ti(t) === "[object Error]" && (!we || !(typeof t == "object" && we in t))
    }

    function Cx(t) {
        return Ti(t) === "[object String]" && (!we || !(typeof t == "object" && we in t))
    }

    function Ix(t) {
        return Ti(t) === "[object Number]" && (!we || !(typeof t == "object" && we in t))
    }

    function Rx(t) {
        return Ti(t) === "[object Boolean]" && (!we || !(typeof t == "object" && we in t))
    }

    function em(t) {
        if (Dn) return t && typeof t == "object" && t instanceof Symbol;
        if (typeof t == "symbol") return !0;
        if (!t || typeof t != "object" || !Yh) return !1;
        try {
            return Yh.call(t), !0
        } catch (e) {}
        return !1
    }

    function Mx(t) {
        if (!t || typeof t != "object" || !$h) return !1;
        try {
            return $h.call(t), !0
        } catch (e) {}
        return !1
    }
    var Dx = Object.prototype.hasOwnProperty || function(t) {
        return t in this
    };

    function Ei(t, e) {
        return Dx.call(t, e)
    }

    function Ti(t) {
        return xx.call(t)
    }

    function Nx(t) {
        if (t.name) return t.name;
        var e = bx.call(_x.call(t), /^function\s*([\w$]+)/);
        return e ? e[1] : null
    }

    function rm(t, e) {
        if (t.indexOf) return t.indexOf(e);
        for (var r = 0, i = t.length; r < i; r++)
            if (t[r] === e) return r;
        return -1
    }

    function Ox(t) {
        if (!Xa || !t || typeof t != "object") return !1;
        try {
            Xa.call(t);
            try {
                $a.call(t)
            } catch (e) {
                return !0
            }
            return t instanceof Map
        } catch (e) {}
        return !1
    }

    function Lx(t) {
        if (!Ps || !t || typeof t != "object") return !1;
        try {
            Ps.call(t, Ps);
            try {
                Cs.call(t, Cs)
            } catch (e) {
                return !0
            }
            return t instanceof WeakMap
        } catch (e) {}
        return !1
    }

    function Bx(t) {
        if (!jf || !t || typeof t != "object") return !1;
        try {
            return jf.call(t), !0
        } catch (e) {}
        return !1
    }

    function kx(t) {
        if (!$a || !t || typeof t != "object") return !1;
        try {
            $a.call(t);
            try {
                Xa.call(t)
            } catch (e) {
                return !0
            }
            return t instanceof Set
        } catch (e) {}
        return !1
    }

    function Fx(t) {
        if (!Cs || !t || typeof t != "object") return !1;
        try {
            Cs.call(t, Cs);
            try {
                Ps.call(t, Ps)
            } catch (e) {
                return !0
            }
            return t instanceof WeakSet
        } catch (e) {}
        return !1
    }

    function Ux(t) {
        return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
    }

    function im(t, e) {
        if (t.length > e.maxStringLength) {
            var r = t.length - e.maxStringLength,
                i = "... " + r + " more character" + (r > 1 ? "s" : "");
            return im(Xh.call(t, 0, e.maxStringLength), e) + i
        }
        var n = bi.call(bi.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Gx);
        return Jf(n, "single", e)
    }

    function Gx(t) {
        var e = t.charCodeAt(0),
            r = {
                8: "b",
                9: "t",
                10: "n",
                12: "f",
                13: "r"
            }[e];
        return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + Ex.call(e.toString(16))
    }

    function Is(t) {
        return "Object(" + t + ")"
    }

    function Kh(t) {
        return t + " { ? }"
    }

    function nm(t, e, r, i) {
        var n = i ? Zh(r, i) : Lr.call(r, ", ");
        return t + " (" + e + ") {" + n + "}"
    }

    function zx(t) {
        for (var e = 0; e < t.length; e++)
            if (rm(t[e], `
`) >= 0) return !1;
        return !0
    }

    function Hx(t, e) {
        var r;
        if (t.indent === "	") r = "	";
        else if (typeof t.indent == "number" && t.indent > 0) r = Lr.call(Array(t.indent + 1), " ");
        else return null;
        return {
            base: r,
            prev: Lr.call(Array(e + 1), r)
        }
    }

    function Zh(t, e) {
        if (t.length === 0) return "";
        var r = `
` + e.prev + e.base;
        return r + Lr.call(t, "," + r) + `
` + e.prev
    }

    function Va(t, e) {
        var r = Qh(t),
            i = [];
        if (r) {
            i.length = t.length;
            for (var n = 0; n < t.length; n++) i[n] = Ei(t, n) ? e(t[n], t) : ""
        }
        var a = typeof Vh == "function" ? Vh(t) : [],
            l;
        if (Dn) {
            l = {};
            for (var h = 0; h < a.length; h++) l["$" + a[h]] = a[h]
        }
        for (var c in t) Ei(t, c) && (r && String(Number(c)) === c && c < t.length || Dn && l["$" + c] instanceof Symbol || (Xf.call(/[^\w$]/, c) ? i.push(e(c, t) + ": " + e(t[c], t)) : i.push(c + ": " + e(t[c], t))));
        if (typeof Vh == "function")
            for (var d = 0; d < a.length; d++) Yf.call(t, a[d]) && i.push("[" + e(a[d]) + "]: " + e(t[a[d]], t));
        return i
    }
    var Jh = Gh,
        Nn = cx,
        jx = wx,
        Wx = Jh("%TypeError%"),
        Ya = Jh("%WeakMap%", !0),
        qa = Jh("%Map%", !0),
        Xx = Nn("WeakMap.prototype.get", !0),
        $x = Nn("WeakMap.prototype.set", !0),
        Vx = Nn("WeakMap.prototype.has", !0),
        Yx = Nn("Map.prototype.get", !0),
        qx = Nn("Map.prototype.set", !0),
        Qx = Nn("Map.prototype.has", !0),
        tu = function(t, e) {
            for (var r = t, i;
                (i = r.next) !== null; r = i)
                if (i.key === e) return r.next = i.next, i.next = t.next, t.next = i, i
        },
        Kx = function(t, e) {
            var r = tu(t, e);
            return r && r.value
        },
        Zx = function(t, e, r) {
            var i = tu(t, e);
            i ? i.value = r : t.next = {
                key: e,
                next: t.next,
                value: r
            }
        },
        Jx = function(t, e) {
            return !!tu(t, e)
        },
        t_ = function() {
            var t, e, r, i = {
                assert: function(n) {
                    if (!i.has(n)) throw new Wx("Side channel does not contain " + jx(n))
                },
                get: function(n) {
                    if (Ya && n && (typeof n == "object" || typeof n == "function")) {
                        if (t) return Xx(t, n)
                    } else if (qa) {
                        if (e) return Yx(e, n)
                    } else if (r) return Kx(r, n)
                },
                has: function(n) {
                    if (Ya && n && (typeof n == "object" || typeof n == "function")) {
                        if (t) return Vx(t, n)
                    } else if (qa) {
                        if (e) return Qx(e, n)
                    } else if (r) return Jx(r, n);
                    return !1
                },
                set: function(n, a) {
                    Ya && n && (typeof n == "object" || typeof n == "function") ? (t || (t = new Ya), $x(t, n, a)) : qa ? (e || (e = new qa), qx(e, n, a)) : (r || (r = {
                        key: {},
                        next: null
                    }), Zx(r, n, a))
                }
            };
            return i
        },
        e_ = String.prototype.replace,
        r_ = /%20/g,
        eu = {
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        },
        ru = {
            default: eu.RFC3986,
            formatters: {
                RFC1738: function(t) {
                    return e_.call(t, r_, "+")
                },
                RFC3986: function(t) {
                    return String(t)
                }
            },
            RFC1738: eu.RFC1738,
            RFC3986: eu.RFC3986
        },
        i_ = ru,
        iu = Object.prototype.hasOwnProperty,
        Vi = Array.isArray,
        Br = function() {
            for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
            return t
        }(),
        n_ = function(t) {
            for (; t.length > 1;) {
                var e = t.pop(),
                    r = e.obj[e.prop];
                if (Vi(r)) {
                    for (var i = [], n = 0; n < r.length; ++n) typeof r[n] < "u" && i.push(r[n]);
                    e.obj[e.prop] = i
                }
            }
        },
        sm = function(t, e) {
            for (var r = e && e.plainObjects ? Object.create(null) : {}, i = 0; i < t.length; ++i) typeof t[i] < "u" && (r[i] = t[i]);
            return r
        },
        s_ = function t(e, r, i) {
            if (!r) return e;
            if (typeof r != "object") {
                if (Vi(e)) e.push(r);
                else if (e && typeof e == "object")(i && (i.plainObjects || i.allowPrototypes) || !iu.call(Object.prototype, r)) && (e[r] = !0);
                else return [e, r];
                return e
            }
            if (!e || typeof e != "object") return [e].concat(r);
            var n = e;
            return Vi(e) && !Vi(r) && (n = sm(e, i)), Vi(e) && Vi(r) ? (r.forEach(function(a, l) {
                if (iu.call(e, l)) {
                    var h = e[l];
                    h && typeof h == "object" && a && typeof a == "object" ? e[l] = t(h, a, i) : e.push(a)
                } else e[l] = a
            }), e) : Object.keys(r).reduce(function(a, l) {
                var h = r[l];
                return iu.call(a, l) ? a[l] = t(a[l], h, i) : a[l] = h, a
            }, n)
        },
        a_ = function(t, e) {
            return Object.keys(e).reduce(function(r, i) {
                return r[i] = e[i], r
            }, t)
        },
        o_ = function(t, e, r) {
            var i = t.replace(/\+/g, " ");
            if (r === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
                return decodeURIComponent(i)
            } catch (n) {
                return i
            }
        },
        l_ = function(t, e, r, i, n) {
            if (t.length === 0) return t;
            var a = t;
            if (typeof t == "symbol" ? a = Symbol.prototype.toString.call(t) : typeof t != "string" && (a = String(t)), r === "iso-8859-1") return escape(a).replace(/%u[0-9a-f]{4}/gi, function(d) {
                return "%26%23" + parseInt(d.slice(2), 16) + "%3B"
            });
            for (var l = "", h = 0; h < a.length; ++h) {
                var c = a.charCodeAt(h);
                if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || n === i_.RFC1738 && (c === 40 || c === 41)) {
                    l += a.charAt(h);
                    continue
                }
                if (c < 128) {
                    l = l + Br[c];
                    continue
                }
                if (c < 2048) {
                    l = l + (Br[192 | c >> 6] + Br[128 | c & 63]);
                    continue
                }
                if (c < 55296 || c >= 57344) {
                    l = l + (Br[224 | c >> 12] + Br[128 | c >> 6 & 63] + Br[128 | c & 63]);
                    continue
                }
                h += 1, c = 65536 + ((c & 1023) << 10 | a.charCodeAt(h) & 1023), l += Br[240 | c >> 18] + Br[128 | c >> 12 & 63] + Br[128 | c >> 6 & 63] + Br[128 | c & 63]
            }
            return l
        },
        h_ = function(t) {
            for (var e = [{
                    obj: {
                        o: t
                    },
                    prop: "o"
                }], r = [], i = 0; i < e.length; ++i)
                for (var n = e[i], a = n.obj[n.prop], l = Object.keys(a), h = 0; h < l.length; ++h) {
                    var c = l[h],
                        d = a[c];
                    typeof d == "object" && d !== null && r.indexOf(d) === -1 && (e.push({
                        obj: a,
                        prop: c
                    }), r.push(d))
                }
            return n_(e), t
        },
        u_ = function(t) {
            return Object.prototype.toString.call(t) === "[object RegExp]"
        },
        c_ = function(t) {
            return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
        },
        d_ = function(t, e) {
            return [].concat(t, e)
        },
        p_ = function(t, e) {
            if (Vi(t)) {
                for (var r = [], i = 0; i < t.length; i += 1) r.push(e(t[i]));
                return r
            }
            return e(t)
        },
        am = {
            arrayToObject: sm,
            assign: a_,
            combine: d_,
            compact: h_,
            decode: o_,
            encode: l_,
            isBuffer: c_,
            isRegExp: u_,
            maybeMap: p_,
            merge: s_
        },
        om = t_,
        Qa = am,
        Rs = ru,
        f_ = Object.prototype.hasOwnProperty,
        lm = {
            brackets: function(t) {
                return t + "[]"
            },
            comma: "comma",
            indices: function(t, e) {
                return t + "[" + e + "]"
            },
            repeat: function(t) {
                return t
            }
        },
        ii = Array.isArray,
        m_ = Array.prototype.push,
        hm = function(t, e) {
            m_.apply(t, ii(e) ? e : [e])
        },
        g_ = Date.prototype.toISOString,
        um = Rs.default,
        Se = {
            addQueryPrefix: !1,
            allowDots: !1,
            charset: "utf-8",
            charsetSentinel: !1,
            delimiter: "&",
            encode: !0,
            encoder: Qa.encode,
            encodeValuesOnly: !1,
            format: um,
            formatter: Rs.formatters[um],
            indices: !1,
            serializeDate: function(t) {
                return g_.call(t)
            },
            skipNulls: !1,
            strictNullHandling: !1
        },
        y_ = function(t) {
            return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
        },
        nu = {},
        v_ = function t(e, r, i, n, a, l, h, c, d, f, g, y, x, _, E, w) {
            for (var I = e, S = w, T = 0, P = !1;
                (S = S.get(nu)) !== void 0 && !P;) {
                var z = S.get(e);
                if (T += 1, typeof z < "u") {
                    if (z === T) throw new RangeError("Cyclic object value");
                    P = !0
                }
                typeof S.get(nu) > "u" && (T = 0)
            }
            if (typeof c == "function" ? I = c(r, I) : I instanceof Date ? I = g(I) : i === "comma" && ii(I) && (I = Qa.maybeMap(I, function(ft) {
                    return ft instanceof Date ? g(ft) : ft
                })), I === null) {
                if (a) return h && !_ ? h(r, Se.encoder, E, "key", y) : r;
                I = ""
            }
            if (y_(I) || Qa.isBuffer(I)) {
                if (h) {
                    var X = _ ? r : h(r, Se.encoder, E, "key", y);
                    return [x(X) + "=" + x(h(I, Se.encoder, E, "value", y))]
                }
                return [x(r) + "=" + x(String(I))]
            }
            var O = [];
            if (typeof I > "u") return O;
            var M;
            if (i === "comma" && ii(I)) _ && h && (I = Qa.maybeMap(I, h)), M = [{
                value: I.length > 0 ? I.join(",") || null : void 0
            }];
            else if (ii(c)) M = c;
            else {
                var $ = Object.keys(I);
                M = d ? $.sort(d) : $
            }
            for (var nt = n && ii(I) && I.length === 1 ? r + "[]" : r, Y = 0; Y < M.length; ++Y) {
                var q = M[Y],
                    B = typeof q == "object" && typeof q.value < "u" ? q.value : I[q];
                if (!(l && B === null)) {
                    var G = ii(I) ? typeof i == "function" ? i(nt, q) : nt : nt + (f ? "." + q : "[" + q + "]");
                    w.set(e, T);
                    var pt = om();
                    pt.set(nu, w), hm(O, t(B, G, i, n, a, l, i === "comma" && _ && ii(I) ? null : h, c, d, f, g, y, x, _, E, pt))
                }
            }
            return O
        },
        x_ = function(t) {
            if (!t) return Se;
            if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
            var e = t.charset || Se.charset;
            if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var r = Rs.default;
            if (typeof t.format < "u") {
                if (!f_.call(Rs.formatters, t.format)) throw new TypeError("Unknown format option provided.");
                r = t.format
            }
            var i = Rs.formatters[r],
                n = Se.filter;
            return (typeof t.filter == "function" || ii(t.filter)) && (n = t.filter), {
                addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Se.addQueryPrefix,
                allowDots: typeof t.allowDots > "u" ? Se.allowDots : !!t.allowDots,
                charset: e,
                charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Se.charsetSentinel,
                delimiter: typeof t.delimiter > "u" ? Se.delimiter : t.delimiter,
                encode: typeof t.encode == "boolean" ? t.encode : Se.encode,
                encoder: typeof t.encoder == "function" ? t.encoder : Se.encoder,
                encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Se.encodeValuesOnly,
                filter: n,
                format: r,
                formatter: i,
                serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Se.serializeDate,
                skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Se.skipNulls,
                sort: typeof t.sort == "function" ? t.sort : null,
                strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Se.strictNullHandling
            }
        },
        __ = function(t, e) {
            var r = t,
                i = x_(e),
                n, a;
            typeof i.filter == "function" ? (a = i.filter, r = a("", r)) : ii(i.filter) && (a = i.filter, n = a);
            var l = [];
            if (typeof r != "object" || r === null) return "";
            var h;
            e && e.arrayFormat in lm ? h = e.arrayFormat : e && "indices" in e ? h = e.indices ? "indices" : "repeat" : h = "indices";
            var c = lm[h];
            if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
            var d = c === "comma" && e && e.commaRoundTrip;
            n || (n = Object.keys(r)), i.sort && n.sort(i.sort);
            for (var f = om(), g = 0; g < n.length; ++g) {
                var y = n[g];
                i.skipNulls && r[y] === null || hm(l, v_(r[y], y, c, d, i.strictNullHandling, i.skipNulls, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, f))
            }
            var x = l.join(i.delimiter),
                _ = i.addQueryPrefix === !0 ? "?" : "";
            return i.charsetSentinel && (i.charset === "iso-8859-1" ? _ += "utf8=%26%2310003%3B&" : _ += "utf8=%E2%9C%93&"), x.length > 0 ? _ + x : ""
        },
        On = am,
        su = Object.prototype.hasOwnProperty,
        b_ = Array.isArray,
        ue = {
            allowDots: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decoder: On.decode,
            delimiter: "&",
            depth: 5,
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictNullHandling: !1
        },
        E_ = function(t) {
            return t.replace(/&#(\d+);/g, function(e, r) {
                return String.fromCharCode(parseInt(r, 10))
            })
        },
        cm = function(t, e) {
            return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
        },
        T_ = "utf8=%26%2310003%3B",
        w_ = "utf8=%E2%9C%93",
        S_ = function(t, e) {
            var r = {
                    __proto__: null
                },
                i = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
                n = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit,
                a = i.split(e.delimiter, n),
                l = -1,
                h, c = e.charset;
            if (e.charsetSentinel)
                for (h = 0; h < a.length; ++h) a[h].indexOf("utf8=") === 0 && (a[h] === w_ ? c = "utf-8" : a[h] === T_ && (c = "iso-8859-1"), l = h, h = a.length);
            for (h = 0; h < a.length; ++h)
                if (h !== l) {
                    var d = a[h],
                        f = d.indexOf("]="),
                        g = f === -1 ? d.indexOf("=") : f + 1,
                        y, x;
                    g === -1 ? (y = e.decoder(d, ue.decoder, c, "key"), x = e.strictNullHandling ? null : "") : (y = e.decoder(d.slice(0, g), ue.decoder, c, "key"), x = On.maybeMap(cm(d.slice(g + 1), e), function(_) {
                        return e.decoder(_, ue.decoder, c, "value")
                    })), x && e.interpretNumericEntities && c === "iso-8859-1" && (x = E_(x)), d.indexOf("[]=") > -1 && (x = b_(x) ? [x] : x), su.call(r, y) ? r[y] = On.combine(r[y], x) : r[y] = x
                }
            return r
        },
        A_ = function(t, e, r, i) {
            for (var n = i ? e : cm(e, r), a = t.length - 1; a >= 0; --a) {
                var l, h = t[a];
                if (h === "[]" && r.parseArrays) l = [].concat(n);
                else {
                    l = r.plainObjects ? Object.create(null) : {};
                    var c = h.charAt(0) === "[" && h.charAt(h.length - 1) === "]" ? h.slice(1, -1) : h,
                        d = parseInt(c, 10);
                    !r.parseArrays && c === "" ? l = {
                        0: n
                    } : !isNaN(d) && h !== c && String(d) === c && d >= 0 && r.parseArrays && d <= r.arrayLimit ? (l = [], l[d] = n) : c !== "__proto__" && (l[c] = n)
                }
                n = l
            }
            return n
        },
        P_ = function(t, e, r, i) {
            if (t) {
                var n = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
                    a = /(\[[^[\]]*])/,
                    l = /(\[[^[\]]*])/g,
                    h = r.depth > 0 && a.exec(n),
                    c = h ? n.slice(0, h.index) : n,
                    d = [];
                if (c) {
                    if (!r.plainObjects && su.call(Object.prototype, c) && !r.allowPrototypes) return;
                    d.push(c)
                }
                for (var f = 0; r.depth > 0 && (h = l.exec(n)) !== null && f < r.depth;) {
                    if (f += 1, !r.plainObjects && su.call(Object.prototype, h[1].slice(1, -1)) && !r.allowPrototypes) return;
                    d.push(h[1])
                }
                return h && d.push("[" + n.slice(h.index) + "]"), A_(d, e, r, i)
            }
        },
        C_ = function(t) {
            if (!t) return ue;
            if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
            if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var e = typeof t.charset > "u" ? ue.charset : t.charset;
            return {
                allowDots: typeof t.allowDots > "u" ? ue.allowDots : !!t.allowDots,
                allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : ue.allowPrototypes,
                allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : ue.allowSparse,
                arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : ue.arrayLimit,
                charset: e,
                charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : ue.charsetSentinel,
                comma: typeof t.comma == "boolean" ? t.comma : ue.comma,
                decoder: typeof t.decoder == "function" ? t.decoder : ue.decoder,
                delimiter: typeof t.delimiter == "string" || On.isRegExp(t.delimiter) ? t.delimiter : ue.delimiter,
                depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : ue.depth,
                ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
                interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : ue.interpretNumericEntities,
                parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : ue.parameterLimit,
                parseArrays: t.parseArrays !== !1,
                plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : ue.plainObjects,
                strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : ue.strictNullHandling
            }
        },
        I_ = function(t, e) {
            var r = C_(e);
            if (t === "" || t === null || typeof t > "u") return r.plainObjects ? Object.create(null) : {};
            for (var i = typeof t == "string" ? S_(t, r) : t, n = r.plainObjects ? Object.create(null) : {}, a = Object.keys(i), l = 0; l < a.length; ++l) {
                var h = a[l],
                    c = P_(h, i[h], r, typeof t == "string");
                n = On.merge(n, c, r)
            }
            return r.allowSparse === !0 ? n : On.compact(n)
        },
        R_ = __,
        M_ = I_,
        D_ = ru,
        N_ = {
            formats: D_,
            parse: M_,
            stringify: R_
        },
        O_ = Fv;

    function vr() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
    }
    var L_ = /^([a-z0-9.+-]+:)/i,
        B_ = /:[0-9]*$/,
        k_ = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
        F_ = ["<", ">", '"', "`", " ", "\r", `
`, "	"],
        U_ = ["{", "}", "|", "\\", "^", "`"].concat(F_),
        au = ["'"].concat(U_),
        dm = ["%", "/", "?", ";", "#"].concat(au),
        pm = ["/", "?", "#"],
        G_ = 255,
        fm = /^[+a-z0-9A-Z_-]{0,63}$/,
        z_ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        H_ = {
            javascript: !0,
            "javascript:": !0
        },
        ou = {
            javascript: !0,
            "javascript:": !0
        },
        Ln = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
        },
        lu = N_;

    function Ka(t, e, r) {
        if (t && typeof t == "object" && t instanceof vr) return t;
        var i = new vr;
        return i.parse(t, e, r), i
    }
    vr.prototype.parse = function(t, e, r) {
        if (typeof t != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
        var i = t.indexOf("?"),
            n = i !== -1 && i < t.indexOf("#") ? "?" : "#",
            a = t.split(n),
            l = /\\/g;
        a[0] = a[0].replace(l, "/"), t = a.join(n);
        var h = t;
        if (h = h.trim(), !r && t.split("#").length === 1) {
            var c = k_.exec(h);
            if (c) return this.path = h, this.href = h, this.pathname = c[1], c[2] ? (this.search = c[2], e ? this.query = lu.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this
        }
        var d = L_.exec(h);
        if (d) {
            d = d[0];
            var f = d.toLowerCase();
            this.protocol = f, h = h.substr(d.length)
        }
        if (r || d || h.match(/^\/\/[^@/]+@[^@/]+/)) {
            var g = h.substr(0, 2) === "//";
            g && !(d && ou[d]) && (h = h.substr(2), this.slashes = !0)
        }
        if (!ou[d] && (g || d && !Ln[d])) {
            for (var y = -1, x = 0; x < pm.length; x++) {
                var _ = h.indexOf(pm[x]);
                _ !== -1 && (y === -1 || _ < y) && (y = _)
            }
            var E, w;
            y === -1 ? w = h.lastIndexOf("@") : w = h.lastIndexOf("@", y), w !== -1 && (E = h.slice(0, w), h = h.slice(w + 1), this.auth = decodeURIComponent(E)), y = -1;
            for (var x = 0; x < dm.length; x++) {
                var _ = h.indexOf(dm[x]);
                _ !== -1 && (y === -1 || _ < y) && (y = _)
            }
            y === -1 && (y = h.length), this.host = h.slice(0, y), h = h.slice(y), this.parseHost(), this.hostname = this.hostname || "";
            var I = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!I)
                for (var S = this.hostname.split(/\./), x = 0, T = S.length; x < T; x++) {
                    var P = S[x];
                    if (P && !P.match(fm)) {
                        for (var z = "", X = 0, O = P.length; X < O; X++) P.charCodeAt(X) > 127 ? z += "x" : z += P[X];
                        if (!z.match(fm)) {
                            var M = S.slice(0, x),
                                $ = S.slice(x + 1),
                                nt = P.match(z_);
                            nt && (M.push(nt[1]), $.unshift(nt[2])), $.length && (h = "/" + $.join(".") + h), this.hostname = M.join(".");
                            break
                        }
                    }
                }
            this.hostname.length > G_ ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), I || (this.hostname = O_.toASCII(this.hostname));
            var Y = this.port ? ":" + this.port : "",
                q = this.hostname || "";
            this.host = q + Y, this.href += this.host, I && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), h[0] !== "/" && (h = "/" + h))
        }
        if (!H_[f])
            for (var x = 0, T = au.length; x < T; x++) {
                var B = au[x];
                if (h.indexOf(B) !== -1) {
                    var G = encodeURIComponent(B);
                    G === B && (G = escape(B)), h = h.split(B).join(G)
                }
            }
        var pt = h.indexOf("#");
        pt !== -1 && (this.hash = h.substr(pt), h = h.slice(0, pt));
        var ft = h.indexOf("?");
        if (ft !== -1 ? (this.search = h.substr(ft), this.query = h.substr(ft + 1), e && (this.query = lu.parse(this.query)), h = h.slice(0, ft)) : e && (this.search = "", this.query = {}), h && (this.pathname = h), Ln[f] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            var Y = this.pathname || "",
                J = this.search || "";
            this.path = Y + J
        }
        return this.href = this.format(), this
    };

    function j_(t) {
        return typeof t == "string" && (t = Ka(t)), t instanceof vr ? t.format() : vr.prototype.format.call(t)
    }
    vr.prototype.format = function() {
        var t = this.auth || "";
        t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@");
        var e = this.protocol || "",
            r = this.pathname || "",
            i = this.hash || "",
            n = !1,
            a = "";
        this.host ? n = t + this.host : this.hostname && (n = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (a = lu.stringify(this.query, {
            arrayFormat: "repeat",
            encodeValuesOnly: !0,
            addQueryPrefix: !1
        }));
        var l = this.search || a && "?" + a || "";
        return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || Ln[e]) && n !== !1 ? (n = "//" + (n || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), l && l.charAt(0) !== "?" && (l = "?" + l), r = r.replace(/[?#]/g, function(h) {
            return encodeURIComponent(h)
        }), l = l.replace("#", "%23"), e + n + r + l + i
    };

    function W_(t, e) {
        return Ka(t, !1, !0).resolve(e)
    }
    vr.prototype.resolve = function(t) {
        return this.resolveObject(Ka(t, !1, !0)).format()
    }, vr.prototype.resolveObject = function(t) {
        if (typeof t == "string") {
            var e = new vr;
            e.parse(t, !1, !0), t = e
        }
        for (var r = new vr, i = Object.keys(this), n = 0; n < i.length; n++) {
            var a = i[n];
            r[a] = this[a]
        }
        if (r.hash = t.hash, t.href === "") return r.href = r.format(), r;
        if (t.slashes && !t.protocol) {
            for (var l = Object.keys(t), h = 0; h < l.length; h++) {
                var c = l[h];
                c !== "protocol" && (r[c] = t[c])
            }
            return Ln[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r
        }
        if (t.protocol && t.protocol !== r.protocol) {
            if (!Ln[t.protocol]) {
                for (var d = Object.keys(t), f = 0; f < d.length; f++) {
                    var g = d[f];
                    r[g] = t[g]
                }
                return r.href = r.format(), r
            }
            if (r.protocol = t.protocol, !t.host && !ou[t.protocol]) {
                for (var T = (t.pathname || "").split("/"); T.length && !(t.host = T.shift()););
                t.host || (t.host = ""), t.hostname || (t.hostname = ""), T[0] !== "" && T.unshift(""), T.length < 2 && T.unshift(""), r.pathname = T.join("/")
            } else r.pathname = t.pathname;
            if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
                var y = r.pathname || "",
                    x = r.search || "";
                r.path = y + x
            }
            return r.slashes = r.slashes || t.slashes, r.href = r.format(), r
        }
        var _ = r.pathname && r.pathname.charAt(0) === "/",
            E = t.host || t.pathname && t.pathname.charAt(0) === "/",
            w = E || _ || r.host && t.pathname,
            I = w,
            S = r.pathname && r.pathname.split("/") || [],
            T = t.pathname && t.pathname.split("/") || [],
            P = r.protocol && !Ln[r.protocol];
        if (P && (r.hostname = "", r.port = null, r.host && (S[0] === "" ? S[0] = r.host : S.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (T[0] === "" ? T[0] = t.host : T.unshift(t.host)), t.host = null), w = w && (T[0] === "" || S[0] === "")), E) r.host = t.host || t.host === "" ? t.host : r.host, r.hostname = t.hostname || t.hostname === "" ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, S = T;
        else if (T.length) S || (S = []), S.pop(), S = S.concat(T), r.search = t.search, r.query = t.query;
        else if (t.search != null) {
            if (P) {
                r.host = S.shift(), r.hostname = r.host;
                var z = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
                z && (r.auth = z.shift(), r.hostname = z.shift(), r.host = r.hostname)
            }
            return r.search = t.search, r.query = t.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r
        }
        if (!S.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
        for (var X = S.slice(-1)[0], O = (r.host || t.host || S.length > 1) && (X === "." || X === "..") || X === "", M = 0, $ = S.length; $ >= 0; $--) X = S[$], X === "." ? S.splice($, 1) : X === ".." ? (S.splice($, 1), M++) : M && (S.splice($, 1), M--);
        if (!w && !I)
            for (; M--; M) S.unshift("..");
        w && S[0] !== "" && (!S[0] || S[0].charAt(0) !== "/") && S.unshift(""), O && S.join("/").substr(-1) !== "/" && S.push("");
        var nt = S[0] === "" || S[0] && S[0].charAt(0) === "/";
        if (P) {
            r.hostname = nt ? "" : S.length ? S.shift() : "", r.host = r.hostname;
            var z = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
            z && (r.auth = z.shift(), r.hostname = z.shift(), r.host = r.hostname)
        }
        return w = w || r.host && S.length, w && !nt && S.unshift(""), S.length > 0 ? r.pathname = S.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r
    }, vr.prototype.parseHost = function() {
        var t = this.host,
            e = B_.exec(t);
        e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
    };
    var X_ = Ka,
        $_ = W_,
        V_ = j_;
    const mm = {
        parse: X_,
        format: V_,
        resolve: $_
    };

    function xr(t) {
        if (typeof t != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
    }

    function Ms(t) {
        return t.split("?")[0].split("#")[0]
    }

    function Y_(t) {
        return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
    }

    function q_(t, e, r) {
        return t.replace(new RegExp(Y_(e), "g"), r)
    }

    function Q_(t, e) {
        let r = "",
            i = 0,
            n = -1,
            a = 0,
            l = -1;
        for (let h = 0; h <= t.length; ++h) {
            if (h < t.length) l = t.charCodeAt(h);
            else {
                if (l === 47) break;
                l = 47
            }
            if (l === 47) {
                if (!(n === h - 1 || a === 1))
                    if (n !== h - 1 && a === 2) {
                        if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                            if (r.length > 2) {
                                const c = r.lastIndexOf("/");
                                if (c !== r.length - 1) {
                                    c === -1 ? (r = "", i = 0) : (r = r.slice(0, c), i = r.length - 1 - r.lastIndexOf("/")), n = h, a = 0;
                                    continue
                                }
                            } else if (r.length === 2 || r.length === 1) {
                                r = "", i = 0, n = h, a = 0;
                                continue
                            }
                        }
                        e && (r.length > 0 ? r += "/.." : r = "..", i = 2)
                    } else r.length > 0 ? r += `/${t.slice(n+1,h)}` : r = t.slice(n + 1, h), i = h - n - 1;
                n = h, a = 0
            } else l === 46 && a !== -1 ? ++a : a = -1
        }
        return r
    }
    const ce = {
            toPosix(t) {
                return q_(t, "\\", "/")
            },
            isUrl(t) {
                return /^https?:/.test(this.toPosix(t))
            },
            isDataUrl(t) {
                return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t)
            },
            hasProtocol(t) {
                return /^[^/:]+:\//.test(this.toPosix(t))
            },
            getProtocol(t) {
                xr(t), t = this.toPosix(t);
                let e = "";
                const r = /^file:\/\/\//.exec(t),
                    i = /^[^/:]+:\/\//.exec(t),
                    n = /^[^/:]+:\//.exec(t);
                if (r || i || n) {
                    const a = (r == null ? void 0 : r[0]) || (i == null ? void 0 : i[0]) || (n == null ? void 0 : n[0]);
                    e = a, t = t.slice(a.length)
                }
                return e
            },
            toAbsolute(t, e, r) {
                if (this.isDataUrl(t)) return t;
                const i = Ms(this.toPosix(e != null ? e : et.ADAPTER.getBaseUrl())),
                    n = Ms(this.toPosix(r != null ? r : this.rootname(i)));
                return xr(t), t = this.toPosix(t), t.startsWith("/") ? ce.join(n, t.slice(1)) : this.isAbsolute(t) ? t : this.join(i, t)
            },
            normalize(t) {
                if (t = this.toPosix(t), xr(t), t.length === 0) return ".";
                let e = "";
                const r = t.startsWith("/");
                this.hasProtocol(t) && (e = this.rootname(t), t = t.slice(e.length));
                const i = t.endsWith("/");
                return t = Q_(t, !1), t.length > 0 && i && (t += "/"), r ? `/${t}` : e + t
            },
            isAbsolute(t) {
                return xr(t), t = this.toPosix(t), this.hasProtocol(t) ? !0 : t.startsWith("/")
            },
            join(...t) {
                var r;
                if (t.length === 0) return ".";
                let e;
                for (let i = 0; i < t.length; ++i) {
                    const n = t[i];
                    if (xr(n), n.length > 0)
                        if (e === void 0) e = n;
                        else {
                            const a = (r = t[i - 1]) != null ? r : "";
                            this.extname(a) ? e += `/../${n}` : e += `/${n}`
                        }
                }
                return e === void 0 ? "." : this.normalize(e)
            },
            dirname(t) {
                if (xr(t), t.length === 0) return ".";
                t = this.toPosix(t);
                let e = t.charCodeAt(0);
                const r = e === 47;
                let i = -1,
                    n = !0;
                const a = this.getProtocol(t),
                    l = t;
                t = t.slice(a.length);
                for (let h = t.length - 1; h >= 1; --h)
                    if (e = t.charCodeAt(h), e === 47) {
                        if (!n) {
                            i = h;
                            break
                        }
                    } else n = !1;
                return i === -1 ? r ? "/" : this.isUrl(l) ? a + t : a : r && i === 1 ? "//" : a + t.slice(0, i)
            },
            rootname(t) {
                xr(t), t = this.toPosix(t);
                let e = "";
                if (t.startsWith("/") ? e = "/" : e = this.getProtocol(t), this.isUrl(t)) {
                    const r = t.indexOf("/", e.length);
                    r !== -1 ? e = t.slice(0, r) : e = t, e.endsWith("/") || (e += "/")
                }
                return e
            },
            basename(t, e) {
                xr(t), e && xr(e), t = Ms(this.toPosix(t));
                let r = 0,
                    i = -1,
                    n = !0,
                    a;
                if (e !== void 0 && e.length > 0 && e.length <= t.length) {
                    if (e.length === t.length && e === t) return "";
                    let l = e.length - 1,
                        h = -1;
                    for (a = t.length - 1; a >= 0; --a) {
                        const c = t.charCodeAt(a);
                        if (c === 47) {
                            if (!n) {
                                r = a + 1;
                                break
                            }
                        } else h === -1 && (n = !1, h = a + 1), l >= 0 && (c === e.charCodeAt(l) ? --l === -1 && (i = a) : (l = -1, i = h))
                    }
                    return r === i ? i = h : i === -1 && (i = t.length), t.slice(r, i)
                }
                for (a = t.length - 1; a >= 0; --a)
                    if (t.charCodeAt(a) === 47) {
                        if (!n) {
                            r = a + 1;
                            break
                        }
                    } else i === -1 && (n = !1, i = a + 1);
                return i === -1 ? "" : t.slice(r, i)
            },
            extname(t) {
                xr(t), t = Ms(this.toPosix(t));
                let e = -1,
                    r = 0,
                    i = -1,
                    n = !0,
                    a = 0;
                for (let l = t.length - 1; l >= 0; --l) {
                    const h = t.charCodeAt(l);
                    if (h === 47) {
                        if (!n) {
                            r = l + 1;
                            break
                        }
                        continue
                    }
                    i === -1 && (n = !1, i = l + 1), h === 46 ? e === -1 ? e = l : a !== 1 && (a = 1) : e !== -1 && (a = -1)
                }
                return e === -1 || i === -1 || a === 0 || a === 1 && e === i - 1 && e === r + 1 ? "" : t.slice(e, i)
            },
            parse(t) {
                xr(t);
                const e = {
                    root: "",
                    dir: "",
                    base: "",
                    ext: "",
                    name: ""
                };
                if (t.length === 0) return e;
                t = Ms(this.toPosix(t));
                let r = t.charCodeAt(0);
                const i = this.isAbsolute(t);
                let n;
                e.root = this.rootname(t), i || this.hasProtocol(t) ? n = 1 : n = 0;
                let a = -1,
                    l = 0,
                    h = -1,
                    c = !0,
                    d = t.length - 1,
                    f = 0;
                for (; d >= n; --d) {
                    if (r = t.charCodeAt(d), r === 47) {
                        if (!c) {
                            l = d + 1;
                            break
                        }
                        continue
                    }
                    h === -1 && (c = !1, h = d + 1), r === 46 ? a === -1 ? a = d : f !== 1 && (f = 1) : a !== -1 && (f = -1)
                }
                return a === -1 || h === -1 || f === 0 || f === 1 && a === h - 1 && a === l + 1 ? h !== -1 && (l === 0 && i ? e.base = e.name = t.slice(1, h) : e.base = e.name = t.slice(l, h)) : (l === 0 && i ? (e.name = t.slice(1, a), e.base = t.slice(1, h)) : (e.name = t.slice(l, a), e.base = t.slice(l, h)), e.ext = t.slice(a, h)), e.dir = this.dirname(t), e
            },
            sep: "/",
            delimiter: ":"
        },
        gm = {};

    function Tt(t, e, r = 3) {
        if (gm[e]) return;
        let i = new Error().stack;
        typeof i > "u" || (i = i.split(`
`).splice(r).join(`
`)), gm[e] = !0
    }

    function K_() {
        Tt("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
    }

    function Z_() {
        Tt("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
    }
    let hu;

    function ym() {
        return typeof hu > "u" && (hu = function() {
            var t;
            const e = {
                stencil: !0,
                failIfMajorPerformanceCaveat: et.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
            };
            try {
                if (!et.ADAPTER.getWebGLRenderingContext()) return !1;
                const r = et.ADAPTER.createCanvas();
                let i = r.getContext("webgl", e) || r.getContext("experimental-webgl", e);
                const n = !!((t = i == null ? void 0 : i.getContextAttributes()) != null && t.stencil);
                if (i) {
                    const a = i.getExtension("WEBGL_lose_context");
                    a && a.loseContext()
                }
                return i = null, n
            } catch (r) {
                return !1
            }
        }()), hu
    }
    var J_ = "#f0f8ff",
        tb = "#faebd7",
        eb = "#00ffff",
        rb = "#7fffd4",
        ib = "#f0ffff",
        nb = "#f5f5dc",
        sb = "#ffe4c4",
        ab = "#000000",
        ob = "#ffebcd",
        lb = "#0000ff",
        hb = "#8a2be2",
        ub = "#a52a2a",
        cb = "#deb887",
        db = "#5f9ea0",
        pb = "#7fff00",
        fb = "#d2691e",
        mb = "#ff7f50",
        gb = "#6495ed",
        yb = "#fff8dc",
        vb = "#dc143c",
        xb = "#00ffff",
        _b = "#00008b",
        bb = "#008b8b",
        Eb = "#b8860b",
        Tb = "#a9a9a9",
        wb = "#006400",
        Sb = "#a9a9a9",
        Ab = "#bdb76b",
        Pb = "#8b008b",
        Cb = "#556b2f",
        Ib = "#ff8c00",
        Rb = "#9932cc",
        Mb = "#8b0000",
        Db = "#e9967a",
        Nb = "#8fbc8f",
        Ob = "#483d8b",
        Lb = "#2f4f4f",
        Bb = "#2f4f4f",
        kb = "#00ced1",
        Fb = "#9400d3",
        Ub = "#ff1493",
        Gb = "#00bfff",
        zb = "#696969",
        Hb = "#696969",
        jb = "#1e90ff",
        Wb = "#b22222",
        Xb = "#fffaf0",
        $b = "#228b22",
        Vb = "#ff00ff",
        Yb = "#dcdcdc",
        qb = "#f8f8ff",
        Qb = "#daa520",
        Kb = "#ffd700",
        Zb = "#808080",
        Jb = "#008000",
        t1 = "#adff2f",
        e1 = "#808080",
        r1 = "#f0fff0",
        i1 = "#ff69b4",
        n1 = "#cd5c5c",
        s1 = "#4b0082",
        a1 = "#fffff0",
        o1 = "#f0e68c",
        l1 = "#fff0f5",
        h1 = "#e6e6fa",
        u1 = "#7cfc00",
        c1 = "#fffacd",
        d1 = "#add8e6",
        p1 = "#f08080",
        f1 = "#e0ffff",
        m1 = "#fafad2",
        g1 = "#d3d3d3",
        y1 = "#90ee90",
        v1 = "#d3d3d3",
        x1 = "#ffb6c1",
        _1 = "#ffa07a",
        b1 = "#20b2aa",
        E1 = "#87cefa",
        T1 = "#778899",
        w1 = "#778899",
        S1 = "#b0c4de",
        A1 = "#ffffe0",
        P1 = "#00ff00",
        C1 = "#32cd32",
        I1 = "#faf0e6",
        R1 = "#ff00ff",
        M1 = "#800000",
        D1 = "#66cdaa",
        N1 = "#0000cd",
        O1 = "#ba55d3",
        L1 = "#9370db",
        B1 = "#3cb371",
        k1 = "#7b68ee",
        F1 = "#00fa9a",
        U1 = "#48d1cc",
        G1 = "#c71585",
        z1 = "#191970",
        H1 = "#f5fffa",
        j1 = "#ffe4e1",
        W1 = "#ffe4b5",
        X1 = "#ffdead",
        $1 = "#000080",
        V1 = "#fdf5e6",
        Y1 = "#808000",
        q1 = "#6b8e23",
        Q1 = "#ffa500",
        K1 = "#ff4500",
        Z1 = "#da70d6",
        J1 = "#eee8aa",
        tE = "#98fb98",
        eE = "#afeeee",
        rE = "#db7093",
        iE = "#ffefd5",
        nE = "#ffdab9",
        sE = "#cd853f",
        aE = "#ffc0cb",
        oE = "#dda0dd",
        lE = "#b0e0e6",
        hE = "#800080",
        uE = "#663399",
        cE = "#ff0000",
        dE = "#bc8f8f",
        pE = "#4169e1",
        fE = "#8b4513",
        mE = "#fa8072",
        gE = "#f4a460",
        yE = "#2e8b57",
        vE = "#fff5ee",
        xE = "#a0522d",
        _E = "#c0c0c0",
        bE = "#87ceeb",
        EE = "#6a5acd",
        TE = "#708090",
        wE = "#708090",
        SE = "#fffafa",
        AE = "#00ff7f",
        PE = "#4682b4",
        CE = "#d2b48c",
        IE = "#008080",
        RE = "#d8bfd8",
        ME = "#ff6347",
        DE = "#40e0d0",
        NE = "#ee82ee",
        OE = "#f5deb3",
        LE = "#ffffff",
        BE = "#f5f5f5",
        kE = "#ffff00",
        FE = "#9acd32",
        UE = {
            aliceblue: J_,
            antiquewhite: tb,
            aqua: eb,
            aquamarine: rb,
            azure: ib,
            beige: nb,
            bisque: sb,
            black: ab,
            blanchedalmond: ob,
            blue: lb,
            blueviolet: hb,
            brown: ub,
            burlywood: cb,
            cadetblue: db,
            chartreuse: pb,
            chocolate: fb,
            coral: mb,
            cornflowerblue: gb,
            cornsilk: yb,
            crimson: vb,
            cyan: xb,
            darkblue: _b,
            darkcyan: bb,
            darkgoldenrod: Eb,
            darkgray: Tb,
            darkgreen: wb,
            darkgrey: Sb,
            darkkhaki: Ab,
            darkmagenta: Pb,
            darkolivegreen: Cb,
            darkorange: Ib,
            darkorchid: Rb,
            darkred: Mb,
            darksalmon: Db,
            darkseagreen: Nb,
            darkslateblue: Ob,
            darkslategray: Lb,
            darkslategrey: Bb,
            darkturquoise: kb,
            darkviolet: Fb,
            deeppink: Ub,
            deepskyblue: Gb,
            dimgray: zb,
            dimgrey: Hb,
            dodgerblue: jb,
            firebrick: Wb,
            floralwhite: Xb,
            forestgreen: $b,
            fuchsia: Vb,
            gainsboro: Yb,
            ghostwhite: qb,
            goldenrod: Qb,
            gold: Kb,
            gray: Zb,
            green: Jb,
            greenyellow: t1,
            grey: e1,
            honeydew: r1,
            hotpink: i1,
            indianred: n1,
            indigo: s1,
            ivory: a1,
            khaki: o1,
            lavenderblush: l1,
            lavender: h1,
            lawngreen: u1,
            lemonchiffon: c1,
            lightblue: d1,
            lightcoral: p1,
            lightcyan: f1,
            lightgoldenrodyellow: m1,
            lightgray: g1,
            lightgreen: y1,
            lightgrey: v1,
            lightpink: x1,
            lightsalmon: _1,
            lightseagreen: b1,
            lightskyblue: E1,
            lightslategray: T1,
            lightslategrey: w1,
            lightsteelblue: S1,
            lightyellow: A1,
            lime: P1,
            limegreen: C1,
            linen: I1,
            magenta: R1,
            maroon: M1,
            mediumaquamarine: D1,
            mediumblue: N1,
            mediumorchid: O1,
            mediumpurple: L1,
            mediumseagreen: B1,
            mediumslateblue: k1,
            mediumspringgreen: F1,
            mediumturquoise: U1,
            mediumvioletred: G1,
            midnightblue: z1,
            mintcream: H1,
            mistyrose: j1,
            moccasin: W1,
            navajowhite: X1,
            navy: $1,
            oldlace: V1,
            olive: Y1,
            olivedrab: q1,
            orange: Q1,
            orangered: K1,
            orchid: Z1,
            palegoldenrod: J1,
            palegreen: tE,
            paleturquoise: eE,
            palevioletred: rE,
            papayawhip: iE,
            peachpuff: nE,
            peru: sE,
            pink: aE,
            plum: oE,
            powderblue: lE,
            purple: hE,
            rebeccapurple: uE,
            red: cE,
            rosybrown: dE,
            royalblue: pE,
            saddlebrown: fE,
            salmon: mE,
            sandybrown: gE,
            seagreen: yE,
            seashell: vE,
            sienna: xE,
            silver: _E,
            skyblue: bE,
            slateblue: EE,
            slategray: TE,
            slategrey: wE,
            snow: SE,
            springgreen: AE,
            steelblue: PE,
            tan: CE,
            teal: IE,
            thistle: RE,
            tomato: ME,
            turquoise: DE,
            violet: NE,
            wheat: OE,
            white: LE,
            whitesmoke: BE,
            yellow: kE,
            yellowgreen: FE
        };
    xi = function(t, e = []) {
        return e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (t & 255) / 255, e
    };

    function uu(t) {
        let e = t.toString(16);
        return e = "000000".substring(0, 6 - e.length) + e, `#${e}`
    }

    function Za(t) {
        if (typeof t == "string" && (t = UE[t.toLowerCase()] || t, t[0] === "#" && (t = t.slice(1)), t.length === 3)) {
            const [e, r, i] = t;
            t = e + e + r + r + i + i
        }
        return parseInt(t, 16)
    }
    Wp = function(t) {
        return (t[0] * 255 << 16) + (t[1] * 255 << 8) + (t[2] * 255 | 0)
    };

    function GE() {
        const t = [],
            e = [];
        for (let i = 0; i < 32; i++) t[i] = i, e[i] = i;
        t[ut.NORMAL_NPM] = ut.NORMAL, t[ut.ADD_NPM] = ut.ADD, t[ut.SCREEN_NPM] = ut.SCREEN, e[ut.NORMAL] = ut.NORMAL_NPM, e[ut.ADD] = ut.ADD_NPM, e[ut.SCREEN] = ut.SCREEN_NPM;
        const r = [];
        return r.push(e), r.push(t), r
    }
    const cu = GE();

    function du(t, e) {
        return cu[e ? 1 : 0][t]
    }

    function vm(t, e, r, i) {
        return r = r || new Float32Array(4), i || i === void 0 ? (r[0] = t[0] * e, r[1] = t[1] * e, r[2] = t[2] * e) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]), r[3] = e, r
    }

    function Ja(t, e) {
        if (e === 1) return (e * 255 << 24) + t;
        if (e === 0) return 0;
        let r = t >> 16 & 255,
            i = t >> 8 & 255,
            n = t & 255;
        return r = r * e + .5 | 0, i = i * e + .5 | 0, n = n * e + .5 | 0, (e * 255 << 24) + (r << 16) + (i << 8) + n
    }

    function pu(t, e, r, i) {
        return r = r || new Float32Array(4), r[0] = (t >> 16 & 255) / 255, r[1] = (t >> 8 & 255) / 255, r[2] = (t & 255) / 255, (i || i === void 0) && (r[0] *= e, r[1] *= e, r[2] *= e), r[3] = e, r
    }
    const xm = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

    function _m(t, e = null) {
        const r = t * 6;
        if (e = e || new Uint16Array(r), e.length !== r) throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${r}`);
        for (let i = 0, n = 0; i < r; i += 6, n += 4) e[i + 0] = n + 0, e[i + 1] = n + 1, e[i + 2] = n + 2, e[i + 3] = n + 0, e[i + 4] = n + 2, e[i + 5] = n + 3;
        return e
    }

    function to(t) {
        if (t.BYTES_PER_ELEMENT === 4) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
        if (t.BYTES_PER_ELEMENT === 2) {
            if (t instanceof Uint16Array) return "Uint16Array"
        } else if (t.BYTES_PER_ELEMENT === 1 && t instanceof Uint8Array) return "Uint8Array";
        return null
    }
    const zE = {
        Float32Array,
        Uint32Array,
        Int32Array,
        Uint8Array
    };

    function HE(t, e) {
        let r = 0,
            i = 0;
        const n = {};
        for (let c = 0; c < t.length; c++) i += e[c], r += t[c].length;
        const a = new ArrayBuffer(r * 4);
        let l = null,
            h = 0;
        for (let c = 0; c < t.length; c++) {
            const d = e[c],
                f = t[c],
                g = to(f);
            n[g] || (n[g] = new zE[g](a)), l = n[g];
            for (let y = 0; y < f.length; y++) {
                const x = (y / d | 0) * i + h,
                    _ = y % d;
                l[x + _] = f[y]
            }
            h += d
        }
        return new Float32Array(a)
    }

    function Ds(t) {
        return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1
    }

    function fu(t) {
        return !(t & t - 1) && !!t
    }

    function mu(t) {
        let e = (t > 65535 ? 1 : 0) << 4;
        t >>>= e;
        let r = (t > 255 ? 1 : 0) << 3;
        return t >>>= r, e |= r, r = (t > 15 ? 1 : 0) << 2, t >>>= r, e |= r, r = (t > 3 ? 1 : 0) << 1, t >>>= r, e |= r, e | t >> 1
    }

    function Yi(t, e, r) {
        const i = t.length;
        let n;
        if (e >= i || r === 0) return;
        r = e + r > i ? i - e : r;
        const a = i - r;
        for (n = e; n < a; ++n) t[n] = t[n + r];
        t.length = a
    }

    function qi(t) {
        return t === 0 ? 0 : t < 0 ? -1 : 1
    }
    let jE = 0;

    function wi() {
        return ++jE
    }
    const bm = class {
        constructor(t, e, r, i) {
            this.left = t, this.top = e, this.right = r, this.bottom = i
        }
        get width() {
            return this.right - this.left
        }
        get height() {
            return this.bottom - this.top
        }
        isEmpty() {
            return this.left === this.right || this.top === this.bottom
        }
    };
    let eo = bm;
    eo.EMPTY = new bm(0, 0, 0, 0);
    const gu = {},
        ve = Object.create(null),
        Me = Object.create(null);

    function WE() {
        let t;
        for (t in ve) ve[t].destroy();
        for (t in Me) Me[t].destroy()
    }

    function XE() {
        let t;
        for (t in ve) delete ve[t];
        for (t in Me) delete Me[t]
    }
    class yu {
        constructor(e, r, i) {
            this._canvas = et.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = i || et.RESOLUTION, this.resize(e, r)
        }
        clear() {
            this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
        }
        resize(e, r) {
            this._checkDestroyed(), this._canvas.width = Math.round(e * this.resolution), this._canvas.height = Math.round(r * this.resolution)
        }
        destroy() {
            this._context = null, this._canvas = null
        }
        get width() {
            return this._checkDestroyed(), this._canvas.width
        }
        set width(e) {
            this._checkDestroyed(), this._canvas.width = Math.round(e)
        }
        get height() {
            return this._checkDestroyed(), this._canvas.height
        }
        set height(e) {
            this._checkDestroyed(), this._canvas.height = Math.round(e)
        }
        get canvas() {
            return this._checkDestroyed(), this._canvas
        }
        get context() {
            return this._checkDestroyed(), this._context
        }
        _checkDestroyed() {
            if (this._canvas === null) throw new TypeError("The CanvasRenderTarget has already been destroyed")
        }
    }

    function Em(t, e, r) {
        for (let i = 0, n = 4 * r * e; i < e; ++i, n += 4)
            if (t[n + 3] !== 0) return !1;
        return !0
    }

    function Tm(t, e, r, i, n) {
        const a = 4 * e;
        for (let l = i, h = i * a + 4 * r; l <= n; ++l, h += a)
            if (t[h + 3] !== 0) return !1;
        return !0
    }

    function wm(t) {
        const {
            width: e,
            height: r
        } = t, i = t.getContext("2d", {
            willReadFrequently: !0
        });
        if (i === null) throw new TypeError("Failed to get canvas 2D context");
        const n = i.getImageData(0, 0, e, r).data;
        let a = 0,
            l = 0,
            h = e - 1,
            c = r - 1;
        for (; l < r && Em(n, e, l);) ++l;
        if (l === r) return eo.EMPTY;
        for (; Em(n, e, c);) --c;
        for (; Tm(n, e, a, l, c);) ++a;
        for (; Tm(n, e, h, l, c);) --h;
        return ++h, ++c, new eo(a, l, h, c)
    }

    function Sm(t) {
        const e = wm(t),
            {
                width: r,
                height: i
            } = e;
        let n = null;
        if (!e.isEmpty()) {
            const a = t.getContext("2d");
            if (a === null) throw new TypeError("Failed to get canvas 2D context");
            n = a.getImageData(e.left, e.top, r, i)
        }
        return {
            width: r,
            height: i,
            data: n
        }
    }

    function $E(t) {
        const e = xm.exec(t);
        if (e) return {
            mediaType: e[1] ? e[1].toLowerCase() : void 0,
            subType: e[2] ? e[2].toLowerCase() : void 0,
            charset: e[3] ? e[3].toLowerCase() : void 0,
            encoding: e[4] ? e[4].toLowerCase() : void 0,
            data: e[5]
        }
    }
    let ro;

    function Am(t, e = globalThis.location) {
        if (t.startsWith("data:")) return "";
        e = e || globalThis.location, ro || (ro = document.createElement("a")), ro.href = t;
        const r = mm.parse(ro.href),
            i = !r.port && e.port === "" || r.port === e.port;
        return r.hostname !== e.hostname || !i || r.protocol !== e.protocol ? "anonymous" : ""
    }

    function ni(t, e = 1) {
        var r;
        const i = (r = et.RETINA_PREFIX) == null ? void 0 : r.exec(t);
        return i ? parseFloat(i[1]) : e
    }
    yv = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTextureCache: Me,
        BoundingBox: eo,
        CanvasRenderTarget: yu,
        DATA_URI: xm,
        EventEmitter: An,
        ProgramCache: gu,
        TextureCache: ve,
        clearTextureCache: XE,
        correctBlendMode: du,
        createIndicesForQuads: _m,
        decomposeDataUri: $E,
        deprecation: Tt,
        destroyTextureCache: WE,
        determineCrossOrigin: Am,
        earcut: Df,
        getBufferType: to,
        getCanvasBoundingBox: wm,
        getResolutionOfUrl: ni,
        hex2rgb: xi,
        hex2string: uu,
        interleaveTypedArrays: HE,
        isMobile: gr,
        isPow2: fu,
        isWebGLSupported: ym,
        log2: mu,
        nextPow2: Ds,
        path: ce,
        premultiplyBlendMode: cu,
        premultiplyRgba: vm,
        premultiplyTint: Ja,
        premultiplyTintToRgba: pu,
        removeItems: Yi,
        rgb2hex: Wp,
        sayHello: Z_,
        sign: qi,
        skipHello: K_,
        string2hex: Za,
        trimCanvas: Sm,
        uid: wi,
        url: mm
    }, Symbol.toStringTag, {
        value: "Module"
    })), Z = (t => (t.Renderer = "renderer", t.Application = "application", t.RendererSystem = "renderer-webgl-system", t.RendererPlugin = "renderer-webgl-plugin", t.CanvasRendererSystem = "renderer-canvas-system", t.CanvasRendererPlugin = "renderer-canvas-plugin", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t))(Z || {});
    let io, vu;
    io = t => {
        if (typeof t == "function" || typeof t == "object" && t.extension) {
            if (!t.extension) throw new Error("Extension class must have an extension object");
            t = Qd(Kr({}, typeof t.extension != "object" ? {
                type: t.extension
            } : t.extension), {
                ref: t
            })
        }
        if (typeof t == "object") t = Kr({}, t);
        else throw new Error("Invalid extension type");
        return typeof t.type == "string" && (t.type = [t.type]), t
    }, vu = (t, e) => {
        var r;
        return (r = io(t).priority) != null ? r : e
    }, lt = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...t) {
            return t.map(io).forEach(e => {
                e.type.forEach(r => {
                    var i, n;
                    return (n = (i = this._removeHandlers)[r]) == null ? void 0 : n.call(i, e)
                })
            }), this
        },
        add(...t) {
            return t.map(io).forEach(e => {
                e.type.forEach(r => {
                    const i = this._addHandlers,
                        n = this._queue;
                    i[r] ? i[r](e) : (n[r] = n[r] || [], n[r].push(e))
                })
            }), this
        },
        handle(t, e, r) {
            const i = this._addHandlers,
                n = this._removeHandlers;
            if (i[t] || n[t]) throw new Error(`Extension type ${t} already has a handler`);
            i[t] = e, n[t] = r;
            const a = this._queue;
            return a[t] && (a[t].forEach(l => e(l)), delete a[t]), this
        },
        handleByMap(t, e) {
            return this.handle(t, r => {
                e[r.name] = r.ref
            }, r => {
                delete e[r.name]
            })
        },
        handleByList(t, e, r = -1) {
            return this.handle(t, i => {
                e.includes(i.ref) || (e.push(i.ref), e.sort((n, a) => vu(a, r) - vu(n, r)))
            }, i => {
                const n = e.indexOf(i.ref);
                n !== -1 && e.splice(n, 1)
            })
        }
    }, Ia = class {
        constructor(t) {
            typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
        }
        get int8View() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
        }
        get uint8View() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
        }
        get int16View() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
        }
        get uint16View() {
            return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
        }
        get int32View() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
        }
        view(t) {
            return this[`${t}View`]
        }
        destroy() {
            this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
        }
        static sizeOf(t) {
            switch (t) {
                case "int8":
                case "uint8":
                    return 1;
                case "int16":
                case "uint16":
                    return 2;
                case "int32":
                case "uint32":
                case "float32":
                    return 4;
                default:
                    throw new Error(`${t} isn't a valid view type`)
            }
        }
    };
    const VE = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

    function YE(t) {
        let e = "";
        for (let r = 0; r < t; ++r) r > 0 && (e += `
else `), r < t - 1 && (e += `if(test == ${r}.0){}`);
        return e
    }
    Vp = function(t, e) {
        if (t === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
        const r = e.createShader(e.FRAGMENT_SHADER);
        for (;;) {
            const i = VE.replace(/%forloop%/gi, YE(t));
            if (e.shaderSource(r, i), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS)) t = t / 2 | 0;
            else break
        }
        return t
    };
    const xu = 0,
        _u = 1,
        bu = 2,
        Eu = 3,
        Tu = 4,
        wu = 5;
    ei = class {
        constructor() {
            this.data = 0, this.blendMode = ut.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
        }
        get blend() {
            return !!(this.data & 1 << xu)
        }
        set blend(t) {
            !!(this.data & 1 << xu) !== t && (this.data ^= 1 << xu)
        }
        get offsets() {
            return !!(this.data & 1 << _u)
        }
        set offsets(t) {
            !!(this.data & 1 << _u) !== t && (this.data ^= 1 << _u)
        }
        get culling() {
            return !!(this.data & 1 << bu)
        }
        set culling(t) {
            !!(this.data & 1 << bu) !== t && (this.data ^= 1 << bu)
        }
        get depthTest() {
            return !!(this.data & 1 << Eu)
        }
        set depthTest(t) {
            !!(this.data & 1 << Eu) !== t && (this.data ^= 1 << Eu)
        }
        get depthMask() {
            return !!(this.data & 1 << wu)
        }
        set depthMask(t) {
            !!(this.data & 1 << wu) !== t && (this.data ^= 1 << wu)
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << Tu)
        }
        set clockwiseFrontFace(t) {
            !!(this.data & 1 << Tu) !== t && (this.data ^= 1 << Tu)
        }
        get blendMode() {
            return this._blendMode
        }
        set blendMode(t) {
            this.blend = t !== ut.NONE, this._blendMode = t
        }
        get polygonOffset() {
            return this._polygonOffset
        }
        set polygonOffset(t) {
            this.offsets = !!t, this._polygonOffset = t
        }
        toString() {
            return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
        }
        static for2d() {
            const t = new ei;
            return t.depthTest = !1, t.blend = !0, t
        }
    }, wa = [], xh = function(t, e) {
        if (!t) return null;
        let r = "";
        if (typeof t == "string") {
            const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
            i && (r = i[1].toLowerCase())
        }
        for (let i = wa.length - 1; i >= 0; --i) {
            const n = wa[i];
            if (n.test && n.test(t, r)) return new n(t, e)
        }
        throw new Error("Unrecognized source type to auto-detect Resource")
    }, ze = class {
        constructor(t) {
            this.items = [], this._name = t, this._aliasCount = 0
        }
        emit(t, e, r, i, n, a, l, h) {
            if (arguments.length > 8) throw new Error("max arguments reached");
            const {
                name: c,
                items: d
            } = this;
            this._aliasCount++;
            for (let f = 0, g = d.length; f < g; f++) d[f][c](t, e, r, i, n, a, l, h);
            return d === this.items && this._aliasCount--, this
        }
        ensureNonAliasedItems() {
            this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
        }
        add(t) {
            return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
        }
        remove(t) {
            const e = this.items.indexOf(t);
            return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
        }
        contains(t) {
            return this.items.includes(t)
        }
        removeAll() {
            return this.ensureNonAliasedItems(), this.items.length = 0, this
        }
        destroy() {
            this.removeAll(), this.items = null, this._name = null
        }
        get empty() {
            return this.items.length === 0
        }
        get name() {
            return this._name
        }
    }, Object.defineProperties(ze.prototype, {
        dispatch: {
            value: ze.prototype.emit
        },
        run: {
            value: ze.prototype.emit
        }
    }), bn = class {
        constructor(t = 0, e = 0) {
            this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new ze("setRealSize"), this.onUpdate = new ze("update"), this.onError = new ze("onError")
        }
        bind(t) {
            this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
        }
        unbind(t) {
            this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
        }
        resize(t, e) {
            (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e))
        }
        get valid() {
            return !!this._width && !!this._height
        }
        update() {
            this.destroyed || this.onUpdate.emit()
        }
        load() {
            return Promise.resolve(this)
        }
        get width() {
            return this._width
        }
        get height() {
            return this._height
        }
        style(t, e, r) {
            return !1
        }
        dispose() {}
        destroy() {
            this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
        }
        static test(t, e) {
            return !1
        }
    }, yn = class extends bn {
        constructor(t, e) {
            const {
                width: r,
                height: i
            } = e || {};
            if (!r || !i) throw new Error("BufferResource width or height invalid");
            super(r, i), this.data = t
        }
        upload(t, e, r) {
            const i = t.gl;
            i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === tr.UNPACK);
            const n = e.realWidth,
                a = e.realHeight;
            return r.width === n && r.height === a ? i.texSubImage2D(e.target, 0, 0, 0, n, a, e.format, r.type, this.data) : (r.width = n, r.height = a, i.texImage2D(e.target, 0, r.internalFormat, n, a, 0, e.format, r.type, this.data)), !0
        }
        dispose() {
            this.data = null
        }
        static test(t) {
            return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
        }
    };
    const qE = {
            scaleMode: Rr.NEAREST,
            format: V.RGBA,
            alphaMode: tr.NPM
        },
        Bn = class extends An {
            constructor(t = null, e = null) {
                super(), e = Object.assign({}, Bn.defaultOptions, e);
                const {
                    alphaMode: r,
                    mipmap: i,
                    anisotropicLevel: n,
                    scaleMode: a,
                    width: l,
                    height: h,
                    wrapMode: c,
                    format: d,
                    type: f,
                    target: g,
                    resolution: y,
                    resourceOptions: x
                } = e;
                t && !(t instanceof bn) && (t = xh(t, x), t.internal = !0), this.resolution = y || et.RESOLUTION, this.width = Math.round((l || 0) * this.resolution) / this.resolution, this.height = Math.round((h || 0) * this.resolution) / this.resolution, this._mipmap = i, this.anisotropicLevel = n, this._wrapMode = c, this._scaleMode = a, this.format = d, this.type = f, this.target = g, this.alphaMode = r, this.uid = wi(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = l > 0 && h > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(t)
            }
            get realWidth() {
                return Math.round(this.width * this.resolution)
            }
            get realHeight() {
                return Math.round(this.height * this.resolution)
            }
            get mipmap() {
                return this._mipmap
            }
            set mipmap(t) {
                this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++)
            }
            get scaleMode() {
                return this._scaleMode
            }
            set scaleMode(t) {
                this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++)
            }
            get wrapMode() {
                return this._wrapMode
            }
            set wrapMode(t) {
                this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++)
            }
            setStyle(t, e) {
                let r;
                return t !== void 0 && t !== this.scaleMode && (this.scaleMode = t, r = !0), e !== void 0 && e !== this.mipmap && (this.mipmap = e, r = !0), r && this.dirtyStyleId++, this
            }
            setSize(t, e, r) {
                return r = r || this.resolution, this.setRealSize(t * r, e * r, r)
            }
            setRealSize(t, e, r) {
                return this.resolution = r || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(e) / this.resolution, this._refreshPOT(), this.update(), this
            }
            _refreshPOT() {
                this.isPowerOfTwo = fu(this.realWidth) && fu(this.realHeight)
            }
            setResolution(t) {
                const e = this.resolution;
                return e === t ? this : (this.resolution = t, this.valid && (this.width = Math.round(this.width * e) / t, this.height = Math.round(this.height * e) / t, this.emit("update", this)), this._refreshPOT(), this)
            }
            setResource(t) {
                if (this.resource === t) return this;
                if (this.resource) throw new Error("Resource can be set only once");
                return t.bind(this), this.resource = t, this
            }
            update() {
                this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
            }
            onError(t) {
                this.emit("error", this, t)
            }
            destroy() {
                this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Me[this.cacheId], delete ve[this.cacheId], this.cacheId = null), this.dispose(), Bn.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
            }
            dispose() {
                this.emit("dispose", this)
            }
            castToBaseTexture() {
                return this
            }
            static from(t, e, r = et.STRICT_TEXTURE_CACHE) {
                const i = typeof t == "string";
                let n = null;
                if (i) n = t;
                else {
                    if (!t._pixiId) {
                        const l = (e == null ? void 0 : e.pixiIdPrefix) || "pixiid";
                        t._pixiId = `${l}_${wi()}`
                    }
                    n = t._pixiId
                }
                let a = Me[n];
                if (i && r && !a) throw new Error(`The cacheId "${n}" does not exist in BaseTextureCache.`);
                return a || (a = new Bn(t, e), a.cacheId = n, Bn.addToCache(a, n)), a
            }
            static fromBuffer(t, e, r, i) {
                t = t || new Float32Array(e * r * 4);
                const n = new yn(t, {
                        width: e,
                        height: r
                    }),
                    a = t instanceof Float32Array ? dt.FLOAT : dt.UNSIGNED_BYTE;
                return new Bn(n, Object.assign({}, qE, i || {
                    width: e,
                    height: r,
                    type: a
                }))
            }
            static addToCache(t, e) {
                e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e), Me[e] && Me[e], Me[e] = t)
            }
            static removeFromCache(t) {
                if (typeof t == "string") {
                    const e = Me[t];
                    if (e) {
                        const r = e.textureCacheIds.indexOf(t);
                        return r > -1 && e.textureCacheIds.splice(r, 1), delete Me[t], e
                    }
                } else if (t != null && t.textureCacheIds) {
                    for (let e = 0; e < t.textureCacheIds.length; ++e) delete Me[t.textureCacheIds[e]];
                    return t.textureCacheIds.length = 0, t
                }
                return null
            }
        };
    mt = Bn, mt.defaultOptions = {
        mipmap: fr.POW2,
        anisotropicLevel: 0,
        scaleMode: Rr.LINEAR,
        wrapMode: Nr.CLAMP,
        alphaMode: tr.UNPACK,
        target: Gi.TEXTURE_2D,
        format: V.RGBA,
        type: dt.UNSIGNED_BYTE
    }, mt._globalBatch = 0, va = class {
        constructor() {
            this.texArray = null, this.blend = 0, this.type = Ye.TRIANGLES, this.start = 0, this.size = 0, this.data = null
        }
    };
    let QE = 0;
    Zt = class {
        constructor(t, e = !0, r = !1) {
            this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = QE++, this.disposeRunner = new ze("disposeBuffer")
        }
        update(t) {
            t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
        }
        dispose() {
            this.disposeRunner.emit(this, !1)
        }
        destroy() {
            this.dispose(), this.data = null
        }
        set index(t) {
            this.type = t ? dr.ELEMENT_ARRAY_BUFFER : dr.ARRAY_BUFFER
        }
        get index() {
            return this.type === dr.ELEMENT_ARRAY_BUFFER
        }
        static from(t) {
            return t instanceof Array && (t = new Float32Array(t)), new Zt(t)
        }
    }, ma = class {
        constructor(t, e = 0, r = !1, i = dt.FLOAT, n, a, l, h = 1) {
            this.buffer = t, this.size = e, this.normalized = r, this.type = i, this.stride = n, this.start = a, this.instance = l, this.divisor = h
        }
        destroy() {
            this.buffer = null
        }
        static from(t, e, r, i, n) {
            return new ma(t, e, r, i, n)
        }
    };
    const KE = {
        Float32Array,
        Uint32Array,
        Int32Array,
        Uint8Array
    };

    function ZE(t, e) {
        let r = 0,
            i = 0;
        const n = {};
        for (let c = 0; c < t.length; c++) i += e[c], r += t[c].length;
        const a = new ArrayBuffer(r * 4);
        let l = null,
            h = 0;
        for (let c = 0; c < t.length; c++) {
            const d = e[c],
                f = t[c],
                g = to(f);
            n[g] || (n[g] = new KE[g](a)), l = n[g];
            for (let y = 0; y < f.length; y++) {
                const x = (y / d | 0) * i + h,
                    _ = y % d;
                l[x + _] = f[y]
            }
            h += d
        }
        return new Float32Array(a)
    }
    const Pm = {
        5126: 4,
        5123: 2,
        5121: 1
    };
    let JE = 0;
    const tT = {
        Float32Array,
        Uint32Array,
        Int32Array,
        Uint8Array,
        Uint16Array
    };
    fi = class {
        constructor(t = [], e = {}) {
            this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = JE++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new ze("disposeGeometry"), this.refCount = 0
        }
        addAttribute(t, e, r = 0, i = !1, n, a, l, h = !1) {
            if (!e) throw new Error("You must pass a buffer when creating an attribute");
            e instanceof Zt || (e instanceof Array && (e = new Float32Array(e)), e = new Zt(e));
            const c = t.split("|");
            if (c.length > 1) {
                for (let f = 0; f < c.length; f++) this.addAttribute(c[f], e, r, i, n);
                return this
            }
            let d = this.buffers.indexOf(e);
            return d === -1 && (this.buffers.push(e), d = this.buffers.length - 1), this.attributes[t] = new ma(d, r, i, n, a, l, h), this.instanced = this.instanced || h, this
        }
        getAttribute(t) {
            return this.attributes[t]
        }
        getBuffer(t) {
            return this.buffers[this.getAttribute(t).buffer]
        }
        addIndex(t) {
            return t instanceof Zt || (t instanceof Array && (t = new Uint16Array(t)), t = new Zt(t)), t.type = dr.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.includes(t) || this.buffers.push(t), this
        }
        getIndex() {
            return this.indexBuffer
        }
        interleave() {
            if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;
            const t = [],
                e = [],
                r = new Zt;
            let i;
            for (i in this.attributes) {
                const n = this.attributes[i],
                    a = this.buffers[n.buffer];
                t.push(a.data), e.push(n.size * Pm[n.type] / 4), n.buffer = 0
            }
            for (r.data = ZE(t, e), i = 0; i < this.buffers.length; i++) this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();
            return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this
        }
        getSize() {
            for (const t in this.attributes) {
                const e = this.attributes[t];
                return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
            }
            return 0
        }
        dispose() {
            this.disposeRunner.emit(this, !1)
        }
        destroy() {
            this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
        }
        clone() {
            const t = new fi;
            for (let e = 0; e < this.buffers.length; e++) t.buffers[e] = new Zt(this.buffers[e].data.slice(0));
            for (const e in this.attributes) {
                const r = this.attributes[e];
                t.attributes[e] = new ma(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance)
            }
            return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = dr.ELEMENT_ARRAY_BUFFER), t
        }
        static merge(t) {
            const e = new fi,
                r = [],
                i = [],
                n = [];
            let a;
            for (let l = 0; l < t.length; l++) {
                a = t[l];
                for (let h = 0; h < a.buffers.length; h++) i[h] = i[h] || 0, i[h] += a.buffers[h].data.length, n[h] = 0
            }
            for (let l = 0; l < a.buffers.length; l++) r[l] = new tT[to(a.buffers[l].data)](i[l]), e.buffers[l] = new Zt(r[l]);
            for (let l = 0; l < t.length; l++) {
                a = t[l];
                for (let h = 0; h < a.buffers.length; h++) r[h].set(a.buffers[h].data, n[h]), n[h] += a.buffers[h].data.length
            }
            if (e.attributes = a.attributes, a.indexBuffer) {
                e.indexBuffer = e.buffers[a.buffers.indexOf(a.indexBuffer)], e.indexBuffer.type = dr.ELEMENT_ARRAY_BUFFER;
                let l = 0,
                    h = 0,
                    c = 0,
                    d = 0;
                for (let f = 0; f < a.buffers.length; f++)
                    if (a.buffers[f] !== a.indexBuffer) {
                        d = f;
                        break
                    }
                for (const f in a.attributes) {
                    const g = a.attributes[f];
                    (g.buffer | 0) === d && (h += g.size * Pm[g.type] / 4)
                }
                for (let f = 0; f < t.length; f++) {
                    const g = t[f].indexBuffer.data;
                    for (let y = 0; y < g.length; y++) e.indexBuffer.data[y + c] += l;
                    l += t[f].buffers[d].data.length / h, c += g.length
                }
            }
            return e
        }
    }, Ml = class extends fi {
        constructor(t = !1) {
            super(), this._buffer = new Zt(null, t, !1), this._indexBuffer = new Zt(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, dt.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, dt.FLOAT).addAttribute("aColor", this._buffer, 4, !0, dt.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, dt.FLOAT).addIndex(this._indexBuffer)
        }
    }, cs = Math.PI * 2, xp = 180 / Math.PI, ep = Math.PI / 180, le = (t => (t[t.POLY = 0] = "POLY", t[t.RECT = 1] = "RECT", t[t.CIRC = 2] = "CIRC", t[t.ELIP = 3] = "ELIP", t[t.RREC = 4] = "RREC", t))(le || {}), gt = class {
        constructor(t = 0, e = 0) {
            this.x = 0, this.y = 0, this.x = t, this.y = e
        }
        clone() {
            return new gt(this.x, this.y)
        }
        copyFrom(t) {
            return this.set(t.x, t.y), this
        }
        copyTo(t) {
            return t.set(this.x, this.y), t
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        set(t = 0, e = t) {
            return this.x = t, this.y = e, this
        }
        toString() {
            return `[@pixi/math:Point x=${this.x} y=${this.y}]`
        }
    };
    const no = [new gt, new gt, new gt, new gt];
    bt = class ff {
        constructor(e = 0, r = 0, i = 0, n = 0) {
            this.x = Number(e), this.y = Number(r), this.width = Number(i), this.height = Number(n), this.type = le.RECT
        }
        get left() {
            return this.x
        }
        get right() {
            return this.x + this.width
        }
        get top() {
            return this.y
        }
        get bottom() {
            return this.y + this.height
        }
        static get EMPTY() {
            return new ff(0, 0, 0, 0)
        }
        clone() {
            return new ff(this.x, this.y, this.width, this.height)
        }
        copyFrom(e) {
            return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
        }
        copyTo(e) {
            return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e
        }
        contains(e, r) {
            return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && r >= this.y && r < this.y + this.height
        }
        intersects(e, r) {
            if (!r) {
                const M = this.x < e.x ? e.x : this.x;
                if ((this.right > e.right ? e.right : this.right) <= M) return !1;
                const $ = this.y < e.y ? e.y : this.y;
                return (this.bottom > e.bottom ? e.bottom : this.bottom) > $
            }
            const i = this.left,
                n = this.right,
                a = this.top,
                l = this.bottom;
            if (n <= i || l <= a) return !1;
            const h = no[0].set(e.left, e.top),
                c = no[1].set(e.left, e.bottom),
                d = no[2].set(e.right, e.top),
                f = no[3].set(e.right, e.bottom);
            if (d.x <= h.x || c.y <= h.y) return !1;
            const g = Math.sign(r.a * r.d - r.b * r.c);
            if (g === 0 || (r.apply(h, h), r.apply(c, c), r.apply(d, d), r.apply(f, f), Math.max(h.x, c.x, d.x, f.x) <= i || Math.min(h.x, c.x, d.x, f.x) >= n || Math.max(h.y, c.y, d.y, f.y) <= a || Math.min(h.y, c.y, d.y, f.y) >= l)) return !1;
            const y = g * (c.y - h.y),
                x = g * (h.x - c.x),
                _ = y * i + x * a,
                E = y * n + x * a,
                w = y * i + x * l,
                I = y * n + x * l;
            if (Math.max(_, E, w, I) <= y * h.x + x * h.y || Math.min(_, E, w, I) >= y * f.x + x * f.y) return !1;
            const S = g * (h.y - d.y),
                T = g * (d.x - h.x),
                P = S * i + T * a,
                z = S * n + T * a,
                X = S * i + T * l,
                O = S * n + T * l;
            return !(Math.max(P, z, X, O) <= S * h.x + T * h.y || Math.min(P, z, X, O) >= S * f.x + T * f.y)
        }
        pad(e = 0, r = e) {
            return this.x -= e, this.y -= r, this.width += e * 2, this.height += r * 2, this
        }
        fit(e) {
            const r = Math.max(this.x, e.x),
                i = Math.min(this.x + this.width, e.x + e.width),
                n = Math.max(this.y, e.y),
                a = Math.min(this.y + this.height, e.y + e.height);
            return this.x = r, this.width = Math.max(i - r, 0), this.y = n, this.height = Math.max(a - n, 0), this
        }
        ceil(e = 1, r = .001) {
            const i = Math.ceil((this.x + this.width - r) * e) / e,
                n = Math.ceil((this.y + this.height - r) * e) / e;
            return this.x = Math.floor((this.x + r) * e) / e, this.y = Math.floor((this.y + r) * e) / e, this.width = i - this.x, this.height = n - this.y, this
        }
        enlarge(e) {
            const r = Math.min(this.x, e.x),
                i = Math.max(this.x + this.width, e.x + e.width),
                n = Math.min(this.y, e.y),
                a = Math.max(this.y + this.height, e.y + e.height);
            return this.x = r, this.width = i - r, this.y = n, this.height = a - n, this
        }
        toString() {
            return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
        }
    }, Ch = class {
        constructor(t = 0, e = 0, r = 0) {
            this.x = t, this.y = e, this.radius = r, this.type = le.CIRC
        }
        clone() {
            return new Ch(this.x, this.y, this.radius)
        }
        contains(t, e) {
            if (this.radius <= 0) return !1;
            const r = this.radius * this.radius;
            let i = this.x - t,
                n = this.y - e;
            return i *= i, n *= n, i + n <= r
        }
        getBounds() {
            return new bt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2)
        }
        toString() {
            return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
        }
    }, Ol = class {
        constructor(t = 0, e = 0, r = 0, i = 0) {
            this.x = t, this.y = e, this.width = r, this.height = i, this.type = le.ELIP
        }
        clone() {
            return new Ol(this.x, this.y, this.width, this.height)
        }
        contains(t, e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            let r = (t - this.x) / this.width,
                i = (e - this.y) / this.height;
            return r *= r, i *= i, r + i <= 1
        }
        getBounds() {
            return new bt(this.x - this.width, this.y - this.height, this.width, this.height)
        }
        toString() {
            return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
        }
    }, _n = class {
        constructor(...t) {
            let e = Array.isArray(t[0]) ? t[0] : t;
            if (typeof e[0] != "number") {
                const r = [];
                for (let i = 0, n = e.length; i < n; i++) r.push(e[i].x, e[i].y);
                e = r
            }
            this.points = e, this.type = le.POLY, this.closeStroke = !0
        }
        clone() {
            const t = this.points.slice(),
                e = new _n(t);
            return e.closeStroke = this.closeStroke, e
        }
        contains(t, e) {
            let r = !1;
            const i = this.points.length / 2;
            for (let n = 0, a = i - 1; n < i; a = n++) {
                const l = this.points[n * 2],
                    h = this.points[n * 2 + 1],
                    c = this.points[a * 2],
                    d = this.points[a * 2 + 1];
                h > e != d > e && t < (c - l) * ((e - h) / (d - h)) + l && (r = !r)
            }
            return r
        }
        toString() {
            return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t,e)=>`${t}, ${e}`,"")}]`
        }
    }, fh = class {
        constructor(t = 0, e = 0, r = 0, i = 0, n = 20) {
            this.x = t, this.y = e, this.width = r, this.height = i, this.radius = n, this.type = le.RREC
        }
        clone() {
            return new fh(this.x, this.y, this.width, this.height, this.radius)
        }
        contains(t, e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r) return !0;
                let i = t - (this.x + r),
                    n = e - (this.y + r);
                const a = r * r;
                if (i * i + n * n <= a || (i = t - (this.x + this.width - r), i * i + n * n <= a) || (n = e - (this.y + this.height - r), i * i + n * n <= a) || (i = t - (this.x + r), i * i + n * n <= a)) return !0
            }
            return !1
        }
        toString() {
            return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
        }
    }, Ut = class {
        constructor(t = 1, e = 0, r = 0, i = 1, n = 0, a = 0) {
            this.array = null, this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = a
        }
        fromArray(t) {
            this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
        }
        set(t, e, r, i, n, a) {
            return this.a = t, this.b = e, this.c = r, this.d = i, this.tx = n, this.ty = a, this
        }
        toArray(t, e) {
            this.array || (this.array = new Float32Array(9));
            const r = e || this.array;
            return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r
        }
        apply(t, e) {
            e = e || new gt;
            const r = t.x,
                i = t.y;
            return e.x = this.a * r + this.c * i + this.tx, e.y = this.b * r + this.d * i + this.ty, e
        }
        applyInverse(t, e) {
            e = e || new gt;
            const r = 1 / (this.a * this.d + this.c * -this.b),
                i = t.x,
                n = t.y;
            return e.x = this.d * r * i + -this.c * r * n + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * n + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, e
        }
        translate(t, e) {
            return this.tx += t, this.ty += e, this
        }
        scale(t, e) {
            return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
        }
        rotate(t) {
            const e = Math.cos(t),
                r = Math.sin(t),
                i = this.a,
                n = this.c,
                a = this.tx;
            return this.a = i * e - this.b * r, this.b = i * r + this.b * e, this.c = n * e - this.d * r, this.d = n * r + this.d * e, this.tx = a * e - this.ty * r, this.ty = a * r + this.ty * e, this
        }
        append(t) {
            const e = this.a,
                r = this.b,
                i = this.c,
                n = this.d;
            return this.a = t.a * e + t.b * i, this.b = t.a * r + t.b * n, this.c = t.c * e + t.d * i, this.d = t.c * r + t.d * n, this.tx = t.tx * e + t.ty * i + this.tx, this.ty = t.tx * r + t.ty * n + this.ty, this
        }
        setTransform(t, e, r, i, n, a, l, h, c) {
            return this.a = Math.cos(l + c) * n, this.b = Math.sin(l + c) * n, this.c = -Math.sin(l - h) * a, this.d = Math.cos(l - h) * a, this.tx = t - (r * this.a + i * this.c), this.ty = e - (r * this.b + i * this.d), this
        }
        prepend(t) {
            const e = this.tx;
            if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
                const r = this.a,
                    i = this.c;
                this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = i * t.a + this.d * t.c, this.d = i * t.b + this.d * t.d
            }
            return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
        }
        decompose(t) {
            const e = this.a,
                r = this.b,
                i = this.c,
                n = this.d,
                a = t.pivot,
                l = -Math.atan2(-i, n),
                h = Math.atan2(r, e),
                c = Math.abs(l + h);
            return c < 1e-5 || Math.abs(cs - c) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = l, t.skew.y = h), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(i * i + n * n), t.position.x = this.tx + (a.x * e + a.y * i), t.position.y = this.ty + (a.x * r + a.y * n), t
        }
        invert() {
            const t = this.a,
                e = this.b,
                r = this.c,
                i = this.d,
                n = this.tx,
                a = t * i - e * r;
            return this.a = i / a, this.b = -e / a, this.c = -r / a, this.d = t / a, this.tx = (r * this.ty - i * n) / a, this.ty = -(t * this.ty - e * n) / a, this
        }
        identity() {
            return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
        }
        clone() {
            const t = new Ut;
            return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
        }
        copyTo(t) {
            return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
        }
        copyFrom(t) {
            return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
        }
        toString() {
            return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
        }
        static get IDENTITY() {
            return new Ut
        }
        static get TEMP_MATRIX() {
            return new Ut
        }
    };
    const Qi = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
        Ki = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
        Zi = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
        Ji = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
        Su = [],
        Cm = [],
        so = Math.sign;

    function eT() {
        for (let t = 0; t < 16; t++) {
            const e = [];
            Su.push(e);
            for (let r = 0; r < 16; r++) {
                const i = so(Qi[t] * Qi[r] + Zi[t] * Ki[r]),
                    n = so(Ki[t] * Qi[r] + Ji[t] * Ki[r]),
                    a = so(Qi[t] * Zi[r] + Zi[t] * Ji[r]),
                    l = so(Ki[t] * Zi[r] + Ji[t] * Ji[r]);
                for (let h = 0; h < 16; h++)
                    if (Qi[h] === i && Ki[h] === n && Zi[h] === a && Ji[h] === l) {
                        e.push(h);
                        break
                    }
            }
        }
        for (let t = 0; t < 16; t++) {
            const e = new Ut;
            e.set(Qi[t], Ki[t], Zi[t], Ji[t], 0, 0), Cm.push(e)
        }
    }
    eT(), Gt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: t => Qi[t],
        uY: t => Ki[t],
        vX: t => Zi[t],
        vY: t => Ji[t],
        inv: t => t & 8 ? t & 15 : -t & 7,
        add: (t, e) => Su[t][e],
        sub: (t, e) => Su[t][Gt.inv(e)],
        rotate180: t => t ^ 4,
        isVertical: t => (t & 3) === 2,
        byDirection: (t, e) => Math.abs(t) * 2 <= Math.abs(e) ? e >= 0 ? Gt.S : Gt.N : Math.abs(e) * 2 <= Math.abs(t) ? t > 0 ? Gt.E : Gt.W : e > 0 ? t > 0 ? Gt.SE : Gt.SW : t > 0 ? Gt.NE : Gt.NW,
        matrixAppendRotationInv: (t, e, r = 0, i = 0) => {
            const n = Cm[Gt.inv(e)];
            n.tx = r, n.ty = i, t.append(n)
        }
    }, Jr = class {
        constructor(t, e, r = 0, i = 0) {
            this._x = r, this._y = i, this.cb = t, this.scope = e
        }
        clone(t = this.cb, e = this.scope) {
            return new Jr(t, e, this._x, this._y)
        }
        set(t = 0, e = t) {
            return (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this
        }
        copyFrom(t) {
            return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
        }
        copyTo(t) {
            return t.set(this._x, this._y), t
        }
        equals(t) {
            return t.x === this._x && t.y === this._y
        }
        toString() {
            return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x !== t && (this._x = t, this.cb.call(this.scope))
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y !== t && (this._y = t, this.cb.call(this.scope))
        }
    };
    const Im = class {
        constructor() {
            this.worldTransform = new Ut, this.localTransform = new Ut, this.position = new Jr(this.onChange, this, 0, 0), this.scale = new Jr(this.onChange, this, 1, 1), this.pivot = new Jr(this.onChange, this, 0, 0), this.skew = new Jr(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
        }
        onChange() {
            this._localID++
        }
        updateSkew() {
            this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
        }
        toString() {
            return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
        }
        updateLocalTransform() {
            const t = this.localTransform;
            this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
        }
        updateTransform(t) {
            const e = this.localTransform;
            if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
                const r = t.worldTransform,
                    i = this.worldTransform;
                i.a = e.a * r.a + e.b * r.c, i.b = e.a * r.b + e.b * r.d, i.c = e.c * r.a + e.d * r.c, i.d = e.c * r.b + e.d * r.d, i.tx = e.tx * r.a + e.ty * r.c + r.tx, i.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++
            }
        }
        setFromMatrix(t) {
            t.decompose(this), this._localID++
        }
        get rotation() {
            return this._rotation
        }
        set rotation(t) {
            this._rotation !== t && (this._rotation = t, this.updateSkew())
        }
    };
    gs = Im, gs.IDENTITY = new Im;
    var rT = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
        iT = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;

    function Rm(t, e, r) {
        const i = t.createShader(e);
        return t.shaderSource(i, r), t.compileShader(i), i
    }

    function Au(t) {
        const e = new Array(t);
        for (let r = 0; r < e.length; r++) e[r] = !1;
        return e
    }

    function Mm(t, e) {
        switch (t) {
            case "float":
                return 0;
            case "vec2":
                return new Float32Array(2 * e);
            case "vec3":
                return new Float32Array(3 * e);
            case "vec4":
                return new Float32Array(4 * e);
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
                return 0;
            case "ivec2":
                return new Int32Array(2 * e);
            case "ivec3":
                return new Int32Array(3 * e);
            case "ivec4":
                return new Int32Array(4 * e);
            case "uvec2":
                return new Uint32Array(2 * e);
            case "uvec3":
                return new Uint32Array(3 * e);
            case "uvec4":
                return new Uint32Array(4 * e);
            case "bool":
                return !1;
            case "bvec2":
                return Au(2 * e);
            case "bvec3":
                return Au(3 * e);
            case "bvec4":
                return Au(4 * e);
            case "mat2":
                return new Float32Array([1, 0, 0, 1]);
            case "mat3":
                return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            case "mat4":
                return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        }
        return null
    }
    let Dm, Nm;
    Hi = [{
        test: t => t.type === "float" && t.size === 1 && !t.isArray,
        code: t => `
            if(uv["${t}"] !== ud["${t}"].value)
            {
                ud["${t}"].value = uv["${t}"]
                gl.uniform1f(ud["${t}"].location, uv["${t}"])
            }
            `
    }, {
        test: (t, e) => (t.type === "sampler2D" || t.type === "samplerCube" || t.type === "sampler2DArray") && t.size === 1 && !t.isArray && (e == null || e.castToBaseTexture !== void 0),
        code: t => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${t}"], t);

            if(ud["${t}"].value !== t)
            {
                ud["${t}"].value = t;
                gl.uniform1i(ud["${t}"].location, t);
; // eslint-disable-line max-len
            }`
    }, {
        test: (t, e) => t.type === "mat3" && t.size === 1 && !t.isArray && e.a !== void 0,
        code: t => `
            gl.uniformMatrix3fv(ud["${t}"].location, false, uv["${t}"].toArray(true));
            `,
        codeUbo: t => `
                var ${t}_matrix = uv.${t}.toArray(true);

                data[offset] = ${t}_matrix[0];
                data[offset+1] = ${t}_matrix[1];
                data[offset+2] = ${t}_matrix[2];
        
                data[offset + 4] = ${t}_matrix[3];
                data[offset + 5] = ${t}_matrix[4];
                data[offset + 6] = ${t}_matrix[5];
        
                data[offset + 8] = ${t}_matrix[6];
                data[offset + 9] = ${t}_matrix[7];
                data[offset + 10] = ${t}_matrix[8];
            `
    }, {
        test: (t, e) => t.type === "vec2" && t.size === 1 && !t.isArray && e.x !== void 0,
        code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${t}"].location, v.x, v.y);
                }`,
        codeUbo: t => `
                v = uv.${t};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
    }, {
        test: t => t.type === "vec2" && t.size === 1 && !t.isArray,
        code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${t}"].location, v[0], v[1]);
                }
            `
    }, {
        test: (t, e) => t.type === "vec4" && t.size === 1 && !t.isArray && e.width !== void 0,
        code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${t}"].location, v.x, v.y, v.width, v.height)
                }`,
        codeUbo: t => `
                    v = uv.${t};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
    }, {
        test: t => t.type === "vec4" && t.size === 1 && !t.isArray,
        code: t => `
                cv = ud["${t}"].value;
                v = uv["${t}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${t}"].location, v[0], v[1], v[2], v[3])
                }`
    }], Dm = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    }, Nm = {
        float: "gl.uniform1fv(location, v)",
        vec2: "gl.uniform2fv(location, v)",
        vec3: "gl.uniform3fv(location, v)",
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
    };

    function nT(t, e) {
        var r;
        const i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
        for (const n in t.uniforms) {
            const a = e[n];
            if (!a) {
                (r = t.uniforms[n]) != null && r.group && (t.uniforms[n].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${n}, '${n}');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.${n}, syncData);
                    `));
                continue
            }
            const l = t.uniforms[n];
            let h = !1;
            for (let c = 0; c < Hi.length; c++)
                if (Hi[c].test(a, l)) {
                    i.push(Hi[c].code(n, l)), h = !0;
                    break
                }
            if (!h) {
                const c = (a.size === 1 && !a.isArray ? Dm : Nm)[a.type].replace("location", `ud["${n}"].location`);
                i.push(`
            cu = ud["${n}"];
            cv = cu.value;
            v = uv["${n}"];
            ${c};`)
            }
        }
        return new Function("ud", "uv", "renderer", "syncData", i.join(`
`))
    }
    const Om = {};
    let Ns = Om;
    sf = function() {
        if (Ns === Om || Ns != null && Ns.isContextLost()) {
            const t = et.ADAPTER.createCanvas();
            let e;
            et.PREFER_ENV >= pi.WEBGL2 && (e = t.getContext("webgl2", {})), e || (e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {}), e ? e.getExtension("WEBGL_draw_buffers") : e = null), Ns = e
        }
        return Ns
    };
    let ao;

    function sT() {
        if (!ao) {
            ao = Ge.MEDIUM;
            const t = sf();
            t && t.getShaderPrecisionFormat && (ao = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision ? Ge.HIGH : Ge.MEDIUM)
        }
        return ao
    }

    function Lm(t, e) {
        const r = t.getShaderSource(e).split(`
`).map((d, f) => `${f}: ${d}`),
            i = t.getShaderInfoLog(e),
            n = i.split(`
`),
            a = {},
            l = n.map(d => parseFloat(d.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(d => d && !a[d] ? (a[d] = !0, !0) : !1),
            h = [""];
        l.forEach(d => {
            r[d - 1] = `%c${r[d-1]}%c`, h.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
        });
        const c = r.join(`
`);
        h[0] = c
    }

    function aT(t, e, r, i) {
        t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(r, t.COMPILE_STATUS) || Lm(t, r), t.getShaderParameter(i, t.COMPILE_STATUS) || Lm(t, i), t.getProgramInfoLog(e))
    }
    const oT = {
        float: 1,
        vec2: 2,
        vec3: 3,
        vec4: 4,
        int: 1,
        ivec2: 2,
        ivec3: 3,
        ivec4: 4,
        uint: 1,
        uvec2: 2,
        uvec3: 3,
        uvec4: 4,
        bool: 1,
        bvec2: 2,
        bvec3: 3,
        bvec4: 4,
        mat2: 4,
        mat3: 9,
        mat4: 16,
        sampler2D: 1
    };

    function Bm(t) {
        return oT[t]
    }
    let oo = null;
    const km = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };

    function Fm(t, e) {
        if (!oo) {
            const r = Object.keys(km);
            oo = {};
            for (let i = 0; i < r.length; ++i) {
                const n = r[i];
                oo[t[n]] = km[n]
            }
        }
        return oo[e]
    }

    function Um(t, e, r) {
        if (t.substring(0, 9) !== "precision") {
            let i = e;
            return e === Ge.HIGH && r !== Ge.HIGH && (i = Ge.MEDIUM), `precision ${i} float;
${t}`
        } else if (r !== Ge.HIGH && t.substring(0, 15) === "precision highp") return t.replace("precision highp", "precision mediump");
        return t
    }
    let Os;
    jp = function() {
        if (typeof Os == "boolean") return Os;
        try {
            Os = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
                a: "b"
            }, "a", "b") === !0
        } catch (t) {
            Os = !1
        }
        return Os
    };
    let lT = 0;
    const lo = {},
        kn = class {
            constructor(t, e, r = "pixi-shader", i = {}) {
                this.extra = {}, this.id = lT++, this.vertexSrc = t || kn.defaultVertexSrc, this.fragmentSrc = e || kn.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = i, this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), lo[r] ? (lo[r]++, r += `-${lo[r]}`) : lo[r] = 1, this.vertexSrc = `#define SHADER_NAME ${r}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${r}
${this.fragmentSrc}`, this.vertexSrc = Um(this.vertexSrc, kn.defaultVertexPrecision, Ge.HIGH), this.fragmentSrc = Um(this.fragmentSrc, kn.defaultFragmentPrecision, sT())), this.glPrograms = {}, this.syncUniforms = null
            }
            static get defaultVertexSrc() {
                return iT
            }
            static get defaultFragmentSrc() {
                return rT
            }
            static from(t, e, r) {
                const i = t + e;
                let n = gu[i];
                return n || (gu[i] = n = new kn(t, e, r)), n
            }
        };
    Ke = kn, Ke.defaultVertexPrecision = Ge.HIGH, Ke.defaultFragmentPrecision = gr.apple.device ? Ge.HIGH : Ge.MEDIUM;
    let hT = 0;
    mr = class {
        constructor(t, e, r) {
            this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = hT++, this.static = !!e, this.ubo = !!r, t instanceof Zt ? (this.buffer = t, this.buffer.type = dr.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Zt(new Float32Array(1)), this.buffer.type = dr.UNIFORM_BUFFER, this.autoManage = !0))
        }
        update() {
            this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
        }
        add(t, e, r) {
            if (!this.ubo) this.uniforms[t] = new mr(e, r);
            else throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
        }
        static from(t, e, r) {
            return new mr(t, e, r)
        }
        static uboFrom(t, e) {
            return new mr(t, e != null ? e : !0, !0)
        }
    }, Mr = class {
        constructor(t, e) {
            this.uniformBindCount = 0, this.program = t, e ? e instanceof mr ? this.uniformGroup = e : this.uniformGroup = new mr(e) : this.uniformGroup = new mr({}), this.disposeRunner = new ze("disposeShader")
        }
        checkUniformExists(t, e) {
            if (e.uniforms[t]) return !0;
            for (const r in e.uniforms) {
                const i = e.uniforms[r];
                if (i.group && this.checkUniformExists(t, i)) return !0
            }
            return !1
        }
        destroy() {
            this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy()
        }
        get uniforms() {
            return this.uniformGroup.uniforms
        }
        static from(t, e, r) {
            const i = Ke.from(t, e);
            return new Mr(i, r)
        }
    }, lf = class {
        constructor(t, e) {
            if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, !e.includes("%count%")) throw new Error('Fragment template must contain "%count%".');
            if (!e.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".')
        }
        generateShader(t) {
            if (!this.programCache[t]) {
                const r = new Int32Array(t);
                for (let n = 0; n < t; n++) r[n] = n;
                this.defaultGroupCache[t] = mr.from({
                    uSamplers: r
                }, !0);
                let i = this.fragTemplate;
                i = i.replace(/%count%/gi, `${t}`), i = i.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Ke(this.vertexSrc, i)
            }
            const e = {
                tint: new Float32Array([1, 1, 1, 1]),
                translationMatrix: new Ut,
                default: this.defaultGroupCache[t]
            };
            return new Mr(this.programCache[t], e)
        }
        generateSampleSrc(t) {
            let e = "";
            e += `
`, e += `
`;
            for (let r = 0; r < t; r++) r > 0 && (e += `
else `), r < t - 1 && (e += `if(vTextureId < ${r}.5)`), e += `
{`, e += `
	color = texture2D(uSamplers[${r}], vTextureCoord);`, e += `
}`;
            return e += `
`, e += `
`, e
        }
    }, ga = class {
        constructor() {
            this.elements = [], this.ids = [], this.count = 0
        }
        clear() {
            for (let t = 0; t < this.count; t++) this.elements[t] = null;
            this.count = 0
        }
    };

    function uT() {
        return !gr.apple.device
    }

    function cT(t) {
        let e = !0;
        const r = et.ADAPTER.getNavigator();
        if (gr.tablet || gr.phone) {
            if (gr.apple.device) {
                const i = r.userAgent.match(/OS (\d+)_(\d+)?/);
                i && parseInt(i[1], 10) < 11 && (e = !1)
            }
            if (gr.android.device) {
                const i = r.userAgent.match(/Android\s([0-9.]*)/);
                i && parseInt(i[1], 10) < 7 && (e = !1)
            }
        }
        return e ? t : 4
    }
    us = class {
        constructor(t) {
            this.renderer = t
        }
        flush() {}
        destroy() {
            this.renderer = null
        }
        start() {}
        stop() {
            this.flush()
        }
        render(t) {}
    };
    var dT = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
        pT = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
    const _r = class extends us {
        constructor(t) {
            super(t), this.setShaderGenerator(), this.geometryClass = Ml, this.vertexSize = 6, this.state = ei.for2d(), this.size = _r.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), t.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
        }
        static get defaultMaxTextures() {
            var t;
            return this._defaultMaxTextures = (t = this._defaultMaxTextures) != null ? t : cT(32), this._defaultMaxTextures
        }
        static set defaultMaxTextures(t) {
            this._defaultMaxTextures = t
        }
        static get canUploadSameBuffer() {
            var t;
            return this._canUploadSameBuffer = (t = this._canUploadSameBuffer) != null ? t : uT(), this._canUploadSameBuffer
        }
        static set canUploadSameBuffer(t) {
            this._canUploadSameBuffer = t
        }
        get MAX_TEXTURES() {
            return Tt("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures
        }
        static get defaultVertexSrc() {
            return pT
        }
        static get defaultFragmentTemplate() {
            return dT
        }
        setShaderGenerator({
            vertex: t = _r.defaultVertexSrc,
            fragment: e = _r.defaultFragmentTemplate
        } = {}) {
            this.shaderGenerator = new lf(t, e)
        }
        contextChange() {
            const t = this.renderer.gl;
            et.PREFER_ENV === pi.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), _r.defaultMaxTextures), this.maxTextures = Vp(this.maxTextures, t)), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
            for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass;
            this.initFlushBuffers()
        }
        initFlushBuffers() {
            const {
                _drawCallPool: t,
                _textureArrayPool: e
            } = _r, r = this.size / 4, i = Math.floor(r / this.maxTextures) + 1;
            for (; t.length < r;) t.push(new va);
            for (; e.length < i;) e.push(new ga);
            for (let n = 0; n < this.maxTextures; n++) this._tempBoundTextures[n] = null
        }
        onPrerender() {
            this._flushId = 0
        }
        render(t) {
            t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
        }
        buildTexturesAndDrawCalls() {
            const {
                _bufferedTextures: t,
                maxTextures: e
            } = this, r = _r._textureArrayPool, i = this.renderer.batch, n = this._tempBoundTextures, a = this.renderer.textureGC.count;
            let l = ++mt._globalBatch,
                h = 0,
                c = r[0],
                d = 0;
            i.copyBoundTextures(n, e);
            for (let f = 0; f < this._bufferSize; ++f) {
                const g = t[f];
                t[f] = null, g._batchEnabled !== l && (c.count >= e && (i.boundArray(c, n, l, e), this.buildDrawCalls(c, d, f), d = f, c = r[++h], ++l), g._batchEnabled = l, g.touched = a, c.elements[c.count++] = g)
            }
            c.count > 0 && (i.boundArray(c, n, l, e), this.buildDrawCalls(c, d, this._bufferSize), ++h, ++l);
            for (let f = 0; f < n.length; f++) n[f] = null;
            mt._globalBatch = l
        }
        buildDrawCalls(t, e, r) {
            const {
                _bufferedElements: i,
                _attributeBuffer: n,
                _indexBuffer: a,
                vertexSize: l
            } = this, h = _r._drawCallPool;
            let c = this._dcIndex,
                d = this._aIndex,
                f = this._iIndex,
                g = h[c];
            g.start = this._iIndex, g.texArray = t;
            for (let y = e; y < r; ++y) {
                const x = i[y],
                    _ = x._texture.baseTexture,
                    E = cu[_.alphaMode ? 1 : 0][x.blendMode];
                i[y] = null, e < y && g.blend !== E && (g.size = f - g.start, e = y, g = h[++c], g.texArray = t, g.start = f), this.packInterleavedGeometry(x, n, a, d, f), d += x.vertexData.length / 2 * l, f += x.indices.length, g.blend = E
            }
            e < r && (g.size = f - g.start, ++c), this._dcIndex = c, this._aIndex = d, this._iIndex = f
        }
        bindAndClearTexArray(t) {
            const e = this.renderer.texture;
            for (let r = 0; r < t.count; r++) e.bind(t.elements[r], t.ids[r]), t.elements[r] = null;
            t.count = 0
        }
        updateGeometry() {
            const {
                _packedGeometries: t,
                _attributeBuffer: e,
                _indexBuffer: r
            } = this;
            _r.canUploadSameBuffer ? (t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t[this._flushId] = new this.geometryClass), t[this._flushId]._buffer.update(e.rawBinaryData), t[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(t[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
        }
        drawBatches() {
            const t = this._dcIndex,
                {
                    gl: e,
                    state: r
                } = this.renderer,
                i = _r._drawCallPool;
            let n = null;
            for (let a = 0; a < t; a++) {
                const {
                    texArray: l,
                    type: h,
                    size: c,
                    start: d,
                    blend: f
                } = i[a];
                n !== l && (n = l, this.bindAndClearTexArray(l)), this.state.blendMode = f, r.set(this.state), e.drawElements(h, c, e.UNSIGNED_SHORT, d * 2)
            }
        }
        flush() {
            this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
        }
        start() {
            this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), _r.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
        }
        stop() {
            this.flush()
        }
        destroy() {
            for (let t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] && this._packedGeometries[t].destroy();
            this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy()
        }
        getAttributeBuffer(t) {
            const e = Ds(Math.ceil(t / 8)),
                r = mu(e),
                i = e * 8;
            this._aBuffers.length <= r && (this._iBuffers.length = r + 1);
            let n = this._aBuffers[i];
            return n || (this._aBuffers[i] = n = new Ia(i * this.vertexSize * 4)), n
        }
        getIndexBuffer(t) {
            const e = Ds(Math.ceil(t / 12)),
                r = mu(e),
                i = e * 12;
            this._iBuffers.length <= r && (this._iBuffers.length = r + 1);
            let n = this._iBuffers[r];
            return n || (this._iBuffers[r] = n = new Uint16Array(i)), n
        }
        packInterleavedGeometry(t, e, r, i, n) {
            const {
                uint32View: a,
                float32View: l
            } = e, h = i / this.vertexSize, c = t.uvs, d = t.indices, f = t.vertexData, g = t._texture.baseTexture._batchLocation, y = Math.min(t.worldAlpha, 1), x = y < 1 && t._texture.baseTexture.alphaMode ? Ja(t._tintRGB, y) : t._tintRGB + (y * 255 << 24);
            for (let _ = 0; _ < f.length; _ += 2) l[i++] = f[_], l[i++] = f[_ + 1], l[i++] = c[_], l[i++] = c[_ + 1], a[i++] = x, l[i++] = g;
            for (let _ = 0; _ < d.length; _++) r[n++] = h + d[_]
        }
    };
    Je = _r, Je.defaultBatchSize = 4096, Je.extension = {
        name: "batch",
        type: Z.RendererPlugin
    }, Je._drawCallPool = [], Je._textureArrayPool = [], lt.add(Je);
    var fT = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
        mT = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
    const Ls = class extends Mr {
        constructor(t, e, r) {
            const i = Ke.from(t || Ls.defaultVertexSrc, e || Ls.defaultFragmentSrc);
            super(i, r), this.padding = 0, this.resolution = Ls.defaultResolution, this.multisample = Ls.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new ei
        }
        apply(t, e, r, i, n) {
            t.applyFilter(this, e, r, i)
        }
        get blendMode() {
            return this.state.blendMode
        }
        set blendMode(t) {
            this.state.blendMode = t
        }
        get resolution() {
            return this._resolution
        }
        set resolution(t) {
            this._resolution = t
        }
        static get defaultVertexSrc() {
            return mT
        }
        static get defaultFragmentSrc() {
            return fT
        }
    };
    ae = Ls, ae.defaultResolution = 1, ae.defaultMultisample = Wt.NONE, Ll = class {
        constructor() {
            this.clearBeforeRender = !0, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 1], this._backgroundColorString = "#000000", this.color = this._backgroundColor, this.alpha = 1
        }
        init(t) {
            this.clearBeforeRender = t.clearBeforeRender, t.color && (this.color = typeof t.color == "string" ? Za(t.color) : t.color), this.alpha = t.alpha
        }
        get color() {
            return this._backgroundColor
        }
        set color(t) {
            this._backgroundColor = t, this._backgroundColorString = uu(t), xi(t, this._backgroundColorRgba)
        }
        get alpha() {
            return this._backgroundColorRgba[3]
        }
        set alpha(t) {
            this._backgroundColorRgba[3] = t
        }
        get colorRgba() {
            return this._backgroundColorRgba
        }
        get colorString() {
            return this._backgroundColorString
        }
        destroy() {}
    }, Ll.extension = {
        type: [Z.RendererSystem, Z.CanvasRendererSystem],
        name: "background"
    }, lt.add(Ll), Ah = class {
        constructor(t) {
            this.renderer = t, this.emptyRenderer = new us(t), this.currentRenderer = this.emptyRenderer
        }
        setObjectRenderer(t) {
            this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
        }
        flush() {
            this.setObjectRenderer(this.emptyRenderer)
        }
        reset() {
            this.setObjectRenderer(this.emptyRenderer)
        }
        copyBoundTextures(t, e) {
            const {
                boundTextures: r
            } = this.renderer.texture;
            for (let i = e - 1; i >= 0; --i) t[i] = r[i] || null, t[i] && (t[i]._batchLocation = i)
        }
        boundArray(t, e, r, i) {
            const {
                elements: n,
                ids: a,
                count: l
            } = t;
            let h = 0;
            for (let c = 0; c < l; c++) {
                const d = n[c],
                    f = d._batchLocation;
                if (f >= 0 && f < i && e[f] === d) {
                    a[c] = f;
                    continue
                }
                for (; h < i;) {
                    const g = e[h];
                    if (g && g._batchEnabled === r && g._batchLocation === h) {
                        h++;
                        continue
                    }
                    a[c] = h, d._batchLocation = h, e[h] = d;
                    break
                }
            }
        }
        destroy() {
            this.renderer = null
        }
    }, Ah.extension = {
        type: Z.RendererSystem,
        name: "batch"
    }, lt.add(Ah);
    let Gm = 0;
    Rl = class {
        constructor(t) {
            this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
                uint32Indices: !1
            }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
        }
        get isLost() {
            return !this.gl || this.gl.isContextLost()
        }
        contextChange(t) {
            this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = Gm++
        }
        init(t) {
            if (t.context) this.initFromContext(t.context);
            else {
                const e = this.renderer.background.alpha < 1,
                    r = t.premultipliedAlpha;
                this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.useContextAlpha = t.useContextAlpha, this.powerPreference = t.powerPreference, this.initFromOptions({
                    alpha: e,
                    premultipliedAlpha: r,
                    antialias: t.antialias,
                    stencil: !0,
                    preserveDrawingBuffer: t.preserveDrawingBuffer,
                    powerPreference: t.powerPreference
                })
            }
        }
        initFromContext(t) {
            this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = Gm++, this.renderer.runners.contextChange.emit(t);
            const e = this.renderer.view;
            e.addEventListener !== void 0 && (e.addEventListener("webglcontextlost", this.handleContextLost, !1), e.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
        }
        initFromOptions(t) {
            const e = this.createContext(this.renderer.view, t);
            this.initFromContext(e)
        }
        createContext(t, e) {
            let r;
            if (et.PREFER_ENV >= pi.WEBGL2 && (r = t.getContext("webgl2", e)), r) this.webGLVersion = 2;
            else if (this.webGLVersion = 1, r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), !r) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            return this.gl = r, this.getExtensions(), this.gl
        }
        getExtensions() {
            const {
                gl: t
            } = this, e = {
                loseContext: t.getExtension("WEBGL_lose_context"),
                anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: t.getExtension("WEBGL_compressed_texture_etc"),
                etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: t.getExtension("WEBGL_compressed_texture_atc"),
                astc: t.getExtension("WEBGL_compressed_texture_astc")
            };
            this.webGLVersion === 1 ? Object.assign(this.extensions, e, {
                drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                depthTexture: t.getExtension("WEBGL_depth_texture"),
                vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                floatTexture: t.getExtension("OES_texture_float"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                textureHalfFloat: t.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
            }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {
                colorBufferFloat: t.getExtension("EXT_color_buffer_float")
            })
        }
        handleContextLost(t) {
            t.preventDefault(), setTimeout(() => {
                this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
            }, 0)
        }
        handleContextRestored() {
            this.renderer.runners.contextChange.emit(this.gl)
        }
        destroy() {
            const t = this.renderer.view;
            this.renderer = null, t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
        }
        postrender() {
            this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
        }
        validateContext(t) {
            const e = t.getContextAttributes(),
                r = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
            r && (this.webGLVersion = 2), e && e.stencil;
            const i = r || !!t.getExtension("OES_element_index_uint");
            this.supports.uint32Indices = i
        }
    }, Rl.extension = {
        type: Z.RendererSystem,
        name: "context"
    }, lt.add(Rl);
    class gT extends yn {
        upload(e, r, i) {
            const n = e.gl;
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === tr.UNPACK);
            const a = r.realWidth,
                l = r.realHeight;
            return i.width === a && i.height === l ? n.texSubImage2D(r.target, 0, 0, 0, a, l, r.format, i.type, this.data) : (i.width = a, i.height = l, n.texImage2D(r.target, 0, i.internalFormat, a, l, 0, r.format, i.type, this.data)), !0
        }
    }
    _a = class {
        constructor(t, e) {
            this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new ze("disposeFramebuffer"), this.multisample = Wt.NONE
        }
        get colorTexture() {
            return this.colorTextures[0]
        }
        addColorTexture(t = 0, e) {
            return this.colorTextures[t] = e || new mt(null, {
                scaleMode: Rr.NEAREST,
                resolution: 1,
                mipmap: fr.OFF,
                width: this.width,
                height: this.height
            }), this.dirtyId++, this.dirtyFormat++, this
        }
        addDepthTexture(t) {
            return this.depthTexture = t || new mt(new gT(null, {
                width: this.width,
                height: this.height
            }), {
                scaleMode: Rr.NEAREST,
                resolution: 1,
                width: this.width,
                height: this.height,
                mipmap: fr.OFF,
                format: V.DEPTH_COMPONENT,
                type: dt.UNSIGNED_SHORT
            }), this.dirtyId++, this.dirtyFormat++, this
        }
        enableDepth() {
            return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
        }
        enableStencil() {
            return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
        }
        resize(t, e) {
            if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {
                this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
                for (let r = 0; r < this.colorTextures.length; r++) {
                    const i = this.colorTextures[r],
                        n = i.resolution;
                    i.setSize(t / n, e / n)
                }
                if (this.depthTexture) {
                    const r = this.depthTexture.resolution;
                    this.depthTexture.setSize(t / r, e / r)
                }
            }
        }
        dispose() {
            this.disposeRunner.emit(this, !1)
        }
        destroyDepthTexture() {
            this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
        }
    }, ql = class extends mt {
        constructor(t = {}) {
            var e;
            if (typeof t == "number") {
                const r = arguments[0],
                    i = arguments[1],
                    n = arguments[2],
                    a = arguments[3];
                t = {
                    width: r,
                    height: i,
                    scaleMode: n,
                    resolution: a
                }
            }
            t.width = t.width || 100, t.height = t.height || 100, (e = t.multisample) != null || (t.multisample = Wt.NONE), super(null, t), this.mipmap = fr.OFF, this.valid = !0, this.clearColor = [0, 0, 0, 0], this.framebuffer = new _a(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = t.multisample, this.maskStack = [], this.filterStack = [{}]
        }
        resize(t, e) {
            this.framebuffer.resize(t * this.resolution, e * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
        }
        dispose() {
            this.framebuffer.dispose(), super.dispose()
        }
        destroy() {
            super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
        }
    }, Zr = class extends bn {
        constructor(t) {
            const e = t,
                r = e.naturalWidth || e.videoWidth || e.width,
                i = e.naturalHeight || e.videoHeight || e.height;
            super(r, i), this.source = t, this.noSubImage = !1
        }
        static crossOrigin(t, e, r) {
            r === void 0 && !e.startsWith("data:") ? t.crossOrigin = Am(e) : r !== !1 && (t.crossOrigin = typeof r == "string" ? r : "anonymous")
        }
        upload(t, e, r, i) {
            const n = t.gl,
                a = e.realWidth,
                l = e.realHeight;
            if (i = i || this.source, typeof HTMLImageElement < "u" && i instanceof HTMLImageElement) {
                if (!i.complete || i.naturalWidth === 0) return !1
            } else if (typeof HTMLVideoElement < "u" && i instanceof HTMLVideoElement && i.readyState <= 1 && i.buffered.length === 0) return !1;
            return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === tr.UNPACK), !this.noSubImage && e.target === n.TEXTURE_2D && r.width === a && r.height === l ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, r.type, i) : (r.width = a, r.height = l, n.texImage2D(e.target, 0, r.internalFormat, e.format, r.type, i)), !0
        }
        update() {
            if (this.destroyed) return;
            const t = this.source,
                e = t.naturalWidth || t.videoWidth || t.width,
                r = t.naturalHeight || t.videoHeight || t.height;
            this.resize(e, r), super.update()
        }
        dispose() {
            this.source = null
        }
    }, Yl = class extends Zr {
        constructor(t, e) {
            var r;
            if (e = e || {}, typeof t == "string") {
                const i = new Image;
                Zr.crossOrigin(i, t, e.crossorigin), i.src = t, t = i
            }
            super(t), !t.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = t.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = ((r = e.createBitmap) != null ? r : et.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof e.alphaMode == "number" ? e.alphaMode : null, this.bitmap = null, this._load = null, e.autoLoad !== !1 && this.load()
        }
        load(t) {
            return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise((e, r) => {
                const i = this.source;
                this.url = i.src;
                const n = () => {
                    this.destroyed || (i.onload = null, i.onerror = null, this.resize(i.width, i.height), this._load = null, this.createBitmap ? e(this.process()) : e(this))
                };
                i.complete && i.src ? n() : (i.onload = n, i.onerror = a => {
                    r(a), this.onError.emit(a)
                })
            }), this._load)
        }
        process() {
            const t = this.source;
            if (this._process !== null) return this._process;
            if (this.bitmap !== null || !globalThis.createImageBitmap) return Promise.resolve(this);
            const e = globalThis.createImageBitmap,
                r = !t.crossOrigin || t.crossOrigin === "anonymous";
            return this._process = fetch(t.src, {
                mode: r ? "cors" : "no-cors"
            }).then(i => i.blob()).then(i => e(i, 0, 0, t.width, t.height, {
                premultiplyAlpha: this.alphaMode === null || this.alphaMode === tr.UNPACK ? "premultiply" : "none"
            })).then(i => this.destroyed ? Promise.reject() : (this.bitmap = i, this.update(), this._process = null, Promise.resolve(this))), this._process
        }
        upload(t, e, r) {
            if (typeof this.alphaMode == "number" && (e.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(t, e, r);
            if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
            if (super.upload(t, e, r, this.bitmap), !this.preserveBitmap) {
                let i = !0;
                const n = e._glTextures;
                for (const a in n) {
                    const l = n[a];
                    if (l !== r && l.dirtyId !== e.dirtyId) {
                        i = !1;
                        break
                    }
                }
                i && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
            }
            return !0
        }
        dispose() {
            this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
        }
        static test(t) {
            return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
        }
    }, ah = class {
        constructor() {
            this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
        }
        set(t, e, r) {
            const i = e.width,
                n = e.height;
            if (r) {
                const a = t.width / 2 / i,
                    l = t.height / 2 / n,
                    h = t.x / i + a,
                    c = t.y / n + l;
                r = Gt.add(r, Gt.NW), this.x0 = h + a * Gt.uX(r), this.y0 = c + l * Gt.uY(r), r = Gt.add(r, 2), this.x1 = h + a * Gt.uX(r), this.y1 = c + l * Gt.uY(r), r = Gt.add(r, 2), this.x2 = h + a * Gt.uX(r), this.y2 = c + l * Gt.uY(r), r = Gt.add(r, 2), this.x3 = h + a * Gt.uX(r), this.y3 = c + l * Gt.uY(r)
            } else this.x0 = t.x / i, this.y0 = t.y / n, this.x1 = (t.x + t.width) / i, this.y1 = t.y / n, this.x2 = (t.x + t.width) / i, this.y2 = (t.y + t.height) / n, this.x3 = t.x / i, this.y3 = (t.y + t.height) / n;
            this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
        }
        toString() {
            return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
        }
    };
    const zm = new ah;

    function ho(t) {
        t.destroy = function() {}, t.on = function() {}, t.once = function() {}, t.emit = function() {}
    }
    Q = class extends An {
        constructor(t, e, r, i, n, a) {
            if (super(), this.noFrame = !1, e || (this.noFrame = !0, e = new bt(0, 0, 1, 1)), t instanceof Q && (t = t.baseTexture), this.baseTexture = t, this._frame = e, this.trim = i, this.valid = !1, this._uvs = zm, this.uvMatrix = null, this.orig = r || e, this._rotate = Number(n || 0), n === !0) this._rotate = 2;
            else if (this._rotate % 2 !== 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
            this.defaultAnchor = a ? new gt(a.x, a.y) : new gt(0, 0), this._updateID = 0, this.textureCacheIds = [], t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = e : t.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
        }
        update() {
            this.baseTexture.resource && this.baseTexture.resource.update()
        }
        onBaseTextureUpdated(t) {
            if (this.noFrame) {
                if (!this.baseTexture.valid) return;
                this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
            } else this.frame = this._frame;
            this.emit("update", this)
        }
        destroy(t) {
            if (this.baseTexture) {
                if (t) {
                    const {
                        resource: e
                    } = this.baseTexture;
                    e != null && e.url && ve[e.url] && Q.removeFromCache(e.url), this.baseTexture.destroy()
                }
                this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
            }
            this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, Q.removeFromCache(this), this.textureCacheIds = null
        }
        clone() {
            var t;
            const e = this._frame.clone(),
                r = this._frame === this.orig ? e : this.orig.clone(),
                i = new Q(this.baseTexture, !this.noFrame && e, r, (t = this.trim) == null ? void 0 : t.clone(), this.rotate, this.defaultAnchor);
            return this.noFrame && (i._frame = e), i
        }
        updateUvs() {
            this._uvs === zm && (this._uvs = new ah), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
        }
        static from(t, e = {}, r = et.STRICT_TEXTURE_CACHE) {
            const i = typeof t == "string";
            let n = null;
            if (i) n = t;
            else if (t instanceof mt) {
                if (!t.cacheId) {
                    const l = (e == null ? void 0 : e.pixiIdPrefix) || "pixiid";
                    t.cacheId = `${l}-${wi()}`, mt.addToCache(t, t.cacheId)
                }
                n = t.cacheId
            } else {
                if (!t._pixiId) {
                    const l = (e == null ? void 0 : e.pixiIdPrefix) || "pixiid";
                    t._pixiId = `${l}_${wi()}`
                }
                n = t._pixiId
            }
            let a = ve[n];
            if (i && r && !a) throw new Error(`The cacheId "${n}" does not exist in TextureCache.`);
            return !a && !(t instanceof mt) ? (e.resolution || (e.resolution = ni(t)), a = new Q(new mt(t, e)), a.baseTexture.cacheId = n, mt.addToCache(a.baseTexture, n), Q.addToCache(a, n)) : !a && t instanceof mt && (a = new Q(t), Q.addToCache(a, n)), a
        }
        static fromURL(t, e) {
            const r = Object.assign({
                    autoLoad: !1
                }, e == null ? void 0 : e.resourceOptions),
                i = Q.from(t, Object.assign({
                    resourceOptions: r
                }, e), !1),
                n = i.baseTexture.resource;
            return i.baseTexture.valid ? Promise.resolve(i) : n.load().then(() => Promise.resolve(i))
        }
        static fromBuffer(t, e, r, i) {
            return new Q(mt.fromBuffer(t, e, r, i))
        }
        static fromLoader(t, e, r, i) {
            const n = new mt(t, Object.assign({
                    scaleMode: mt.defaultOptions.scaleMode,
                    resolution: ni(e)
                }, i)),
                {
                    resource: a
                } = n;
            a instanceof Yl && (a.url = e);
            const l = new Q(n);
            return r || (r = e), mt.addToCache(l.baseTexture, r), Q.addToCache(l, r), r !== e && (mt.addToCache(l.baseTexture, e), Q.addToCache(l, e)), l.baseTexture.valid ? Promise.resolve(l) : new Promise(h => {
                l.baseTexture.once("loaded", () => h(l))
            })
        }
        static addToCache(t, e) {
            e && (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e), ve[e] && ve[e], ve[e] = t)
        }
        static removeFromCache(t) {
            if (typeof t == "string") {
                const e = ve[t];
                if (e) {
                    const r = e.textureCacheIds.indexOf(t);
                    return r > -1 && e.textureCacheIds.splice(r, 1), delete ve[t], e
                }
            } else if (t != null && t.textureCacheIds) {
                for (let e = 0; e < t.textureCacheIds.length; ++e) ve[t.textureCacheIds[e]] === t && delete ve[t.textureCacheIds[e]];
                return t.textureCacheIds.length = 0, t
            }
            return null
        }
        get resolution() {
            return this.baseTexture.resolution
        }
        get frame() {
            return this._frame
        }
        set frame(t) {
            this._frame = t, this.noFrame = !1;
            const {
                x: e,
                y: r,
                width: i,
                height: n
            } = t, a = e + i > this.baseTexture.width, l = r + n > this.baseTexture.height;
            if (a || l) {
                const h = a && l ? "and" : "or",
                    c = `X: ${e} + ${i} = ${e+i} > ${this.baseTexture.width}`,
                    d = `Y: ${r} + ${n} = ${r+n} > ${this.baseTexture.height}`;
                throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${h} ${d}`)
            }
            this.valid = i && n && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs()
        }
        get rotate() {
            return this._rotate
        }
        set rotate(t) {
            this._rotate = t, this.valid && this.updateUvs()
        }
        get width() {
            return this.orig.width
        }
        get height() {
            return this.orig.height
        }
        castToBaseTexture() {
            return this.baseTexture
        }
        static get EMPTY() {
            return Q._EMPTY || (Q._EMPTY = new Q(new mt), ho(Q._EMPTY), ho(Q._EMPTY.baseTexture)), Q._EMPTY
        }
        static get WHITE() {
            if (!Q._WHITE) {
                const t = et.ADAPTER.createCanvas(16, 16),
                    e = t.getContext("2d");
                t.width = 16, t.height = 16, e.fillStyle = "white", e.fillRect(0, 0, 16, 16), Q._WHITE = new Q(mt.from(t)), ho(Q._WHITE), ho(Q._WHITE.baseTexture)
            }
            return Q._WHITE
        }
    }, yi = class extends Q {
        constructor(t, e) {
            super(t, e), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
        }
        get framebuffer() {
            return this.baseTexture.framebuffer
        }
        get multisample() {
            return this.framebuffer.multisample
        }
        set multisample(t) {
            this.framebuffer.multisample = t
        }
        resize(t, e, r = !0) {
            const i = this.baseTexture.resolution,
                n = Math.round(t * i) / i,
                a = Math.round(e * i) / i;
            this.valid = n > 0 && a > 0, this._frame.width = this.orig.width = n, this._frame.height = this.orig.height = a, r && this.baseTexture.resize(n, a), this.updateUvs()
        }
        setResolution(t) {
            const {
                baseTexture: e
            } = this;
            e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
        }
        static create(t) {
            return new yi(new ql(t))
        }
    }, ch = class {
        constructor(t) {
            this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
        }
        createTexture(t, e, r = Wt.NONE) {
            const i = new ql(Object.assign({
                width: t,
                height: e,
                resolution: 1,
                multisample: r
            }, this.textureOptions));
            return new yi(i)
        }
        getOptimalTexture(t, e, r = 1, i = Wt.NONE) {
            let n;
            t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = Ds(t), e = Ds(e), n = ((t & 65535) << 16 | e & 65535) >>> 0, i > 1 && (n += i * 4294967296)) : n = i > 1 ? -i : -1, this.texturePool[n] || (this.texturePool[n] = []);
            let a = this.texturePool[n].pop();
            return a || (a = this.createTexture(t, e, i)), a.filterPoolKey = n, a.setResolution(r), a
        }
        getFilterTexture(t, e, r) {
            const i = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || Wt.NONE);
            return i.filterFrame = t.filterFrame, i
        }
        returnTexture(t) {
            const e = t.filterPoolKey;
            t.filterFrame = null, this.texturePool[e].push(t)
        }
        returnFilterTexture(t) {
            this.returnTexture(t)
        }
        clear(t) {
            if (t = t !== !1, t)
                for (const e in this.texturePool) {
                    const r = this.texturePool[e];
                    if (r)
                        for (let i = 0; i < r.length; i++) r[i].destroy(!0)
                }
            this.texturePool = {}
        }
        setScreenSize(t) {
            if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
                this.enableFullScreen = t.width > 0 && t.height > 0;
                for (const e in this.texturePool) {
                    if (!(Number(e) < 0)) continue;
                    const r = this.texturePool[e];
                    if (r)
                        for (let i = 0; i < r.length; i++) r[i].destroy(!0);
                    this.texturePool[e] = []
                }
                this._pixelsWidth = t.width, this._pixelsHeight = t.height
            }
        }
    }, ch.SCREEN_KEY = -1, vp = class extends fi {
        constructor() {
            super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
        }
    }, th = class extends fi {
        constructor() {
            super(), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new Zt(this.vertices), this.uvBuffer = new Zt(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
        }
        map(t, e) {
            let r = 0,
                i = 0;
            return this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + e.width / t.width, this.uvs[3] = i, this.uvs[4] = r + e.width / t.width, this.uvs[5] = i + e.height / t.height, this.uvs[6] = r, this.uvs[7] = i + e.height / t.height, r = e.x, i = e.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + e.width, this.vertices[3] = i, this.vertices[4] = r + e.width, this.vertices[5] = i + e.height, this.vertices[6] = r, this.vertices[7] = i + e.height, this.invalidate(), this
        }
        invalidate() {
            return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
        }
    }, fp = class {
        constructor() {
            this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = Wt.NONE, this.sourceFrame = new bt, this.destinationFrame = new bt, this.bindingSourceFrame = new bt, this.bindingDestinationFrame = new bt, this.filters = [], this.transform = null
        }
        clear() {
            this.target = null, this.filters = null, this.renderTexture = null
        }
    };
    const uo = [new gt, new gt, new gt, new gt],
        Pu = new Ut;
    jl = class {
        constructor(t) {
            this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new ch, this.statePool = [], this.quad = new vp, this.quadUv = new th, this.tempRect = new bt, this.activeState = {}, this.globalUniforms = new mr({
                outputFrame: new bt,
                inputSize: new Float32Array(4),
                inputPixel: new Float32Array(4),
                inputClamp: new Float32Array(4),
                resolution: 1,
                filterArea: new Float32Array(4),
                filterClamp: new Float32Array(4)
            }, !0), this.forceClear = !1, this.useMaxPadding = !1
        }
        init() {
            this.texturePool.setScreenSize(this.renderer.view)
        }
        push(t, e) {
            var x, _;
            const r = this.renderer,
                i = this.defaultFilterStack,
                n = this.statePool.pop() || new fp,
                a = this.renderer.renderTexture;
            let l = e[0].resolution,
                h = e[0].multisample,
                c = e[0].padding,
                d = e[0].autoFit,
                f = (x = e[0].legacy) != null ? x : !0;
            for (let E = 1; E < e.length; E++) {
                const w = e[E];
                l = Math.min(l, w.resolution), h = Math.min(h, w.multisample), c = this.useMaxPadding ? Math.max(c, w.padding) : c + w.padding, d = d && w.autoFit, f = f || ((_ = w.legacy) != null ? _ : !0)
            }
            i.length === 1 && (this.defaultFilterStack[0].renderTexture = a.current), i.push(n), n.resolution = l, n.multisample = h, n.legacy = f, n.target = t, n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), n.sourceFrame.pad(c);
            const g = this.tempRect.copyFrom(a.sourceFrame);
            r.projection.transform && this.transformAABB(Pu.copyFrom(r.projection.transform).invert(), g), d ? (n.sourceFrame.fit(g), (n.sourceFrame.width <= 0 || n.sourceFrame.height <= 0) && (n.sourceFrame.width = 0, n.sourceFrame.height = 0)) : n.sourceFrame.intersects(g) || (n.sourceFrame.width = 0, n.sourceFrame.height = 0), this.roundFrame(n.sourceFrame, a.current ? a.current.resolution : r.resolution, a.sourceFrame, a.destinationFrame, r.projection.transform), n.renderTexture = this.getOptimalFilterTexture(n.sourceFrame.width, n.sourceFrame.height, l, h), n.filters = e, n.destinationFrame.width = n.renderTexture.width, n.destinationFrame.height = n.renderTexture.height;
            const y = this.tempRect;
            y.x = 0, y.y = 0, y.width = n.sourceFrame.width, y.height = n.sourceFrame.height, n.renderTexture.filterFrame = n.sourceFrame, n.bindingSourceFrame.copyFrom(a.sourceFrame), n.bindingDestinationFrame.copyFrom(a.destinationFrame), n.transform = r.projection.transform, r.projection.transform = null, a.bind(n.renderTexture, n.sourceFrame, y), r.framebuffer.clear(0, 0, 0, 0)
        }
        pop() {
            const t = this.defaultFilterStack,
                e = t.pop(),
                r = e.filters;
            this.activeState = e;
            const i = this.globalUniforms.uniforms;
            i.outputFrame = e.sourceFrame, i.resolution = e.resolution;
            const n = i.inputSize,
                a = i.inputPixel,
                l = i.inputClamp;
            if (n[0] = e.destinationFrame.width, n[1] = e.destinationFrame.height, n[2] = 1 / n[0], n[3] = 1 / n[1], a[0] = Math.round(n[0] * e.resolution), a[1] = Math.round(n[1] * e.resolution), a[2] = 1 / a[0], a[3] = 1 / a[1], l[0] = .5 * a[2], l[1] = .5 * a[3], l[2] = e.sourceFrame.width * n[2] - .5 * a[2], l[3] = e.sourceFrame.height * n[3] - .5 * a[3], e.legacy) {
                const c = i.filterArea;
                c[0] = e.destinationFrame.width, c[1] = e.destinationFrame.height, c[2] = e.sourceFrame.x, c[3] = e.sourceFrame.y, i.filterClamp = i.inputClamp
            }
            this.globalUniforms.update();
            const h = t[t.length - 1];
            if (this.renderer.framebuffer.blit(), r.length === 1) r[0].apply(this, e.renderTexture, h.renderTexture, yr.BLEND, e), this.returnFilterTexture(e.renderTexture);
            else {
                let c = e.renderTexture,
                    d = this.getOptimalFilterTexture(c.width, c.height, e.resolution);
                d.filterFrame = c.filterFrame;
                let f = 0;
                for (f = 0; f < r.length - 1; ++f) {
                    f === 1 && e.multisample > 1 && (d = this.getOptimalFilterTexture(c.width, c.height, e.resolution), d.filterFrame = c.filterFrame), r[f].apply(this, c, d, yr.CLEAR, e);
                    const g = c;
                    c = d, d = g
                }
                r[f].apply(this, c, h.renderTexture, yr.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(c), this.returnFilterTexture(d)
            }
            e.clear(), this.statePool.push(e)
        }
        bindAndClear(t, e = yr.CLEAR) {
            const {
                renderTexture: r,
                state: i
            } = this.renderer;
            if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t != null && t.filterFrame) {
                const a = this.tempRect;
                a.x = 0, a.y = 0, a.width = t.filterFrame.width, a.height = t.filterFrame.height, r.bind(t, t.filterFrame, a)
            } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
            const n = i.stateId & 1 || this.forceClear;
            (e === yr.CLEAR || e === yr.BLIT && n) && this.renderer.framebuffer.clear(0, 0, 0, 0)
        }
        applyFilter(t, e, r, i) {
            const n = this.renderer;
            n.state.set(t.state), this.bindAndClear(r, i), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, n.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), n.geometry.bind(this.quadUv), n.geometry.draw(Ye.TRIANGLES)) : (n.geometry.bind(this.quad), n.geometry.draw(Ye.TRIANGLE_STRIP))
        }
        calculateSpriteMatrix(t, e) {
            const {
                sourceFrame: r,
                destinationFrame: i
            } = this.activeState, {
                orig: n
            } = e._texture, a = t.set(i.width, 0, 0, i.height, r.x, r.y), l = e.worldTransform.copyTo(Ut.TEMP_MATRIX);
            return l.invert(), a.prepend(l), a.scale(1 / n.width, 1 / n.height), a.translate(e.anchor.x, e.anchor.y), a
        }
        destroy() {
            this.renderer = null, this.texturePool.clear(!1)
        }
        getOptimalFilterTexture(t, e, r = 1, i = Wt.NONE) {
            return this.texturePool.getOptimalTexture(t, e, r, i)
        }
        getFilterTexture(t, e, r) {
            if (typeof t == "number") {
                const n = t;
                t = e, e = n
            }
            t = t || this.activeState.renderTexture;
            const i = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || Wt.NONE);
            return i.filterFrame = t.filterFrame, i
        }
        returnFilterTexture(t) {
            this.texturePool.returnTexture(t)
        }
        emptyPool() {
            this.texturePool.clear(!0)
        }
        resize() {
            this.texturePool.setScreenSize(this.renderer.view)
        }
        transformAABB(t, e) {
            const r = uo[0],
                i = uo[1],
                n = uo[2],
                a = uo[3];
            r.set(e.left, e.top), i.set(e.left, e.bottom), n.set(e.right, e.top), a.set(e.right, e.bottom), t.apply(r, r), t.apply(i, i), t.apply(n, n), t.apply(a, a);
            const l = Math.min(r.x, i.x, n.x, a.x),
                h = Math.min(r.y, i.y, n.y, a.y),
                c = Math.max(r.x, i.x, n.x, a.x),
                d = Math.max(r.y, i.y, n.y, a.y);
            e.x = l, e.y = h, e.width = c - l, e.height = d - h
        }
        roundFrame(t, e, r, i, n) {
            if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {
                if (n) {
                    const {
                        a,
                        b: l,
                        c: h,
                        d: c
                    } = n;
                    if ((Math.abs(l) > 1e-4 || Math.abs(h) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(c) > 1e-4)) return
                }
                n = n ? Pu.copyFrom(n) : Pu.identity(), n.translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.transformAABB(n, t), t.ceil(e), this.transformAABB(n.invert(), t)
            }
        }
    }, jl.extension = {
        type: Z.RendererSystem,
        name: "filter"
    }, lt.add(jl), mp = class {
        constructor(t) {
            this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = Wt.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
        }
    };
    const yT = new bt;
    Wl = class {
        constructor(t) {
            this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new _a(10, 10), this.msaaSamples = null
        }
        contextChange() {
            this.disposeAll(!0);
            const t = this.gl = this.renderer.gl;
            if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new bt, this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
                let e = this.renderer.context.extensions.drawBuffers,
                    r = this.renderer.context.extensions.depthTexture;
                et.PREFER_ENV === pi.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = i => e.drawBuffersWEBGL(i) : (this.hasMRT = !1, t.drawBuffers = () => {}), r || (this.writeDepthTexture = !1)
            } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
        }
        bind(t, e, r = 0) {
            const {
                gl: i
            } = this;
            if (t) {
                const n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
                this.current !== t && (this.current = t, i.bindFramebuffer(i.FRAMEBUFFER, n.framebuffer)), n.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, n.mipLevel = r), n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId, n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat, n.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
                for (let a = 0; a < t.colorTextures.length; a++) {
                    const l = t.colorTextures[a];
                    this.renderer.texture.unbind(l.parentTextureArray || l)
                }
                if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {
                    const a = e.width >> r,
                        l = e.height >> r,
                        h = a / e.width;
                    this.setViewport(e.x * h, e.y * h, a, l)
                } else {
                    const a = t.width >> r,
                        l = t.height >> r;
                    this.setViewport(0, 0, a, l)
                }
            } else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
        }
        setViewport(t, e, r, i) {
            const n = this.viewport;
            t = Math.round(t), e = Math.round(e), r = Math.round(r), i = Math.round(i), (n.width !== r || n.height !== i || n.x !== t || n.y !== e) && (n.x = t, n.y = e, n.width = r, n.height = i, this.gl.viewport(t, e, r, i))
        }
        get size() {
            return this.current ? {
                x: 0,
                y: 0,
                width: this.current.width,
                height: this.current.height
            } : {
                x: 0,
                y: 0,
                width: this.renderer.width,
                height: this.renderer.height
            }
        }
        clear(t, e, r, i, n = Oa.COLOR | Oa.DEPTH) {
            const {
                gl: a
            } = this;
            a.clearColor(t, e, r, i), a.clear(n)
        }
        initFramebuffer(t) {
            const {
                gl: e
            } = this, r = new mp(e.createFramebuffer());
            return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r
        }
        resizeFramebuffer(t) {
            const {
                gl: e
            } = this, r = t.glFramebuffers[this.CONTEXT_UID];
            r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
            const i = t.colorTextures;
            let n = i.length;
            e.drawBuffers || (n = Math.min(n, 1));
            for (let a = 0; a < n; a++) {
                const l = i[a],
                    h = l.parentTextureArray || l;
                this.renderer.texture.bind(h, 0), a === 0 && r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
            }
            t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
        }
        updateFramebuffer(t, e) {
            const {
                gl: r
            } = this, i = t.glFramebuffers[this.CONTEXT_UID], n = t.colorTextures;
            let a = n.length;
            r.drawBuffers || (a = Math.min(a, 1)), i.multisample > 1 && this.canMultisampleFramebuffer(t) ? i.msaaBuffer = i.msaaBuffer || r.createRenderbuffer() : i.msaaBuffer && (r.deleteRenderbuffer(i.msaaBuffer), i.msaaBuffer = null, i.blitFramebuffer && (i.blitFramebuffer.dispose(), i.blitFramebuffer = null));
            const l = [];
            for (let h = 0; h < a; h++) {
                const c = n[h],
                    d = c.parentTextureArray || c;
                this.renderer.texture.bind(d, 0), h === 0 && i.msaaBuffer ? (r.bindRenderbuffer(r.RENDERBUFFER, i.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, d._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, i.msaaBuffer)) : (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + h, c.target, d._glTextures[this.CONTEXT_UID].texture, e), l.push(r.COLOR_ATTACHMENT0 + h))
            }
            if (l.length > 1 && r.drawBuffers(l), t.depthTexture && this.writeDepthTexture) {
                const h = t.depthTexture;
                this.renderer.texture.bind(h, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, h._glTextures[this.CONTEXT_UID].texture, e)
            }(t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (i.stencil = i.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, i.stencil), i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i.stencil)) : i.stencil && (r.deleteRenderbuffer(i.stencil), i.stencil = null)
        }
        canMultisampleFramebuffer(t) {
            return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
        }
        detectSamples(t) {
            const {
                msaaSamples: e
            } = this;
            let r = Wt.NONE;
            if (t <= 1 || e === null) return r;
            for (let i = 0; i < e.length; i++)
                if (e[i] <= t) {
                    r = e[i];
                    break
                }
            return r === 1 && (r = Wt.NONE), r
        }
        blit(t, e, r) {
            const {
                current: i,
                renderer: n,
                gl: a,
                CONTEXT_UID: l
            } = this;
            if (n.context.webGLVersion !== 2 || !i) return;
            const h = i.glFramebuffers[l];
            if (!h) return;
            if (!t) {
                if (!h.msaaBuffer) return;
                const d = i.colorTextures[0];
                if (!d) return;
                h.blitFramebuffer || (h.blitFramebuffer = new _a(i.width, i.height), h.blitFramebuffer.addColorTexture(0, d)), t = h.blitFramebuffer, t.colorTextures[0] !== d && (t.colorTextures[0] = d, t.dirtyId++, t.dirtyFormat++), (t.width !== i.width || t.height !== i.height) && (t.width = i.width, t.height = i.height, t.dirtyId++, t.dirtySize++)
            }
            e || (e = yT, e.width = i.width, e.height = i.height), r || (r = e);
            const c = e.width === r.width && e.height === r.height;
            this.bind(t), a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer), a.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, a.COLOR_BUFFER_BIT, c ? a.NEAREST : a.LINEAR)
        }
        disposeFramebuffer(t, e) {
            const r = t.glFramebuffers[this.CONTEXT_UID],
                i = this.gl;
            if (!r) return;
            delete t.glFramebuffers[this.CONTEXT_UID];
            const n = this.managedFramebuffers.indexOf(t);
            n >= 0 && this.managedFramebuffers.splice(n, 1), t.disposeRunner.remove(this), e || (i.deleteFramebuffer(r.framebuffer), r.msaaBuffer && i.deleteRenderbuffer(r.msaaBuffer), r.stencil && i.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose()
        }
        disposeAll(t) {
            const e = this.managedFramebuffers;
            this.managedFramebuffers = [];
            for (let r = 0; r < e.length; r++) this.disposeFramebuffer(e[r], t)
        }
        forceStencil() {
            const t = this.current;
            if (!t) return;
            const e = t.glFramebuffers[this.CONTEXT_UID];
            if (!e || e.stencil) return;
            t.stencil = !0;
            const r = t.width,
                i = t.height,
                n = this.gl,
                a = n.createRenderbuffer();
            n.bindRenderbuffer(n.RENDERBUFFER, a), e.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, e.multisample, n.DEPTH24_STENCIL8, r, i) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, r, i), e.stencil = a, n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, a)
        }
        reset() {
            this.current = this.unknownFramebuffer, this.viewport = new bt
        }
        destroy() {
            this.renderer = null
        }
    }, Wl.extension = {
        type: Z.RendererSystem,
        name: "framebuffer"
    }, lt.add(Wl);
    const Cu = {
        5126: 4,
        5123: 2,
        5121: 1
    };
    $l = class {
        constructor(t) {
            this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
        }
        contextChange() {
            this.disposeAll(!0);
            const t = this.gl = this.renderer.gl,
                e = this.renderer.context;
            if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {
                let r = this.renderer.context.extensions.vertexArrayObject;
                et.PREFER_ENV === pi.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = () => r.createVertexArrayOES(), t.bindVertexArray = i => r.bindVertexArrayOES(i), t.deleteVertexArray = i => r.deleteVertexArrayOES(i)) : (this.hasVao = !1, t.createVertexArray = () => null, t.bindVertexArray = () => null, t.deleteVertexArray = () => null)
            }
            if (e.webGLVersion !== 2) {
                const r = t.getExtension("ANGLE_instanced_arrays");
                r ? (t.vertexAttribDivisor = (i, n) => r.vertexAttribDivisorANGLE(i, n), t.drawElementsInstanced = (i, n, a, l, h) => r.drawElementsInstancedANGLE(i, n, a, l, h), t.drawArraysInstanced = (i, n, a, l) => r.drawArraysInstancedANGLE(i, n, a, l)) : this.hasInstance = !1
            }
            this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex
        }
        bind(t, e) {
            e = e || this.renderer.shader.shader;
            const {
                gl: r
            } = this;
            let i = t.glVertexArrayObjects[this.CONTEXT_UID],
                n = !1;
            i || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = i = {}, n = !0);
            const a = i[e.program.id] || this.initGeometryVao(t, e, n);
            this._activeGeometry = t, this._activeVao !== a && (this._activeVao = a, this.hasVao ? r.bindVertexArray(a) : this.activateVao(t, e.program)), this.updateBuffers()
        }
        reset() {
            this.unbind()
        }
        updateBuffers() {
            const t = this._activeGeometry,
                e = this.renderer.buffer;
            for (let r = 0; r < t.buffers.length; r++) {
                const i = t.buffers[r];
                e.update(i)
            }
        }
        checkCompatibility(t, e) {
            const r = t.attributes,
                i = e.attributeData;
            for (const n in i)
                if (!r[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)
        }
        getSignature(t, e) {
            const r = t.attributes,
                i = e.attributeData,
                n = ["g", t.id];
            for (const a in r) i[a] && n.push(a, i[a].location);
            return n.join("-")
        }
        initGeometryVao(t, e, r = !0) {
            const i = this.gl,
                n = this.CONTEXT_UID,
                a = this.renderer.buffer,
                l = e.program;
            l.glPrograms[n] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, l);
            const h = this.getSignature(t, l),
                c = t.glVertexArrayObjects[this.CONTEXT_UID];
            let d = c[h];
            if (d) return c[l.id] = d, d;
            const f = t.buffers,
                g = t.attributes,
                y = {},
                x = {};
            for (const _ in f) y[_] = 0, x[_] = 0;
            for (const _ in g) !g[_].size && l.attributeData[_] ? g[_].size = l.attributeData[_].size : g[_].size, y[g[_].buffer] += g[_].size * Cu[g[_].type];
            for (const _ in g) {
                const E = g[_],
                    w = E.size;
                E.stride === void 0 && (y[E.buffer] === w * Cu[E.type] ? E.stride = 0 : E.stride = y[E.buffer]), E.start === void 0 && (E.start = x[E.buffer], x[E.buffer] += w * Cu[E.type])
            }
            d = i.createVertexArray(), i.bindVertexArray(d);
            for (let _ = 0; _ < f.length; _++) {
                const E = f[_];
                a.bind(E), r && E._glBuffers[n].refCount++
            }
            return this.activateVao(t, l), c[l.id] = d, c[h] = d, i.bindVertexArray(null), a.unbind(dr.ARRAY_BUFFER), d
        }
        disposeGeometry(t, e) {
            var r;
            if (!this.managedGeometries[t.id]) return;
            delete this.managedGeometries[t.id];
            const i = t.glVertexArrayObjects[this.CONTEXT_UID],
                n = this.gl,
                a = t.buffers,
                l = (r = this.renderer) == null ? void 0 : r.buffer;
            if (t.disposeRunner.remove(this), !!i) {
                if (l)
                    for (let h = 0; h < a.length; h++) {
                        const c = a[h]._glBuffers[this.CONTEXT_UID];
                        c && (c.refCount--, c.refCount === 0 && !e && l.dispose(a[h], e))
                    }
                if (!e) {
                    for (const h in i)
                        if (h[0] === "g") {
                            const c = i[h];
                            this._activeVao === c && this.unbind(), n.deleteVertexArray(c)
                        }
                }
                delete t.glVertexArrayObjects[this.CONTEXT_UID]
            }
        }
        disposeAll(t) {
            const e = Object.keys(this.managedGeometries);
            for (let r = 0; r < e.length; r++) this.disposeGeometry(this.managedGeometries[e[r]], t)
        }
        activateVao(t, e) {
            const r = this.gl,
                i = this.CONTEXT_UID,
                n = this.renderer.buffer,
                a = t.buffers,
                l = t.attributes;
            t.indexBuffer && n.bind(t.indexBuffer);
            let h = null;
            for (const c in l) {
                const d = l[c],
                    f = a[d.buffer],
                    g = f._glBuffers[i];
                if (e.attributeData[c]) {
                    h !== g && (n.bind(f), h = g);
                    const y = e.attributeData[c].location;
                    if (r.enableVertexAttribArray(y), r.vertexAttribPointer(y, d.size, d.type || r.FLOAT, d.normalized, d.stride, d.start), d.instance)
                        if (this.hasInstance) r.vertexAttribDivisor(y, d.divisor);
                        else throw new Error("geometry error, GPU Instancing is not supported on this device")
                }
            }
        }
        draw(t, e, r, i) {
            const {
                gl: n
            } = this, a = this._activeGeometry;
            if (a.indexBuffer) {
                const l = a.indexBuffer.data.BYTES_PER_ELEMENT,
                    h = l === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
                (l === 2 || l === 4 && this.canUseUInt32ElementIndex) && (a.instanced ? n.drawElementsInstanced(t, e || a.indexBuffer.data.length, h, (r || 0) * l, i || 1) : n.drawElements(t, e || a.indexBuffer.data.length, h, (r || 0) * l))
            } else a.instanced ? n.drawArraysInstanced(t, r, e || a.getSize(), i || 1) : n.drawArrays(t, r, e || a.getSize());
            return this
        }
        unbind() {
            this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
        }
        destroy() {
            this.renderer = null
        }
    }, $l.extension = {
        type: Z.RendererSystem,
        name: "geometry"
    }, lt.add($l);
    const Hm = new Ut;
    Sa = class {
        constructor(t, e) {
            this._texture = t, this.mapCoord = new Ut, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > "u" ? .5 : e, this.isSimple = !1
        }
        get texture() {
            return this._texture
        }
        set texture(t) {
            this._texture = t, this._textureID = -1
        }
        multiplyUvs(t, e) {
            e === void 0 && (e = t);
            const r = this.mapCoord;
            for (let i = 0; i < t.length; i += 2) {
                const n = t[i],
                    a = t[i + 1];
                e[i] = n * r.a + a * r.c + r.tx, e[i + 1] = n * r.b + a * r.d + r.ty
            }
            return e
        }
        update(t) {
            const e = this._texture;
            if (!e || !e.valid || !t && this._textureID === e._updateID) return !1;
            this._textureID = e._updateID, this._updateID++;
            const r = e._uvs;
            this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
            const i = e.orig,
                n = e.trim;
            n && (Hm.set(i.width / n.width, 0, 0, i.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(Hm));
            const a = e.baseTexture,
                l = this.uClampFrame,
                h = this.clampMargin / a.resolution,
                c = this.clampOffset;
            return l[0] = (e._frame.x + h + c) / a.width, l[1] = (e._frame.y + h + c) / a.height, l[2] = (e._frame.x + e._frame.width - h + c) / a.width, l[3] = (e._frame.y + e._frame.height - h + c) / a.height, this.uClampOffset[0] = c / a.realWidth, this.uClampOffset[1] = c / a.realHeight, this.isSimple = e._frame.width === a.width && e._frame.height === a.height && e.rotate === 0, !0
        }
    };
    var vT = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
        xT = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
    Cp = class extends ae {
        constructor(t, e, r) {
            let i = null;
            typeof t != "string" && e === void 0 && r === void 0 && (i = t, t = void 0, e = void 0, r = void 0), super(t || xT, e || vT, r), this.maskSprite = i, this.maskMatrix = new Ut
        }
        get maskSprite() {
            return this._maskSprite
        }
        set maskSprite(t) {
            this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
        }
        apply(t, e, r, i) {
            const n = this._maskSprite,
                a = n._texture;
            a.valid && (a.uvMatrix || (a.uvMatrix = new Sa(a, 0)), a.uvMatrix.update(), this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = a, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(a.uvMatrix.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = a.uvMatrix.uClampFrame, t.applyFilter(this, e, r, i))
        }
    }, lp = class {
        constructor(t = null) {
            this.type = ee.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = ae.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null
        }
        get filter() {
            return this._filters ? this._filters[0] : null
        }
        set filter(t) {
            t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
        }
        reset() {
            this.pooled && (this.maskObject = null, this.type = ee.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
        }
        copyCountersOrReset(t) {
            t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
        }
    }, Ul = class {
        constructor(t) {
            this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
        }
        setMaskStack(t) {
            this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
        }
        push(t, e) {
            let r = e;
            if (!r.isMaskData) {
                const n = this.maskDataPool.pop() || new lp;
                n.pooled = !0, n.maskObject = e, r = n
            }
            const i = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
            if (r.copyCountersOrReset(i), r._colorMask = i ? i._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== ee.SPRITE && this.maskStack.push(r), r.enabled) switch (r.type) {
                case ee.SCISSOR:
                    this.renderer.scissor.push(r);
                    break;
                case ee.STENCIL:
                    this.renderer.stencil.push(r);
                    break;
                case ee.SPRITE:
                    r.copyCountersOrReset(null), this.pushSpriteMask(r);
                    break;
                case ee.COLOR:
                    this.pushColorMask(r);
                    break
            }
            r.type === ee.SPRITE && this.maskStack.push(r)
        }
        pop(t) {
            const e = this.maskStack.pop();
            if (!(!e || e._target !== t)) {
                if (e.enabled) switch (e.type) {
                    case ee.SCISSOR:
                        this.renderer.scissor.pop(e);
                        break;
                    case ee.STENCIL:
                        this.renderer.stencil.pop(e.maskObject);
                        break;
                    case ee.SPRITE:
                        this.popSpriteMask(e);
                        break;
                    case ee.COLOR:
                        this.popColorMask(e);
                        break
                }
                if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {
                    const r = this.maskStack[this.maskStack.length - 1];
                    r.type === ee.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject)
                }
            }
        }
        detect(t) {
            const e = t.maskObject;
            e ? e.isSprite ? t.type = ee.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = ee.SCISSOR : t.type = ee.STENCIL : t.type = ee.COLOR
        }
        pushSpriteMask(t) {
            var d, f;
            const {
                maskObject: e
            } = t, r = t._target;
            let i = t._filters;
            i || (i = this.alphaMaskPool[this.alphaMaskIndex], i || (i = this.alphaMaskPool[this.alphaMaskIndex] = [new Cp]));
            const n = this.renderer,
                a = n.renderTexture;
            let l, h;
            if (a.current) {
                const g = a.current;
                l = t.resolution || g.resolution, h = (d = t.multisample) != null ? d : g.multisample
            } else l = t.resolution || n.resolution, h = (f = t.multisample) != null ? f : n.multisample;
            i[0].resolution = l, i[0].multisample = h, i[0].maskSprite = e;
            const c = r.filterArea;
            r.filterArea = e.getBounds(!0), n.filter.push(r, i), r.filterArea = c, t._filters || this.alphaMaskIndex++
        }
        popSpriteMask(t) {
            this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
        }
        pushColorMask(t) {
            const e = t._colorMask,
                r = t._colorMask = e & t.colorMask;
            r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)
        }
        popColorMask(t) {
            const e = t._colorMask,
                r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
            r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)
        }
        destroy() {
            this.renderer = null
        }
    }, Ul.extension = {
        type: Z.RendererSystem,
        name: "mask"
    }, lt.add(Ul);
    class jm {
        constructor(e) {
            this.renderer = e, this.maskStack = [], this.glConst = 0
        }
        getStackLength() {
            return this.maskStack.length
        }
        setMaskStack(e) {
            const {
                gl: r
            } = this.renderer, i = this.getStackLength();
            this.maskStack = e;
            const n = this.getStackLength();
            n !== i && (n === 0 ? r.disable(this.glConst) : (r.enable(this.glConst), this._useCurrent()))
        }
        _useCurrent() {}
        destroy() {
            this.renderer = null, this.maskStack = null
        }
    }
    const Wm = new Ut,
        Xm = [],
        co = class extends jm {
            constructor(t) {
                super(t), this.glConst = et.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
            }
            getStackLength() {
                const t = this.maskStack[this.maskStack.length - 1];
                return t ? t._scissorCounter : 0
            }
            calcScissorRect(t) {
                var l;
                if (t._scissorRectLocal) return;
                const e = t._scissorRect,
                    {
                        maskObject: r
                    } = t,
                    {
                        renderer: i
                    } = this,
                    n = i.renderTexture,
                    a = r.getBounds(!0, (l = Xm.pop()) != null ? l : new bt);
                this.roundFrameToPixels(a, n.current ? n.current.resolution : i.resolution, n.sourceFrame, n.destinationFrame, i.projection.transform), e && a.fit(e), t._scissorRectLocal = a
            }
            static isMatrixRotated(t) {
                if (!t) return !1;
                const {
                    a: e,
                    b: r,
                    c: i,
                    d: n
                } = t;
                return (Math.abs(r) > 1e-4 || Math.abs(i) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(n) > 1e-4)
            }
            testScissor(t) {
                const {
                    maskObject: e
                } = t;
                if (!e.isFastRect || !e.isFastRect() || co.isMatrixRotated(e.worldTransform) || co.isMatrixRotated(this.renderer.projection.transform)) return !1;
                this.calcScissorRect(t);
                const r = t._scissorRectLocal;
                return r.width > 0 && r.height > 0
            }
            roundFrameToPixels(t, e, r, i, n) {
                co.isMatrixRotated(n) || (n = n ? Wm.copyFrom(n) : Wm.identity(), n.translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.renderer.filter.transformAABB(n, t), t.fit(i), t.x = Math.round(t.x * e), t.y = Math.round(t.y * e), t.width = Math.round(t.width * e), t.height = Math.round(t.height * e))
            }
            push(t) {
                t._scissorRectLocal || this.calcScissorRect(t);
                const {
                    gl: e
                } = this.renderer;
                t._scissorRect || e.enable(e.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent()
            }
            pop(t) {
                const {
                    gl: e
                } = this.renderer;
                t && Xm.push(t._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : e.disable(e.SCISSOR_TEST)
            }
            _useCurrent() {
                const t = this.maskStack[this.maskStack.length - 1]._scissorRect;
                let e;
                this.renderer.renderTexture.current ? e = t.y : e = this.renderer.height - t.height - t.y, this.renderer.gl.scissor(t.x, e, t.width, t.height)
            }
        };
    mh = co, mh.extension = {
        type: Z.RendererSystem,
        name: "scissor"
    }, lt.add(mh), ih = class extends jm {
        constructor(t) {
            super(t), this.glConst = et.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
        }
        getStackLength() {
            const t = this.maskStack[this.maskStack.length - 1];
            return t ? t._stencilCounter : 0
        }
        push(t) {
            const e = t.maskObject,
                {
                    gl: r
                } = this.renderer,
                i = t._stencilCounter;
            i === 0 && (this.renderer.framebuffer.forceStencil(), r.clearStencil(0), r.clear(r.STENCIL_BUFFER_BIT), r.enable(r.STENCIL_TEST)), t._stencilCounter++;
            const n = t._colorMask;
            n !== 0 && (t._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilFunc(r.EQUAL, i, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, n !== 0 && (t._colorMask = n, r.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)), this._useCurrent()
        }
        pop(t) {
            const e = this.renderer.gl;
            if (this.getStackLength() === 0) e.disable(e.STENCIL_TEST);
            else {
                const r = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null,
                    i = r ? r._colorMask : 15;
                i !== 0 && (r._colorMask = 0, e.colorMask(!1, !1, !1, !1)), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, i !== 0 && (r._colorMask = i, e.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)), this._useCurrent()
            }
        }
        _useCurrent() {
            const t = this.renderer.gl;
            t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
        }
    }, ih.extension = {
        type: Z.RendererSystem,
        name: "stencil"
    }, lt.add(ih), Kl = class {
        constructor(t) {
            this.renderer = t, this.plugins = {}, Object.defineProperties(this.plugins, {
                extract: {
                    enumerable: !1,
                    get() {
                        return Tt("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), t.extract
                    }
                },
                prepare: {
                    enumerable: !1,
                    get() {
                        return Tt("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), t.prepare
                    }
                },
                interaction: {
                    enumerable: !1,
                    get() {
                        return Tt("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), t.events
                    }
                }
            })
        }
        init(t) {
            for (const e in t) this.plugins[e] = new t[e](this.renderer)
        }
        destroy() {
            for (const t in this.plugins) this.plugins[t].destroy(), this.plugins[t] = null
        }
    }, Kl.extension = {
        type: [Z.RendererSystem, Z.CanvasRendererSystem],
        name: "_plugin"
    }, lt.add(Kl), Jl = class {
        constructor(t) {
            this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Ut, this.transform = null
        }
        update(t, e, r, i) {
            this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, i), this.transform && this.projectionMatrix.append(this.transform);
            const n = this.renderer;
            n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, n.globalUniforms.update(), n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)
        }
        calculateProjection(t, e, r, i) {
            const n = this.projectionMatrix,
                a = i ? -1 : 1;
            n.identity(), n.a = 1 / e.width * 2, n.d = a * (1 / e.height * 2), n.tx = -1 - e.x * n.a, n.ty = -a - e.y * n.d
        }
        setTransform(t) {}
        destroy() {
            this.renderer = null
        }
    }, Jl.extension = {
        type: Z.RendererSystem,
        name: "projection"
    }, lt.add(Jl);
    const _T = new gs;
    Xl = class {
        constructor(t) {
            this.renderer = t, this._tempMatrix = new Ut
        }
        generateTexture(t, e) {
            const h = e || {},
                {
                    region: r
                } = h,
                i = Kd(h, ["region"]),
                n = r || t.getLocalBounds(null, !0);
            n.width === 0 && (n.width = 1), n.height === 0 && (n.height = 1);
            const a = yi.create(Kr({
                width: n.width,
                height: n.height
            }, i));
            this._tempMatrix.tx = -n.x, this._tempMatrix.ty = -n.y;
            const l = t.transform;
            return t.transform = _T, this.renderer.render(t, {
                renderTexture: a,
                transform: this._tempMatrix,
                skipUpdateTransform: !!t.parent,
                blit: !0
            }), t.transform = l, a
        }
        destroy() {}
    }, Xl.extension = {
        type: [Z.RendererSystem, Z.CanvasRendererSystem],
        name: "textureGenerator"
    }, lt.add(Xl);
    const tn = new bt,
        Bs = new bt;
    dh = class {
        constructor(t) {
            this.renderer = t, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new bt, this.destinationFrame = new bt, this.viewportFrame = new bt
        }
        bind(t = null, e, r) {
            const i = this.renderer;
            this.current = t;
            let n, a, l;
            t ? (n = t.baseTexture, l = n.resolution, e || (tn.width = t.frame.width, tn.height = t.frame.height, e = tn), r || (Bs.x = t.frame.x, Bs.y = t.frame.y, Bs.width = e.width, Bs.height = e.height, r = Bs), a = n.framebuffer) : (l = i.resolution, e || (tn.width = i._view.screen.width, tn.height = i._view.screen.height, e = tn), r || (r = tn, r.width = e.width, r.height = e.height));
            const h = this.viewportFrame;
            h.x = r.x * l, h.y = r.y * l, h.width = r.width * l, h.height = r.height * l, t || (h.y = i.view.height - (h.y + h.height)), h.ceil(), this.renderer.framebuffer.bind(a, h), this.renderer.projection.update(r, e, l, !a), t ? this.renderer.mask.setMaskStack(n.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r)
        }
        clear(t, e) {
            this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.renderer.background.colorRgba;
            const r = this.destinationFrame,
                i = this.current ? this.current.baseTexture : this.renderer._view.screen,
                n = r.width !== i.width || r.height !== i.height;
            if (n) {
                let {
                    x: a,
                    y: l,
                    width: h,
                    height: c
                } = this.viewportFrame;
                a = Math.round(a), l = Math.round(l), h = Math.round(h), c = Math.round(c), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, l, h, c)
            }
            this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), n && this.renderer.scissor.pop()
        }
        resize() {
            this.bind(null)
        }
        reset() {
            this.bind(null)
        }
        destroy() {
            this.renderer = null
        }
    }, dh.extension = {
        type: Z.RendererSystem,
        name: "renderTexture"
    }, lt.add(dh), uv = class {}, gp = class {
        constructor(t, e) {
            this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
        }
        destroy() {
            this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
        }
    };

    function bT(t, e) {
        const r = {},
            i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
        for (let n = 0; n < i; n++) {
            const a = e.getActiveAttrib(t, n);
            if (a.name.startsWith("gl_")) continue;
            const l = Fm(e, a.type),
                h = {
                    type: l,
                    name: a.name,
                    size: Bm(l),
                    location: e.getAttribLocation(t, a.name)
                };
            r[a.name] = h
        }
        return r
    }

    function ET(t, e) {
        const r = {},
            i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let n = 0; n < i; n++) {
            const a = e.getActiveUniform(t, n),
                l = a.name.replace(/\[.*?\]$/, ""),
                h = !!a.name.match(/\[.*?\]$/),
                c = Fm(e, a.type);
            r[l] = {
                name: l,
                index: n,
                type: c,
                size: a.size,
                isArray: h,
                value: Mm(c, a.size)
            }
        }
        return r
    }
    ef = function(t, e) {
        var r;
        const i = Rm(t, t.VERTEX_SHADER, e.vertexSrc),
            n = Rm(t, t.FRAGMENT_SHADER, e.fragmentSrc),
            a = t.createProgram();
        t.attachShader(a, i), t.attachShader(a, n);
        const l = (r = e.extra) == null ? void 0 : r.transformFeedbackVaryings;
        if (l && (typeof t.transformFeedbackVaryings != "function" || t.transformFeedbackVaryings(a, l.names, l.bufferMode === "separate" ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)), t.linkProgram(a), t.getProgramParameter(a, t.LINK_STATUS) || aT(t, a, i, n), e.attributeData = bT(a, t), e.uniformData = ET(a, t), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
            const c = Object.keys(e.attributeData);
            c.sort((d, f) => d > f ? 1 : -1);
            for (let d = 0; d < c.length; d++) e.attributeData[c[d]].location = d, t.bindAttribLocation(a, d, c[d]);
            t.linkProgram(a)
        }
        t.deleteShader(i), t.deleteShader(n);
        const h = {};
        for (const c in e.uniformData) {
            const d = e.uniformData[c];
            h[c] = {
                location: t.getUniformLocation(a, c),
                value: Mm(d.type, d.size)
            }
        }
        return new gp(a, h)
    };

    function TT(t, e, r, i, n) {
        r.buffer.update(n)
    }
    const wT = {
            float: `
        data[offset] = v;
    `,
            vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
            vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
            vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
            mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
            mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
            mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
        },
        $m = {
            float: 4,
            vec2: 8,
            vec3: 12,
            vec4: 16,
            int: 4,
            ivec2: 8,
            ivec3: 12,
            ivec4: 16,
            uint: 4,
            uvec2: 8,
            uvec3: 12,
            uvec4: 16,
            bool: 4,
            bvec2: 8,
            bvec3: 12,
            bvec4: 16,
            mat2: 16 * 2,
            mat3: 16 * 3,
            mat4: 16 * 4
        };
    qp = function(t) {
        const e = t.map(a => ({
            data: a,
            offset: 0,
            dataLen: 0,
            dirty: 0
        }));
        let r = 0,
            i = 0,
            n = 0;
        for (let a = 0; a < e.length; a++) {
            const l = e[a];
            if (r = $m[l.data.type], l.data.size > 1 && (r = Math.max(r, 16) * l.data.size), l.dataLen = r, i % r !== 0 && i < 16) {
                const h = i % r % 16;
                i += h, n += h
            }
            i + r > 16 ? (n = Math.ceil(n / 16) * 16, l.offset = n, n += r, i = r) : (l.offset = n, i += r, n += r)
        }
        return n = Math.ceil(n / 16) * 16, {
            uboElements: e,
            size: n
        }
    }, af = function(t, e) {
        const r = [];
        for (const i in t) e[i] && r.push(e[i]);
        return r.sort((i, n) => i.index - n.index), r
    }, rf = function(t, e) {
        if (!t.autoManage) return {
            size: 0,
            syncFunc: TT
        };
        const r = af(t.uniforms, e),
            {
                uboElements: i,
                size: n
            } = qp(r),
            a = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
        for (let l = 0; l < i.length; l++) {
            const h = i[l],
                c = t.uniforms[h.data.name],
                d = h.data.name;
            let f = !1;
            for (let g = 0; g < Hi.length; g++) {
                const y = Hi[g];
                if (y.codeUbo && y.test(h.data, c)) {
                    a.push(`offset = ${h.offset/4};`, Hi[g].codeUbo(h.data.name, c)), f = !0;
                    break
                }
            }
            if (!f)
                if (h.data.size > 1) {
                    const g = Bm(h.data.type),
                        y = Math.max($m[h.data.type] / 16, 1),
                        x = g / y,
                        _ = (4 - x % 4) % 4;
                    a.push(`
                cv = ud.${d}.value;
                v = uv.${d};
                offset = ${h.offset/4};

                t = 0;

                for(var i=0; i < ${h.data.size*y}; i++)
                {
                    for(var j = 0; j < ${x}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${_};
                }

                `)
                } else {
                    const g = wT[h.data.type];
                    a.push(`
                cv = ud.${d}.value;
                v = uv.${d};
                offset = ${h.offset/4};
                ${g};
                `)
                }
        }
        return a.push(`
       renderer.buffer.update(buffer);
    `), {
            size: n,
            syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", a.join(`
`))
        }
    };
    let ST = 0;
    const po = {
        textureCount: 0,
        uboCount: 0
    };
    gh = class {
        constructor(t) {
            this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ST++
        }
        systemCheck() {
            if (!jp()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
        }
        contextChange(t) {
            this.gl = t, this.reset()
        }
        bind(t, e) {
            t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
            const r = t.program,
                i = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
            return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(i.program)), e || (po.textureCount = 0, po.uboCount = 0, this.syncUniformGroup(t.uniformGroup, po)), i
        }
        setUniforms(t) {
            const e = this.shader.program,
                r = e.glPrograms[this.renderer.CONTEXT_UID];
            e.syncUniforms(r.uniformData, t, this.renderer)
        }
        syncUniformGroup(t, e) {
            const r = this.getGlProgram();
            (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e))
        }
        syncUniforms(t, e, r) {
            (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, r)
        }
        createSyncGroups(t) {
            const e = this.getSignature(t, this.shader.program.uniformData, "u");
            return this.cache[e] || (this.cache[e] = nT(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
        }
        syncUniformBufferGroup(t, e) {
            const r = this.getGlProgram();
            if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {
                t.dirtyId = 0;
                const i = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);
                t.buffer.update(), i(r.uniformData, t.uniforms, this.renderer, po, t.buffer)
            }
            this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e])
        }
        createSyncBufferGroup(t, e, r) {
            const {
                gl: i
            } = this.renderer;
            this.renderer.buffer.bind(t.buffer);
            const n = this.gl.getUniformBlockIndex(e.program, r);
            e.uniformBufferBindings[r] = this.shader.uniformBindCount, i.uniformBlockBinding(e.program, n, this.shader.uniformBindCount), this.shader.uniformBindCount++;
            const a = this.getSignature(t, this.shader.program.uniformData, "ubo");
            let l = this._uboCache[a];
            if (l || (l = this._uboCache[a] = rf(t, this.shader.program.uniformData)), t.autoManage) {
                const h = new Float32Array(l.size / 4);
                t.buffer.update(h)
            }
            return e.uniformGroups[t.id] = l.syncFunc, e.uniformGroups[t.id]
        }
        getSignature(t, e, r) {
            const i = t.uniforms,
                n = [`${r}-`];
            for (const a in i) n.push(a), e[a] && n.push(e[a].type);
            return n.join("-")
        }
        getGlProgram() {
            return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
        }
        generateProgram(t) {
            const e = this.gl,
                r = t.program,
                i = ef(e, r);
            return r.glPrograms[this.renderer.CONTEXT_UID] = i, i
        }
        reset() {
            this.program = null, this.shader = null
        }
        disposeShader(t) {
            this.shader === t && (this.shader = null)
        }
        destroy() {
            this.renderer = null, this.destroyed = !0
        }
    }, gh.extension = {
        type: Z.RendererSystem,
        name: "shader"
    }, lt.add(gh), eh = class {
        constructor(t) {
            this.renderer = t
        }
        run(t) {
            const e = this.renderer;
            e.emitWithCustomOptions(e.runners.init, t), t.hello, e.resize(this.renderer.screen.width, this.renderer.screen.height)
        }
        destroy() {}
    }, eh.extension = {
        type: [Z.RendererSystem, Z.CanvasRendererSystem],
        name: "startup"
    }, lt.add(eh);

    function AT(t, e = []) {
        return e[ut.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.ADD] = [t.ONE, t.ONE], e[ut.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.NONE] = [0, 0], e[ut.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[ut.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[ut.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[ut.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[ut.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[ut.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[ut.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[ut.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[ut.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[ut.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[ut.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
    }
    const PT = 0,
        CT = 1,
        IT = 2,
        RT = 3,
        MT = 4,
        DT = 5,
        Iu = class {
            constructor() {
                this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = ut.NONE, this._blendEq = !1, this.map = [], this.map[PT] = this.setBlend, this.map[CT] = this.setOffset, this.map[IT] = this.setCullFace, this.map[RT] = this.setDepthTest, this.map[MT] = this.setFrontFace, this.map[DT] = this.setDepthMask, this.checks = [], this.defaultState = new ei, this.defaultState.blend = !0
            }
            contextChange(t) {
                this.gl = t, this.blendModes = AT(t), this.set(this.defaultState), this.reset()
            }
            set(t) {
                if (t = t || this.defaultState, this.stateId !== t.data) {
                    let e = this.stateId ^ t.data,
                        r = 0;
                    for (; e;) e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;
                    this.stateId = t.data
                }
                for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t)
            }
            forceState(t) {
                t = t || this.defaultState;
                for (let e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
                for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t);
                this.stateId = t.data
            }
            setBlend(t) {
                this.updateCheck(Iu.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND)
            }
            setOffset(t) {
                this.updateCheck(Iu.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
            }
            setDepthTest(t) {
                this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
            }
            setDepthMask(t) {
                this.gl.depthMask(t)
            }
            setCullFace(t) {
                this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
            }
            setFrontFace(t) {
                this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
            }
            setBlendMode(t) {
                if (t === this.blendMode) return;
                this.blendMode = t;
                const e = this.blendModes[t],
                    r = this.gl;
                e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
            }
            setPolygonOffset(t, e) {
                this.gl.polygonOffset(t, e)
            }
            reset() {
                this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
            }
            updateCheck(t, e) {
                const r = this.checks.indexOf(t);
                e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1)
            }
            static checkBlendMode(t, e) {
                t.setBlendMode(e.blendMode)
            }
            static checkPolygonOffset(t, e) {
                t.setPolygonOffset(1, e.polygonOffset)
            }
            destroy() {
                this.gl = null
            }
        };
    rh = Iu, rh.extension = {
        type: Z.RendererSystem,
        name: "state"
    }, lt.add(rh), _p = class extends An {
        constructor() {
            super(...arguments), this.runners = {}, this._systemsHash = {}
        }
        setup(t) {
            var i;
            this.addRunners(...t.runners);
            const e = ((i = t.priority) != null ? i : []).filter(n => t.systems[n]),
                r = [...e, ...Object.keys(t.systems).filter(n => !e.includes(n))];
            for (const n of r) this.addSystem(t.systems[n], n)
        }
        addRunners(...t) {
            t.forEach(e => {
                this.runners[e] = new ze(e)
            })
        }
        addSystem(t, e) {
            const r = new t(this);
            if (this[e]) throw new Error(`Whoops! The name "${e}" is already in use`);
            this[e] = r, this._systemsHash[e] = r;
            for (const i in this.runners) this.runners[i].add(r);
            return this
        }
        emitWithCustomOptions(t, e) {
            const r = Object.keys(this._systemsHash);
            t.items.forEach(i => {
                const n = r.find(a => this._systemsHash[a] === i);
                i[t.name](e[n])
            })
        }
        destroy() {
            Object.values(this.runners).forEach(t => {
                t.destroy()
            }), this._systemsHash = {}
        }
    };
    const fo = class {
        constructor(t) {
            this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = fo.defaultMaxIdle, this.checkCountMax = fo.defaultCheckCountMax, this.mode = fo.defaultMode
        }
        postrender() {
            this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== ba.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
        }
        run() {
            const t = this.renderer.texture,
                e = t.managedTextures;
            let r = !1;
            for (let i = 0; i < e.length; i++) {
                const n = e[i];
                !n.framebuffer && this.count - n.touched > this.maxIdle && (t.destroyTexture(n, !0), e[i] = null, r = !0)
            }
            if (r) {
                let i = 0;
                for (let n = 0; n < e.length; n++) e[n] !== null && (e[i++] = e[n]);
                e.length = i
            }
        }
        unload(t) {
            const e = this.renderer.texture,
                r = t._texture;
            r && !r.framebuffer && e.destroyTexture(r);
            for (let i = t.children.length - 1; i >= 0; i--) this.unload(t.children[i])
        }
        destroy() {
            this.renderer = null
        }
    };
    Ze = fo, Ze.defaultMode = ba.AUTO, Ze.defaultMaxIdle = 60 * 60, Ze.defaultCheckCountMax = 60 * 10, Ze.extension = {
        type: Z.RendererSystem,
        name: "textureGC"
    }, lt.add(Ze), Ea = class {
        constructor(t) {
            this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = dt.UNSIGNED_BYTE, this.internalFormat = V.RGBA, this.samplerType = 0
        }
    };

    function NT(t) {
        let e;
        return "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext ? e = {
            [dt.UNSIGNED_BYTE]: {
                [V.RGBA]: t.RGBA8,
                [V.RGB]: t.RGB8,
                [V.RG]: t.RG8,
                [V.RED]: t.R8,
                [V.RGBA_INTEGER]: t.RGBA8UI,
                [V.RGB_INTEGER]: t.RGB8UI,
                [V.RG_INTEGER]: t.RG8UI,
                [V.RED_INTEGER]: t.R8UI,
                [V.ALPHA]: t.ALPHA,
                [V.LUMINANCE]: t.LUMINANCE,
                [V.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
            },
            [dt.BYTE]: {
                [V.RGBA]: t.RGBA8_SNORM,
                [V.RGB]: t.RGB8_SNORM,
                [V.RG]: t.RG8_SNORM,
                [V.RED]: t.R8_SNORM,
                [V.RGBA_INTEGER]: t.RGBA8I,
                [V.RGB_INTEGER]: t.RGB8I,
                [V.RG_INTEGER]: t.RG8I,
                [V.RED_INTEGER]: t.R8I
            },
            [dt.UNSIGNED_SHORT]: {
                [V.RGBA_INTEGER]: t.RGBA16UI,
                [V.RGB_INTEGER]: t.RGB16UI,
                [V.RG_INTEGER]: t.RG16UI,
                [V.RED_INTEGER]: t.R16UI,
                [V.DEPTH_COMPONENT]: t.DEPTH_COMPONENT16
            },
            [dt.SHORT]: {
                [V.RGBA_INTEGER]: t.RGBA16I,
                [V.RGB_INTEGER]: t.RGB16I,
                [V.RG_INTEGER]: t.RG16I,
                [V.RED_INTEGER]: t.R16I
            },
            [dt.UNSIGNED_INT]: {
                [V.RGBA_INTEGER]: t.RGBA32UI,
                [V.RGB_INTEGER]: t.RGB32UI,
                [V.RG_INTEGER]: t.RG32UI,
                [V.RED_INTEGER]: t.R32UI,
                [V.DEPTH_COMPONENT]: t.DEPTH_COMPONENT24
            },
            [dt.INT]: {
                [V.RGBA_INTEGER]: t.RGBA32I,
                [V.RGB_INTEGER]: t.RGB32I,
                [V.RG_INTEGER]: t.RG32I,
                [V.RED_INTEGER]: t.R32I
            },
            [dt.FLOAT]: {
                [V.RGBA]: t.RGBA32F,
                [V.RGB]: t.RGB32F,
                [V.RG]: t.RG32F,
                [V.RED]: t.R32F,
                [V.DEPTH_COMPONENT]: t.DEPTH_COMPONENT32F
            },
            [dt.HALF_FLOAT]: {
                [V.RGBA]: t.RGBA16F,
                [V.RGB]: t.RGB16F,
                [V.RG]: t.RG16F,
                [V.RED]: t.R16F
            },
            [dt.UNSIGNED_SHORT_5_6_5]: {
                [V.RGB]: t.RGB565
            },
            [dt.UNSIGNED_SHORT_4_4_4_4]: {
                [V.RGBA]: t.RGBA4
            },
            [dt.UNSIGNED_SHORT_5_5_5_1]: {
                [V.RGBA]: t.RGB5_A1
            },
            [dt.UNSIGNED_INT_2_10_10_10_REV]: {
                [V.RGBA]: t.RGB10_A2,
                [V.RGBA_INTEGER]: t.RGB10_A2UI
            },
            [dt.UNSIGNED_INT_10F_11F_11F_REV]: {
                [V.RGB]: t.R11F_G11F_B10F
            },
            [dt.UNSIGNED_INT_5_9_9_9_REV]: {
                [V.RGB]: t.RGB9_E5
            },
            [dt.UNSIGNED_INT_24_8]: {
                [V.DEPTH_STENCIL]: t.DEPTH24_STENCIL8
            },
            [dt.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
                [V.DEPTH_STENCIL]: t.DEPTH32F_STENCIL8
            }
        } : e = {
            [dt.UNSIGNED_BYTE]: {
                [V.RGBA]: t.RGBA,
                [V.RGB]: t.RGB,
                [V.ALPHA]: t.ALPHA,
                [V.LUMINANCE]: t.LUMINANCE,
                [V.LUMINANCE_ALPHA]: t.LUMINANCE_ALPHA
            },
            [dt.UNSIGNED_SHORT_5_6_5]: {
                [V.RGB]: t.RGB
            },
            [dt.UNSIGNED_SHORT_4_4_4_4]: {
                [V.RGBA]: t.RGBA
            },
            [dt.UNSIGNED_SHORT_5_5_5_1]: {
                [V.RGBA]: t.RGBA
            }
        }, e
    }
    sh = class {
        constructor(t) {
            this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new mt, this.hasIntegerTextures = !1
        }
        contextChange() {
            const t = this.gl = this.renderer.gl;
            this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = NT(t);
            const e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
            this.boundTextures.length = e;
            for (let i = 0; i < e; i++) this.boundTextures[i] = null;
            this.emptyTextures = {};
            const r = new Ea(t.createTexture());
            t.bindTexture(t.TEXTURE_2D, r.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = r, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Ea(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
            for (let i = 0; i < 6; i++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
            t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
            for (let i = 0; i < this.boundTextures.length; i++) this.bind(null, i)
        }
        bind(t, e = 0) {
            const {
                gl: r
            } = this;
            if (t = t == null ? void 0 : t.castToBaseTexture(), t != null && t.valid && !t.parentTextureArray) {
                t.touched = this.renderer.textureGC.count;
                const i = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
                this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, i.texture)), i.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : i.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t
            } else this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null
        }
        reset() {
            this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
            for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
        }
        unbind(t) {
            const {
                gl: e,
                boundTextures: r
            } = this;
            if (this._unknownBoundTextures) {
                this._unknownBoundTextures = !1;
                for (let i = 0; i < r.length; i++) r[i] === this.unknownTexture && this.bind(null, i)
            }
            for (let i = 0; i < r.length; i++) r[i] === t && (this.currentLocation !== i && (e.activeTexture(e.TEXTURE0 + i), this.currentLocation = i), e.bindTexture(t.target, this.emptyTextures[t.target].texture), r[i] = null)
        }
        ensureSamplerType(t) {
            const {
                boundTextures: e,
                hasIntegerTextures: r,
                CONTEXT_UID: i
            } = this;
            if (r)
                for (let n = t - 1; n >= 0; --n) {
                    const a = e[n];
                    a && a._glTextures[i].samplerType !== Aa.FLOAT && this.renderer.texture.unbind(a)
                }
        }
        initTexture(t) {
            const e = new Ea(this.gl.createTexture());
            return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e
        }
        initTextureType(t, e) {
            var i;
            var r;
            e.internalFormat = (i = (r = this.internalFormats[t.type]) == null ? void 0 : r[t.format]) != null ? i : t.format, this.webGLVersion === 2 && t.type === dt.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type
        }
        updateTexture(t) {
            var e;
            const r = t._glTextures[this.CONTEXT_UID];
            if (!r) return;
            const i = this.renderer;
            if (this.initTextureType(t, r), (e = t.resource) != null && e.upload(i, t, r)) r.samplerType !== Aa.FLOAT && (this.hasIntegerTextures = !0);
            else {
                const n = t.realWidth,
                    a = t.realHeight,
                    l = i.gl;
                (r.width !== n || r.height !== a || r.dirtyId < 0) && (r.width = n, r.height = a, l.texImage2D(t.target, 0, r.internalFormat, n, a, 0, t.format, r.type, null))
            }
            t.dirtyStyleId !== r.dirtyStyleId && this.updateTextureStyle(t), r.dirtyId = t.dirtyId
        }
        destroyTexture(t, e) {
            const {
                gl: r
            } = this;
            if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
                const i = this.managedTextures.indexOf(t);
                i !== -1 && Yi(this.managedTextures, i, 1)
            }
        }
        updateTextureStyle(t) {
            var e;
            const r = t._glTextures[this.CONTEXT_UID];
            r && ((t.mipmap === fr.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? r.mipmap = !1 : r.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? r.wrapMode = Nr.CLAMP : r.wrapMode = t.wrapMode, (e = t.resource) != null && e.style(this.renderer, t, r) || this.setStyle(t, r), r.dirtyStyleId = t.dirtyStyleId)
        }
        setStyle(t, e) {
            const r = this.gl;
            if (e.mipmap && t.mipmap !== fr.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
                r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Rr.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
                const i = this.renderer.context.extensions.anisotropicFiltering;
                if (i && t.anisotropicLevel > 0 && t.scaleMode === Rr.LINEAR) {
                    const n = Math.min(t.anisotropicLevel, r.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                    r.texParameterf(t.target, i.TEXTURE_MAX_ANISOTROPY_EXT, n)
                }
            } else r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Rr.LINEAR ? r.LINEAR : r.NEAREST);
            r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === Rr.LINEAR ? r.LINEAR : r.NEAREST)
        }
        destroy() {
            this.renderer = null
        }
    }, sh.extension = {
        type: Z.RendererSystem,
        name: "texture"
    }, lt.add(sh), Ql = class {
        constructor(t) {
            this.renderer = t
        }
        contextChange() {
            this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
        }
        bind(t) {
            const {
                gl: e,
                CONTEXT_UID: r
            } = this, i = t._glTransformFeedbacks[r] || this.createGLTransformFeedback(t);
            e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, i)
        }
        unbind() {
            const {
                gl: t
            } = this;
            t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
        }
        beginTransformFeedback(t, e) {
            const {
                gl: r,
                renderer: i
            } = this;
            e && i.shader.bind(e), r.beginTransformFeedback(t)
        }
        endTransformFeedback() {
            const {
                gl: t
            } = this;
            t.endTransformFeedback()
        }
        createGLTransformFeedback(t) {
            const {
                gl: e,
                renderer: r,
                CONTEXT_UID: i
            } = this, n = e.createTransformFeedback();
            t._glTransformFeedbacks[i] = n, e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, n);
            for (let a = 0; a < t.buffers.length; a++) {
                const l = t.buffers[a];
                l && (r.buffer.update(l), l._glBuffers[i].refCount++, e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, a, l._glBuffers[i].buffer || null))
            }
            return e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null), t.disposeRunner.add(this), n
        }
        disposeTransformFeedback(t, e) {
            const r = t._glTransformFeedbacks[this.CONTEXT_UID],
                i = this.gl;
            t.disposeRunner.remove(this);
            const n = this.renderer.buffer;
            if (n)
                for (let a = 0; a < t.buffers.length; a++) {
                    const l = t.buffers[a];
                    if (!l) continue;
                    const h = l._glBuffers[this.CONTEXT_UID];
                    h && (h.refCount--, h.refCount === 0 && !e && n.dispose(l, e))
                }
            r && (e || i.deleteTransformFeedback(r), delete t._glTransformFeedbacks[this.CONTEXT_UID])
        }
        destroy() {
            this.renderer = null
        }
    }, Ql.extension = {
        type: Z.RendererSystem,
        name: "transformFeedback"
    }, lt.add(Ql), yh = class {
        constructor(t) {
            this.renderer = t
        }
        init(t) {
            this.screen = new bt(0, 0, t.width, t.height), this.element = t.view || et.ADAPTER.createCanvas(), this.resolution = t.resolution || et.RESOLUTION, this.autoDensity = !!t.autoDensity
        }
        resizeView(t, e) {
            this.element.width = Math.round(t * this.resolution), this.element.height = Math.round(e * this.resolution);
            const r = this.element.width / this.resolution,
                i = this.element.height / this.resolution;
            this.screen.width = r, this.screen.height = i, this.autoDensity && (this.element.style.width = `${r}px`, this.element.style.height = `${i}px`), this.renderer.emit("resize", r, i), this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
        }
        destroy(t) {
            var e;
            t && ((e = this.element.parentNode) == null || e.removeChild(this.element)), this.renderer = null, this.element = null, this.screen = null
        }
    }, yh.extension = {
        type: [Z.RendererSystem, Z.CanvasRendererSystem],
        name: "_view"
    }, lt.add(yh), et.PREFER_ENV = pi.WEBGL2, et.STRICT_TEXTURE_CACHE = !1, Object.defineProperties(et, {
        WRAP_MODE: {
            get() {
                return mt.defaultOptions.wrapMode
            },
            set(t) {
                Tt("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), mt.defaultOptions.wrapMode = t
            }
        },
        SCALE_MODE: {
            get() {
                return mt.defaultOptions.scaleMode
            },
            set(t) {
                Tt("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), mt.defaultOptions.scaleMode = t
            }
        },
        MIPMAP_TEXTURES: {
            get() {
                return mt.defaultOptions.mipmap
            },
            set(t) {
                Tt("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), mt.defaultOptions.mipmap = t
            }
        },
        ANISOTROPIC_LEVEL: {
            get() {
                return mt.defaultOptions.anisotropicLevel
            },
            set(t) {
                Tt("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"), mt.defaultOptions.anisotropicLevel = t
            }
        },
        FILTER_RESOLUTION: {
            get() {
                return Tt("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), ae.defaultResolution
            },
            set(t) {
                ae.defaultResolution = t
            }
        },
        FILTER_MULTISAMPLE: {
            get() {
                return Tt("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), ae.defaultMultisample
            },
            set(t) {
                ae.defaultMultisample = t
            }
        },
        SPRITE_MAX_TEXTURES: {
            get() {
                return Je.defaultMaxTextures
            },
            set(t) {
                Tt("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), Je.defaultMaxTextures = t
            }
        },
        SPRITE_BATCH_SIZE: {
            get() {
                return Je.defaultBatchSize
            },
            set(t) {
                Tt("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), Je.defaultBatchSize = t
            }
        },
        CAN_UPLOAD_SAME_BUFFER: {
            get() {
                return Je.canUploadSameBuffer
            },
            set(t) {
                Tt("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), Je.canUploadSameBuffer = t
            }
        },
        GC_MODE: {
            get() {
                return Ze.defaultMode
            },
            set(t) {
                Tt("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), Ze.defaultMode = t
            }
        },
        GC_MAX_IDLE: {
            get() {
                return Ze.defaultMaxIdle
            },
            set(t) {
                Tt("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), Ze.defaultMaxIdle = t
            }
        },
        GC_MAX_CHECK_COUNT: {
            get() {
                return Ze.defaultCheckCountMax
            },
            set(t) {
                Tt("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), Ze.defaultCheckCountMax = t
            }
        },
        PRECISION_VERTEX: {
            get() {
                return Ke.defaultVertexPrecision
            },
            set(t) {
                Tt("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Ke.defaultVertexPrecision = t
            }
        },
        PRECISION_FRAGMENT: {
            get() {
                return Ke.defaultFragmentPrecision
            },
            set(t) {
                Tt("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Ke.defaultFragmentPrecision = t
            }
        }
    }), vi = (t => (t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(vi || {});
    class Ru {
        constructor(e, r = null, i = 0, n = !1) {
            this.next = null, this.previous = null, this._destroyed = !1, this.fn = e, this.context = r, this.priority = i, this.once = n
        }
        match(e, r = null) {
            return this.fn === e && this.context === r
        }
        emit(e) {
            this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
            const r = this.next;
            return this.once && this.destroy(!0), this._destroyed && (this.next = null), r
        }
        connect(e) {
            this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this
        }
        destroy(e = !1) {
            this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
            const r = this.next;
            return this.next = e ? null : r, this.previous = null, r
        }
    }
    const He = class {
        constructor() {
            this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Ru(null, null, 1 / 0), this.deltaMS = 1 / He.targetFPMS, this.elapsedMS = 1 / He.targetFPMS, this._tick = t => {
                this._requestId = null, this.started && (this.update(t), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
            }
        }
        _requestIfNeeded() {
            this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
        }
        _cancelIfNeeded() {
            this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
        }
        _startIfPossible() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start()
        }
        add(t, e, r = vi.NORMAL) {
            return this._addListener(new Ru(t, e, r))
        }
        addOnce(t, e, r = vi.NORMAL) {
            return this._addListener(new Ru(t, e, r, !0))
        }
        _addListener(t) {
            let e = this._head.next,
                r = this._head;
            if (!e) t.connect(r);
            else {
                for (; e;) {
                    if (t.priority > e.priority) {
                        t.connect(r);
                        break
                    }
                    r = e, e = e.next
                }
                t.previous || t.connect(r)
            }
            return this._startIfPossible(), this
        }
        remove(t, e) {
            let r = this._head.next;
            for (; r;) r.match(t, e) ? r = r.destroy() : r = r.next;
            return this._head.next || this._cancelIfNeeded(), this
        }
        get count() {
            if (!this._head) return 0;
            let t = 0,
                e = this._head;
            for (; e = e.next;) t++;
            return t
        }
        start() {
            this.started || (this.started = !0, this._requestIfNeeded())
        }
        stop() {
            this.started && (this.started = !1, this._cancelIfNeeded())
        }
        destroy() {
            if (!this._protected) {
                this.stop();
                let t = this._head.next;
                for (; t;) t = t.destroy(!0);
                this._head.destroy(), this._head = null
            }
        }
        update(t = performance.now()) {
            let e;
            if (t > this.lastTime) {
                if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                    const n = t - this._lastFrame | 0;
                    if (n < this._minElapsedMS) return;
                    this._lastFrame = t - n % this._minElapsedMS
                }
                this.deltaMS = e, this.deltaTime = this.deltaMS * He.targetFPMS;
                const r = this._head;
                let i = r.next;
                for (; i;) i = i.emit(this.deltaTime);
                r.next || this._cancelIfNeeded()
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = t
        }
        get FPS() {
            return 1e3 / this.elapsedMS
        }
        get minFPS() {
            return 1e3 / this._maxElapsedMS
        }
        set minFPS(t) {
            const e = Math.min(this.maxFPS, t),
                r = Math.min(Math.max(0, e) / 1e3, He.targetFPMS);
            this._maxElapsedMS = 1 / r
        }
        get maxFPS() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
        }
        set maxFPS(t) {
            if (t === 0) this._minElapsedMS = 0;
            else {
                const e = Math.max(this.minFPS, t);
                this._minElapsedMS = 1 / (e / 1e3)
            }
        }
        static get shared() {
            if (!He._shared) {
                const t = He._shared = new He;
                t.autoStart = !0, t._protected = !0
            }
            return He._shared
        }
        static get system() {
            if (!He._system) {
                const t = He._system = new He;
                t.autoStart = !0, t._protected = !0
            }
            return He._system
        }
    };
    Vt = He, Vt.targetFPMS = .06, Object.defineProperties(et, {
        TARGET_FPMS: {
            get() {
                return Vt.targetFPMS
            },
            set(t) {
                Tt("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), Vt.targetFPMS = t
            }
        }
    }), oh = class {
        static init(t) {
            t = Object.assign({
                autoStart: !0,
                sharedTicker: !1
            }, t), Object.defineProperty(this, "ticker", {
                set(e) {
                    this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, vi.LOW)
                },
                get() {
                    return this._ticker
                }
            }), this.stop = () => {
                this._ticker.stop()
            }, this.start = () => {
                this._ticker.start()
            }, this._ticker = null, this.ticker = t.sharedTicker ? Vt.shared : new Vt, t.autoStart && this.start()
        }
        static destroy() {
            if (this._ticker) {
                const t = this._ticker;
                this.ticker = null, t.destroy()
            }
        }
    }, oh.extension = Z.Application, lt.add(oh);
    const Vm = [];
    lt.handleByList(Z.Renderer, Vm), vh = function(t) {
        for (const e of Vm)
            if (e.test(t)) return new e(t);
        throw new Error("Unable to auto-detect a suitable renderer.")
    };
    var OT = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
        LT = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
    Qp = OT, bh = LT, Gl = class {
        constructor(t) {
            this.renderer = t
        }
        contextChange(t) {
            let e;
            if (this.renderer.context.webGLVersion === 1) {
                const r = t.getParameter(t.FRAMEBUFFER_BINDING);
                t.bindFramebuffer(t.FRAMEBUFFER, null), e = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, r)
            } else {
                const r = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
                t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), e = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, r)
            }
            e >= Wt.HIGH ? this.multisample = Wt.HIGH : e >= Wt.MEDIUM ? this.multisample = Wt.MEDIUM : e >= Wt.LOW ? this.multisample = Wt.LOW : this.multisample = Wt.NONE
        }
        destroy() {}
    }, Gl.extension = {
        type: Z.RendererSystem,
        name: "_multisample"
    }, lt.add(Gl);
    class BT {
        constructor(e) {
            this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
        }
    }
    Ph = class {
        constructor(t) {
            this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
        }
        destroy() {
            this.renderer = null
        }
        contextChange() {
            this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
        }
        bind(t) {
            const {
                gl: e,
                CONTEXT_UID: r
            } = this, i = t._glBuffers[r] || this.createGLBuffer(t);
            e.bindBuffer(t.type, i.buffer)
        }
        unbind(t) {
            const {
                gl: e
            } = this;
            e.bindBuffer(t, null)
        }
        bindBufferBase(t, e) {
            const {
                gl: r,
                CONTEXT_UID: i
            } = this;
            if (this.boundBufferBases[e] !== t) {
                const n = t._glBuffers[i] || this.createGLBuffer(t);
                this.boundBufferBases[e] = t, r.bindBufferBase(r.UNIFORM_BUFFER, e, n.buffer)
            }
        }
        bindBufferRange(t, e, r) {
            const {
                gl: i,
                CONTEXT_UID: n
            } = this;
            r = r || 0;
            const a = t._glBuffers[n] || this.createGLBuffer(t);
            i.bindBufferRange(i.UNIFORM_BUFFER, e || 0, a.buffer, r * 256, 256)
        }
        update(t) {
            const {
                gl: e,
                CONTEXT_UID: r
            } = this, i = t._glBuffers[r] || this.createGLBuffer(t);
            if (t._updateID !== i.updateID)
                if (i.updateID = t._updateID, e.bindBuffer(t.type, i.buffer), i.byteLength >= t.data.byteLength) e.bufferSubData(t.type, 0, t.data);
                else {
                    const n = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                    i.byteLength = t.data.byteLength, e.bufferData(t.type, t.data, n)
                }
        }
        dispose(t, e) {
            if (!this.managedBuffers[t.id]) return;
            delete this.managedBuffers[t.id];
            const r = t._glBuffers[this.CONTEXT_UID],
                i = this.gl;
            t.disposeRunner.remove(this), r && (e || i.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID])
        }
        disposeAll(t) {
            const e = Object.keys(this.managedBuffers);
            for (let r = 0; r < e.length; r++) this.dispose(this.managedBuffers[e[r]], t)
        }
        createGLBuffer(t) {
            const {
                CONTEXT_UID: e,
                gl: r
            } = this;
            return t._glBuffers[e] = new BT(r.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[e]
        }
    }, Ph.extension = {
        type: Z.RendererSystem,
        name: "buffer"
    }, lt.add(Ph), zl = class {
        constructor(t) {
            this.renderer = t
        }
        render(t, e) {
            const r = this.renderer;
            let i, n, a, l;
            if (e && (i = e.renderTexture, n = e.clear, a = e.transform, l = e.skipUpdateTransform), this.renderingToScreen = !i, r.runners.prerender.emit(), r.emit("prerender"), r.projection.transform = a, !r.context.isLost) {
                if (i || (this.lastObjectRendered = t), !l) {
                    const h = t.enableTempParent();
                    t.updateTransform(), t.disableTempParent(h)
                }
                r.renderTexture.bind(i), r.batch.currentRenderer.start(), (n != null ? n : r.background.clearBeforeRender) && r.renderTexture.clear(), t.render(r), r.batch.currentRenderer.flush(), i && (e.blit && r.framebuffer.blit(), i.baseTexture.update()), r.runners.postrender.emit(), r.projection.transform = null, r.emit("postrender")
            }
        }
        destroy() {
            this.renderer = null, this.lastObjectRendered = null
        }
    }, zl.extension = {
        type: Z.RendererSystem,
        name: "objectRenderer"
    }, lt.add(zl);
    const Mu = class extends _p {
        constructor(t) {
            var i;
            super(), this.type = uh.WEBGL, t = Object.assign({}, et.RENDER_OPTIONS, t), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new mr({
                projectionMatrix: new Ut
            }, !0);
            const e = {
                runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
                systems: Mu.__systems,
                priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
            };
            this.setup(e), "useContextAlpha" in t && (Tt("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), t.premultipliedAlpha = t.useContextAlpha && t.useContextAlpha !== "notMultiplied", t.backgroundAlpha = t.useContextAlpha === !1 ? 1 : t.backgroundAlpha);
            const r = {
                hello: t.hello,
                _plugin: Mu.__plugins,
                background: {
                    alpha: t.backgroundAlpha,
                    color: (i = t.background) != null ? i : t.backgroundColor,
                    clearBeforeRender: t.clearBeforeRender
                },
                _view: {
                    height: t.height,
                    width: t.width,
                    autoDensity: t.autoDensity,
                    resolution: t.resolution,
                    view: t.view
                },
                context: {
                    antialias: t.antialias,
                    context: t.context,
                    powerPreference: t.powerPreference,
                    premultipliedAlpha: t.premultipliedAlpha,
                    preserveDrawingBuffer: t.preserveDrawingBuffer
                }
            };
            this.options = t, this.startup.run(r)
        }
        static test(t) {
            return t != null && t.forceCanvas ? !1 : ym()
        }
        render(t, e) {
            this.objectRenderer.render(t, e)
        }
        resize(t, e) {
            this._view.resizeView(t, e)
        }
        reset() {
            return this.runners.reset.emit(), this
        }
        clear() {
            this.renderTexture.bind(), this.renderTexture.clear()
        }
        destroy(t = !1) {
            this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
                _view: t
            }), super.destroy()
        }
        get plugins() {
            return this._plugin.plugins
        }
        get multisample() {
            return this._multisample.multisample
        }
        get width() {
            return this._view.element.width
        }
        get height() {
            return this._view.element.height
        }
        get resolution() {
            return this._view.resolution
        }
        set resolution(t) {
            this._view.resolution = t, this.runners.resolutionChange.emit(t)
        }
        get autoDensity() {
            return this._view.autoDensity
        }
        get view() {
            return this._view.element
        }
        get screen() {
            return this._view.screen
        }
        get lastObjectRendered() {
            return this.objectRenderer.lastObjectRendered
        }
        get renderingToScreen() {
            return this.objectRenderer.renderingToScreen
        }
        get rendererLogId() {
            return `WebGL ${this.context.webGLVersion}`
        }
        get clearBeforeRender() {
            return Tt("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender
        }
        get useContextAlpha() {
            return Tt("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha
        }
        get preserveDrawingBuffer() {
            return Tt("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer
        }
        get backgroundColor() {
            return Tt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
        }
        set backgroundColor(t) {
            Tt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = t
        }
        get backgroundAlpha() {
            return Tt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.color
        }
        set backgroundAlpha(t) {
            Tt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = t
        }
        get powerPreference() {
            return Tt("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference
        }
        generateTexture(t, e) {
            return this.textureGenerator.generateTexture(t, e)
        }
    };
    zi = Mu, zi.extension = {
        type: Z.Renderer,
        priority: 1
    }, zi.__plugins = {}, zi.__systems = {}, lt.handleByMap(Z.RendererPlugin, zi.__plugins), lt.handleByMap(Z.RendererSystem, zi.__systems), lt.add(zi), Nl = class extends bn {
        constructor(t, e) {
            const {
                width: r,
                height: i
            } = e || {};
            super(r, i), this.items = [], this.itemDirtyIds = [];
            for (let n = 0; n < t; n++) {
                const a = new mt;
                this.items.push(a), this.itemDirtyIds.push(-2)
            }
            this.length = t, this._load = null, this.baseTexture = null
        }
        initFromArray(t, e) {
            for (let r = 0; r < this.length; r++) t[r] && (t[r].castToBaseTexture ? this.addBaseTextureAt(t[r].castToBaseTexture(), r) : t[r] instanceof bn ? this.addResourceAt(t[r], r) : this.addResourceAt(xh(t[r], e), r))
        }
        dispose() {
            for (let t = 0, e = this.length; t < e; t++) this.items[t].destroy();
            this.items = null, this.itemDirtyIds = null, this._load = null
        }
        addResourceAt(t, e) {
            if (!this.items[e]) throw new Error(`Index ${e} is out of bounds`);
            return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
        }
        bind(t) {
            if (this.baseTexture !== null) throw new Error("Only one base texture per TextureArray is allowed");
            super.bind(t);
            for (let e = 0; e < this.length; e++) this.items[e].parentTextureArray = t, this.items[e].on("update", t.update, t)
        }
        unbind(t) {
            super.unbind(t);
            for (let e = 0; e < this.length; e++) this.items[e].parentTextureArray = null, this.items[e].off("update", t.update, t)
        }
        load() {
            if (this._load) return this._load;
            const t = this.items.map(e => e.resource).filter(e => e).map(e => e.load());
            return this._load = Promise.all(t).then(() => {
                const {
                    realWidth: e,
                    realHeight: r
                } = this.items[0];
                return this.resize(e, r), Promise.resolve(this)
            }), this._load
        }
    }, ip = class extends Nl {
        constructor(t, e) {
            const {
                width: r,
                height: i
            } = e || {};
            let n, a;
            Array.isArray(t) ? (n = t, a = t.length) : a = t, super(a, {
                width: r,
                height: i
            }), n && this.initFromArray(n, e)
        }
        addBaseTextureAt(t, e) {
            if (t.resource) this.addResourceAt(t.resource, e);
            else throw new Error("ArrayResource does not support RenderTexture");
            return this
        }
        bind(t) {
            super.bind(t), t.target = Gi.TEXTURE_2D_ARRAY
        }
        upload(t, e, r) {
            const {
                length: i,
                itemDirtyIds: n,
                items: a
            } = this, {
                gl: l
            } = t;
            r.dirtyId < 0 && l.texImage3D(l.TEXTURE_2D_ARRAY, 0, r.internalFormat, this._width, this._height, i, 0, e.format, r.type, null);
            for (let h = 0; h < i; h++) {
                const c = a[h];
                n[h] < c.dirtyId && (n[h] = c.dirtyId, c.valid && l.texSubImage3D(l.TEXTURE_2D_ARRAY, 0, 0, 0, h, c.resource.width, c.resource.height, 1, e.format, r.type, c.resource.source))
            }
            return !0
        }
    }, pf = class extends Zr {
        constructor(t) {
            super(t)
        }
        static test(t) {
            const {
                OffscreenCanvas: e
            } = globalThis;
            return e && t instanceof e ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
        }
    };
    const ks = class extends Nl {
        constructor(t, e) {
            const {
                width: r,
                height: i,
                autoLoad: n,
                linkBaseTexture: a
            } = e || {};
            if (t && t.length !== ks.SIDES) throw new Error(`Invalid length. Got ${t.length}, expected 6`);
            super(6, {
                width: r,
                height: i
            });
            for (let l = 0; l < ks.SIDES; l++) this.items[l].target = Gi.TEXTURE_CUBE_MAP_POSITIVE_X + l;
            this.linkBaseTexture = a !== !1, t && this.initFromArray(t, e), n !== !1 && this.load()
        }
        bind(t) {
            super.bind(t), t.target = Gi.TEXTURE_CUBE_MAP
        }
        addBaseTextureAt(t, e, r) {
            if (r === void 0 && (r = this.linkBaseTexture), !this.items[e]) throw new Error(`Index ${e} is out of bounds`);
            if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0)
                if (t.resource) this.addResourceAt(t.resource, e);
                else throw new Error("CubeResource does not support copying of renderTexture.");
            else t.target = Gi.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t;
            return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
        }
        upload(t, e, r) {
            const i = this.itemDirtyIds;
            for (let n = 0; n < ks.SIDES; n++) {
                const a = this.items[n];
                (i[n] < a.dirtyId || r.dirtyId < e.dirtyId) && (a.valid && a.resource ? (a.resource.upload(t, a, r), i[n] = a.dirtyId) : i[n] < -1 && (t.gl.texImage2D(a.target, 0, r.internalFormat, e.realWidth, e.realHeight, 0, e.format, r.type, null), i[n] = -1))
            }
            return !0
        }
        static test(t) {
            return Array.isArray(t) && t.length === ks.SIDES
        }
    };
    Dl = ks, Dl.SIDES = 6, xn = class extends Zr {
        constructor(t, e) {
            var n;
            e = e || {};
            let r, i;
            typeof t == "string" ? (r = xn.EMPTY, i = t) : (r = t, i = null), super(r), this.url = i, this.crossOrigin = (n = e.crossOrigin) != null ? n : !0, this.alphaMode = typeof e.alphaMode == "number" ? e.alphaMode : null, this._load = null, e.autoLoad !== !1 && this.load()
        }
        load() {
            return this._load ? this._load : (this._load = new Promise(async (t, e) => {
                if (this.url === null) {
                    t(this);
                    return
                }
                try {
                    const r = await et.ADAPTER.fetch(this.url, {
                        mode: this.crossOrigin ? "cors" : "no-cors"
                    });
                    if (this.destroyed) return;
                    const i = await r.blob();
                    if (this.destroyed) return;
                    const n = await createImageBitmap(i, {
                        premultiplyAlpha: this.alphaMode === null || this.alphaMode === tr.UNPACK ? "premultiply" : "none"
                    });
                    if (this.destroyed) return;
                    this.source = n, this.update(), t(this)
                } catch (r) {
                    if (this.destroyed) return;
                    e(r), this.onError.emit(r)
                }
            }), this._load)
        }
        upload(t, e, r) {
            return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (e.alphaMode = this.alphaMode), super.upload(t, e, r)) : (this.load(), !1)
        }
        dispose() {
            this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null
        }
        static test(t) {
            return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
        }
        static get EMPTY() {
            var t;
            return xn._EMPTY = (t = xn._EMPTY) != null ? t : et.ADAPTER.createCanvas(0, 0), xn._EMPTY
        }
    };
    const mo = class extends Zr {
        constructor(t, e) {
            e = e || {}, super(et.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = t, this.scale = e.scale || 1, this._overrideWidth = e.width, this._overrideHeight = e.height, this._resolve = null, this._crossorigin = e.crossorigin, this._load = null, e.autoLoad !== !1 && this.load()
        }
        load() {
            return this._load ? this._load : (this._load = new Promise(t => {
                if (this._resolve = () => {
                        this.resize(this.source.width, this.source.height), t(this)
                    }, mo.SVG_XML.test(this.svg.trim())) {
                    if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                    this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
                }
                this._loadSvg()
            }), this._load)
        }
        _loadSvg() {
            const t = new Image;
            Zr.crossOrigin(t, this.svg, this._crossorigin), t.src = this.svg, t.onerror = e => {
                this._resolve && (t.onerror = null, this.onError.emit(e))
            }, t.onload = () => {
                if (!this._resolve) return;
                const e = t.width,
                    r = t.height;
                if (!e || !r) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                let i = e * this.scale,
                    n = r * this.scale;
                (this._overrideWidth || this._overrideHeight) && (i = this._overrideWidth || this._overrideHeight / r * e, n = this._overrideHeight || this._overrideWidth / e * r), i = Math.round(i), n = Math.round(n);
                const a = this.source;
                a.width = i, a.height = n, a._pixiId = `canvas_${wi()}`, a.getContext("2d").drawImage(t, 0, 0, e, r, 0, 0, i, n), this._resolve(), this._resolve = null
            }
        }
        static getSize(t) {
            const e = mo.SVG_SIZE.exec(t),
                r = {};
            return e && (r[e[1]] = Math.round(parseFloat(e[3])), r[e[5]] = Math.round(parseFloat(e[7]))), r
        }
        dispose() {
            super.dispose(), this._resolve = null, this._crossorigin = null
        }
        static test(t, e) {
            return e === "svg" || typeof t == "string" && t.startsWith("data:image/svg+xml") || typeof t == "string" && mo.SVG_XML.test(t)
        }
    };
    En = mo, En.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, En.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
    const Du = class extends Zr {
        constructor(t, e) {
            if (e = e || {}, !(t instanceof HTMLVideoElement)) {
                const r = document.createElement("video");
                r.setAttribute("preload", "auto"), r.setAttribute("webkit-playsinline", ""), r.setAttribute("playsinline", ""), typeof t == "string" && (t = [t]);
                const i = t[0].src || t[0];
                Zr.crossOrigin(r, i, e.crossorigin);
                for (let n = 0; n < t.length; ++n) {
                    const a = document.createElement("source");
                    let {
                        src: l,
                        mime: h
                    } = t[n];
                    l = l || t[n];
                    const c = l.split("?").shift().toLowerCase(),
                        d = c.slice(c.lastIndexOf(".") + 1);
                    h = h || Du.MIME_TYPES[d] || `video/${d}`, a.src = l, a.type = h, r.appendChild(a)
                }
                t = r
            }
            super(t), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), e.autoLoad !== !1 && this.load()
        }
        update(t = 0) {
            if (!this.destroyed) {
                const e = Vt.shared.elapsedMS * this.source.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
            }
        }
        load() {
            if (this._load) return this._load;
            const t = this.source;
            return (t.readyState === t.HAVE_ENOUGH_DATA || t.readyState === t.HAVE_FUTURE_DATA) && t.width && t.height && (t.complete = !0), t.addEventListener("play", this._onPlayStart.bind(this)), t.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (t.addEventListener("canplay", this._onCanPlay), t.addEventListener("canplaythrough", this._onCanPlay), t.addEventListener("error", this._onError, !0)), this._load = new Promise(e => {
                this.valid ? e(this) : (this._resolve = e, t.load())
            }), this._load
        }
        _onError(t) {
            this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t)
        }
        _isSourcePlaying() {
            const t = this.source;
            return !t.paused && !t.ended && this._isSourceReady()
        }
        _isSourceReady() {
            return this.source.readyState > 2
        }
        _onPlayStart() {
            this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Vt.shared.add(this.update, this), this._isConnectedToTicker = !0)
        }
        _onPlayStop() {
            this._isConnectedToTicker && (Vt.shared.remove(this.update, this), this._isConnectedToTicker = !1)
        }
        _onCanPlay() {
            const t = this.source;
            t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
            const e = this.valid;
            this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
        }
        dispose() {
            this._isConnectedToTicker && (Vt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
            const t = this.source;
            t && (t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), super.dispose()
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(t) {
            t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Vt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Vt.shared.add(this.update, this), this._isConnectedToTicker = !0))
        }
        get updateFPS() {
            return this._updateFPS
        }
        set updateFPS(t) {
            t !== this._updateFPS && (this._updateFPS = t)
        }
        static test(t, e) {
            return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || Du.TYPES.includes(e)
        }
    };
    Ca = Du, Ca.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], Ca.MIME_TYPES = {
        ogv: "video/ogg",
        mov: "video/quicktime",
        m4v: "video/mp4"
    }, wa.push(xn, Yl, pf, Ca, En, yn, Dl, ip), dv = class {
        constructor() {
            this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new ze("disposeTransformFeedback")
        }
        bindBuffer(t, e) {
            this.buffers[t] = e
        }
        destroy() {
            this.disposeRunner.emit(this, !1)
        }
    }, fv = "7.1.4", as = class {
        constructor() {
            this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
        }
        isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY
        }
        clear() {
            this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
        }
        getRectangle(t) {
            return this.minX > this.maxX || this.minY > this.maxY ? bt.EMPTY : (t = t || new bt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
        }
        addPoint(t) {
            this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
        }
        addPointMatrix(t, e) {
            const {
                a: r,
                b: i,
                c: n,
                d: a,
                tx: l,
                ty: h
            } = t, c = r * e.x + n * e.y + l, d = i * e.x + a * e.y + h;
            this.minX = Math.min(this.minX, c), this.maxX = Math.max(this.maxX, c), this.minY = Math.min(this.minY, d), this.maxY = Math.max(this.maxY, d)
        }
        addQuad(t) {
            let e = this.minX,
                r = this.minY,
                i = this.maxX,
                n = this.maxY,
                a = t[0],
                l = t[1];
            e = a < e ? a : e, r = l < r ? l : r, i = a > i ? a : i, n = l > n ? l : n, a = t[2], l = t[3], e = a < e ? a : e, r = l < r ? l : r, i = a > i ? a : i, n = l > n ? l : n, a = t[4], l = t[5], e = a < e ? a : e, r = l < r ? l : r, i = a > i ? a : i, n = l > n ? l : n, a = t[6], l = t[7], e = a < e ? a : e, r = l < r ? l : r, i = a > i ? a : i, n = l > n ? l : n, this.minX = e, this.minY = r, this.maxX = i, this.maxY = n
        }
        addFrame(t, e, r, i, n) {
            this.addFrameMatrix(t.worldTransform, e, r, i, n)
        }
        addFrameMatrix(t, e, r, i, n) {
            const a = t.a,
                l = t.b,
                h = t.c,
                c = t.d,
                d = t.tx,
                f = t.ty;
            let g = this.minX,
                y = this.minY,
                x = this.maxX,
                _ = this.maxY,
                E = a * e + h * r + d,
                w = l * e + c * r + f;
            g = E < g ? E : g, y = w < y ? w : y, x = E > x ? E : x, _ = w > _ ? w : _, E = a * i + h * r + d, w = l * i + c * r + f, g = E < g ? E : g, y = w < y ? w : y, x = E > x ? E : x, _ = w > _ ? w : _, E = a * e + h * n + d, w = l * e + c * n + f, g = E < g ? E : g, y = w < y ? w : y, x = E > x ? E : x, _ = w > _ ? w : _, E = a * i + h * n + d, w = l * i + c * n + f, g = E < g ? E : g, y = w < y ? w : y, x = E > x ? E : x, _ = w > _ ? w : _, this.minX = g, this.minY = y, this.maxX = x, this.maxY = _
        }
        addVertexData(t, e, r) {
            let i = this.minX,
                n = this.minY,
                a = this.maxX,
                l = this.maxY;
            for (let h = e; h < r; h += 2) {
                const c = t[h],
                    d = t[h + 1];
                i = c < i ? c : i, n = d < n ? d : n, a = c > a ? c : a, l = d > l ? d : l
            }
            this.minX = i, this.minY = n, this.maxX = a, this.maxY = l
        }
        addVertices(t, e, r, i) {
            this.addVerticesMatrix(t.worldTransform, e, r, i)
        }
        addVerticesMatrix(t, e, r, i, n = 0, a = n) {
            const l = t.a,
                h = t.b,
                c = t.c,
                d = t.d,
                f = t.tx,
                g = t.ty;
            let y = this.minX,
                x = this.minY,
                _ = this.maxX,
                E = this.maxY;
            for (let w = r; w < i; w += 2) {
                const I = e[w],
                    S = e[w + 1],
                    T = l * I + c * S + f,
                    P = d * S + h * I + g;
                y = Math.min(y, T - n), _ = Math.max(_, T + n), x = Math.min(x, P - a), E = Math.max(E, P + a)
            }
            this.minX = y, this.minY = x, this.maxX = _, this.maxY = E
        }
        addBounds(t) {
            const e = this.minX,
                r = this.minY,
                i = this.maxX,
                n = this.maxY;
            this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > i ? t.maxX : i, this.maxY = t.maxY > n ? t.maxY : n
        }
        addBoundsMask(t, e) {
            const r = t.minX > e.minX ? t.minX : e.minX,
                i = t.minY > e.minY ? t.minY : e.minY,
                n = t.maxX < e.maxX ? t.maxX : e.maxX,
                a = t.maxY < e.maxY ? t.maxY : e.maxY;
            if (r <= n && i <= a) {
                const l = this.minX,
                    h = this.minY,
                    c = this.maxX,
                    d = this.maxY;
                this.minX = r < l ? r : l, this.minY = i < h ? i : h, this.maxX = n > c ? n : c, this.maxY = a > d ? a : d
            }
        }
        addBoundsMatrix(t, e) {
            this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
        }
        addBoundsArea(t, e) {
            const r = t.minX > e.x ? t.minX : e.x,
                i = t.minY > e.y ? t.minY : e.y,
                n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
                a = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
            if (r <= n && i <= a) {
                const l = this.minX,
                    h = this.minY,
                    c = this.maxX,
                    d = this.maxY;
                this.minX = r < l ? r : l, this.minY = i < h ? i : h, this.maxX = n > c ? n : c, this.maxY = a > d ? a : d
            }
        }
        pad(t = 0, e = t) {
            this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
        }
        addFramePad(t, e, r, i, n, a) {
            t -= n, e -= a, r += n, i += a, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > i ? this.maxY : i
        }
    }, Ft = class extends An {
        constructor() {
            super(), this.tempDisplayObjectParent = null, this.transform = new gs, this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new as, this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
        }
        static mixin(t) {
            const e = Object.keys(t);
            for (let r = 0; r < e.length; ++r) {
                const i = e[r];
                Object.defineProperty(Ft.prototype, i, Object.getOwnPropertyDescriptor(t, i))
            }
        }
        get destroyed() {
            return this._destroyed
        }
        _recursivePostUpdateTransform() {
            this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
        }
        updateTransform() {
            this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
        }
        getBounds(t, e) {
            return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new bt), e = this._boundsRect), this._bounds.getRectangle(e)
        }
        getLocalBounds(t) {
            t || (this._localBoundsRect || (this._localBoundsRect = new bt), t = this._localBoundsRect), this._localBounds || (this._localBounds = new as);
            const e = this.transform,
                r = this.parent;
            this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
            const i = this._bounds,
                n = this._boundsID;
            this._bounds = this._localBounds;
            const a = this.getBounds(!1, t);
            return this.parent = r, this.transform = e, this._bounds = i, this._bounds.updateID += this._boundsID - n, a
        }
        toGlobal(t, e, r = !1) {
            return r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
        }
        toLocal(t, e, r, i) {
            return e && (t = e.toGlobal(t, r, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, r)
        }
        setParent(t) {
            if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
            return t.addChild(this), t
        }
        removeFromParent() {
            var t;
            (t = this.parent) == null || t.removeChild(this)
        }
        setTransform(t = 0, e = 0, r = 1, i = 1, n = 0, a = 0, l = 0, h = 0, c = 0) {
            return this.position.x = t, this.position.y = e, this.scale.x = r || 1, this.scale.y = i || 1, this.rotation = n, this.skew.x = a, this.skew.y = l, this.pivot.x = h, this.pivot.y = c, this
        }
        destroy(t) {
            this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners()
        }
        get _tempDisplayObjectParent() {
            return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new Ep), this.tempDisplayObjectParent
        }
        enableTempParent() {
            const t = this.parent;
            return this.parent = this._tempDisplayObjectParent, t
        }
        disableTempParent(t) {
            this.parent = t
        }
        get x() {
            return this.position.x
        }
        set x(t) {
            this.transform.position.x = t
        }
        get y() {
            return this.position.y
        }
        set y(t) {
            this.transform.position.y = t
        }
        get worldTransform() {
            return this.transform.worldTransform
        }
        get localTransform() {
            return this.transform.localTransform
        }
        get position() {
            return this.transform.position
        }
        set position(t) {
            this.transform.position.copyFrom(t)
        }
        get scale() {
            return this.transform.scale
        }
        set scale(t) {
            this.transform.scale.copyFrom(t)
        }
        get pivot() {
            return this.transform.pivot
        }
        set pivot(t) {
            this.transform.pivot.copyFrom(t)
        }
        get skew() {
            return this.transform.skew
        }
        set skew(t) {
            this.transform.skew.copyFrom(t)
        }
        get rotation() {
            return this.transform.rotation
        }
        set rotation(t) {
            this.transform.rotation = t
        }
        get angle() {
            return this.transform.rotation * xp
        }
        set angle(t) {
            this.transform.rotation = t * ep
        }
        get zIndex() {
            return this._zIndex
        }
        set zIndex(t) {
            this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
        }
        get worldVisible() {
            let t = this;
            do {
                if (!t.visible) return !1;
                t = t.parent
            } while (t);
            return !0
        }
        get mask() {
            return this._mask
        }
        set mask(t) {
            if (this._mask !== t) {
                if (this._mask) {
                    const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                    e && (e._maskRefCount--, e._maskRefCount === 0 && (e.renderable = !0, e.isMask = !1))
                }
                if (this._mask = t, this._mask) {
                    const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                    e && (e._maskRefCount === 0 && (e.renderable = !1, e.isMask = !0), e._maskRefCount++)
                }
            }
        }
    }, Ep = class extends Ft {
        constructor() {
            super(...arguments), this.sortDirty = null
        }
    }, Ft.prototype.displayObjectUpdateTransform = Ft.prototype.updateTransform;
    const kT = new Ut;

    function FT(t, e) {
        return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
    }
    const Nu = class extends Ft {
        constructor() {
            super(), this.children = [], this.sortableChildren = Nu.defaultSortableChildren, this.sortDirty = !1
        }
        onChildrenChange(t) {}
        addChild(...t) {
            if (t.length > 1)
                for (let e = 0; e < t.length; e++) this.addChild(t[e]);
            else {
                const e = t[0];
                e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.push(e), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", e, this, this.children.length - 1), e.emit("added", this)
            }
            return t[0]
        }
        addChildAt(t, e) {
            if (e < 0 || e > this.children.length) throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`);
            return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t
        }
        swapChildren(t, e) {
            if (t === e) return;
            const r = this.getChildIndex(t),
                i = this.getChildIndex(e);
            this.children[r] = e, this.children[i] = t, this.onChildrenChange(r < i ? r : i)
        }
        getChildIndex(t) {
            const e = this.children.indexOf(t);
            if (e === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }
        setChildIndex(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            const r = this.getChildIndex(t);
            Yi(this.children, r, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
        }
        getChildAt(t) {
            if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`);
            return this.children[t]
        }
        removeChild(...t) {
            if (t.length > 1)
                for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
            else {
                const e = t[0],
                    r = this.children.indexOf(e);
                if (r === -1) return null;
                e.parent = null, e.transform._parentID = -1, Yi(this.children, r, 1), this._boundsID++, this.onChildrenChange(r), e.emit("removed", this), this.emit("childRemoved", e, this, r)
            }
            return t[0]
        }
        removeChildAt(t) {
            const e = this.getChildAt(t);
            return e.parent = null, e.transform._parentID = -1, Yi(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e
        }
        removeChildren(t = 0, e = this.children.length) {
            const r = t,
                i = e,
                n = i - r;
            let a;
            if (n > 0 && n <= i) {
                a = this.children.splice(r, n);
                for (let l = 0; l < a.length; ++l) a[l].parent = null, a[l].transform && (a[l].transform._parentID = -1);
                this._boundsID++, this.onChildrenChange(t);
                for (let l = 0; l < a.length; ++l) a[l].emit("removed", this), this.emit("childRemoved", a[l], this, l);
                return a
            } else if (n === 0 && this.children.length === 0) return [];
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        }
        sortChildren() {
            let t = !1;
            for (let e = 0, r = this.children.length; e < r; ++e) {
                const i = this.children[e];
                i._lastSortedIndex = e, !t && i.zIndex !== 0 && (t = !0)
            }
            t && this.children.length > 1 && this.children.sort(FT), this.sortDirty = !1
        }
        updateTransform() {
            this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
            for (let t = 0, e = this.children.length; t < e; ++t) {
                const r = this.children[t];
                r.visible && r.updateTransform()
            }
        }
        calculateBounds() {
            this._bounds.clear(), this._calculateBounds();
            for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                if (!(!e.visible || !e.renderable))
                    if (e.calculateBounds(), e._mask) {
                        const r = e._mask.isMaskData ? e._mask.maskObject : e._mask;
                        r ? (r.calculateBounds(), this._bounds.addBoundsMask(e._bounds, r._bounds)) : this._bounds.addBounds(e._bounds)
                    } else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
            }
            this._bounds.updateID = this._boundsID
        }
        getLocalBounds(t, e = !1) {
            const r = super.getLocalBounds(t);
            if (!e)
                for (let i = 0, n = this.children.length; i < n; ++i) {
                    const a = this.children[i];
                    a.visible && a.updateTransform()
                }
            return r
        }
        _calculateBounds() {}
        _renderWithCulling(t) {
            const e = t.renderTexture.sourceFrame;
            if (!(e.width > 0 && e.height > 0)) return;
            let r, i;
            this.cullArea ? (r = this.cullArea, i = this.worldTransform) : this._render !== Nu.prototype._render && (r = this.getBounds(!0));
            const n = t.projection.transform;
            if (n && (i ? (i = kT.copyFrom(i), i.prepend(n)) : i = n), r && e.intersects(r, i)) this._render(t);
            else if (this.cullArea) return;
            for (let a = 0, l = this.children.length; a < l; ++a) {
                const h = this.children[a],
                    c = h.cullable;
                h.cullable = c || !this.cullArea, h.render(t), h.cullable = c
            }
        }
        render(t) {
            var e;
            if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
                if (this._mask || (e = this.filters) != null && e.length) this.renderAdvanced(t);
                else if (this.cullable) this._renderWithCulling(t);
            else {
                this._render(t);
                for (let r = 0, i = this.children.length; r < i; ++r) this.children[r].render(t)
            }
        }
        renderAdvanced(t) {
            var e, r, i;
            const n = this.filters,
                a = this._mask;
            if (n) {
                this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
                for (let h = 0; h < n.length; h++) n[h].enabled && this._enabledFilters.push(n[h])
            }
            const l = n && ((e = this._enabledFilters) == null ? void 0 : e.length) || a && (!a.isMaskData || a.enabled && (a.autoDetect || a.type !== ee.NONE));
            if (l && t.batch.flush(), n && (r = this._enabledFilters) != null && r.length && t.filter.push(this, this._enabledFilters), a && t.mask.push(this, this._mask), this.cullable) this._renderWithCulling(t);
            else {
                this._render(t);
                for (let h = 0, c = this.children.length; h < c; ++h) this.children[h].render(t)
            }
            l && t.batch.flush(), a && t.mask.pop(this), n && (i = this._enabledFilters) != null && i.length && t.filter.pop()
        }
        _render(t) {}
        destroy(t) {
            super.destroy(), this.sortDirty = !1;
            const e = typeof t == "boolean" ? t : t == null ? void 0 : t.children,
                r = this.removeChildren(0, this.children.length);
            if (e)
                for (let i = 0; i < r.length; ++i) r[i].destroy(t)
        }
        get width() {
            return this.scale.x * this.getLocalBounds().width
        }
        set width(t) {
            const e = this.getLocalBounds().width;
            e !== 0 ? this.scale.x = t / e : this.scale.x = 1, this._width = t
        }
        get height() {
            return this.scale.y * this.getLocalBounds().height
        }
        set height(t) {
            const e = this.getLocalBounds().height;
            e !== 0 ? this.scale.y = t / e : this.scale.y = 1, this._height = t
        }
    };
    Kt = Nu, Kt.defaultSortableChildren = !1, Kt.prototype.containerUpdateTransform = Kt.prototype.updateTransform, Object.defineProperties(et, {
        SORTABLE_CHILDREN: {
            get() {
                return Kt.defaultSortableChildren
            },
            set(t) {
                Tt("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), Kt.defaultSortableChildren = t
            }
        }
    });
    const Fs = new gt,
        UT = new Uint16Array([0, 1, 2, 0, 2, 3]);
    Dr = class extends Kt {
        constructor(t) {
            super(), this._anchor = new Jr(this._onAnchorUpdate, this, t ? t.defaultAnchor.x : 0, t ? t.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = ut.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = t || Q.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = UT, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = et.ROUND_PIXELS
        }
        _onTextureUpdate() {
            this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = qi(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = qi(this.scale.y) * this._height / this._texture.orig.height)
        }
        _onAnchorUpdate() {
            this._transformID = -1, this._transformTrimmedID = -1
        }
        calculateVertices() {
            const t = this._texture;
            if (this._transformID === this.transform._worldID && this._textureID === t._updateID) return;
            this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
            const e = this.transform.worldTransform,
                r = e.a,
                i = e.b,
                n = e.c,
                a = e.d,
                l = e.tx,
                h = e.ty,
                c = this.vertexData,
                d = t.trim,
                f = t.orig,
                g = this._anchor;
            let y = 0,
                x = 0,
                _ = 0,
                E = 0;
            if (d ? (x = d.x - g._x * f.width, y = x + d.width, E = d.y - g._y * f.height, _ = E + d.height) : (x = -g._x * f.width, y = x + f.width, E = -g._y * f.height, _ = E + f.height), c[0] = r * x + n * E + l, c[1] = a * E + i * x + h, c[2] = r * y + n * E + l, c[3] = a * E + i * y + h, c[4] = r * y + n * _ + l, c[5] = a * _ + i * y + h, c[6] = r * x + n * _ + l, c[7] = a * _ + i * x + h, this._roundPixels) {
                const w = et.RESOLUTION;
                for (let I = 0; I < c.length; ++I) c[I] = Math.round(c[I] * w) / w
            }
        }
        calculateTrimmedVertices() {
            if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8);
            else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
            this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
            const t = this._texture,
                e = this.vertexTrimmedData,
                r = t.orig,
                i = this._anchor,
                n = this.transform.worldTransform,
                a = n.a,
                l = n.b,
                h = n.c,
                c = n.d,
                d = n.tx,
                f = n.ty,
                g = -i._x * r.width,
                y = g + r.width,
                x = -i._y * r.height,
                _ = x + r.height;
            e[0] = a * g + h * x + d, e[1] = c * x + l * g + f, e[2] = a * y + h * x + d, e[3] = c * x + l * y + f, e[4] = a * y + h * _ + d, e[5] = c * _ + l * y + f, e[6] = a * g + h * _ + d, e[7] = c * _ + l * g + f
        }
        _render(t) {
            this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
        }
        _calculateBounds() {
            const t = this._texture.trim,
                e = this._texture.orig;
            !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
        }
        getLocalBounds(t) {
            return this.children.length === 0 ? (this._localBounds || (this._localBounds = new as), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new bt), t = this._localBoundsRect), this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
        }
        containsPoint(t) {
            this.worldTransform.applyInverse(t, Fs);
            const e = this._texture.orig.width,
                r = this._texture.orig.height,
                i = -e * this.anchor.x;
            let n = 0;
            return Fs.x >= i && Fs.x < i + e && (n = -r * this.anchor.y, Fs.y >= n && Fs.y < n + r)
        }
        destroy(t) {
            if (super.destroy(t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
                const e = typeof t == "boolean" ? t : t == null ? void 0 : t.baseTexture;
                this._texture.destroy(!!e)
            }
            this._texture = null
        }
        static from(t, e) {
            const r = t instanceof Q ? t : Q.from(t, e);
            return new Dr(r)
        }
        set roundPixels(t) {
            this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
        }
        get roundPixels() {
            return this._roundPixels
        }
        get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(t) {
            const e = qi(this.scale.x) || 1;
            this.scale.x = e * t / this._texture.orig.width, this._width = t
        }
        get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(t) {
            const e = qi(this.scale.y) || 1;
            this.scale.y = e * t / this._texture.orig.height, this._height = t
        }
        get anchor() {
            return this._anchor
        }
        set anchor(t) {
            this._anchor.copyFrom(t)
        }
        get tint() {
            return this._tint
        }
        set tint(t) {
            this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16)
        }
        get texture() {
            return this._texture
        }
        set texture(t) {
            this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Q.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
        }
    };
    const Ym = new Ut;
    Ft.prototype._cacheAsBitmap = !1, Ft.prototype._cacheData = null, Ft.prototype._cacheAsBitmapResolution = null, Ft.prototype._cacheAsBitmapMultisample = null;
    class GT {
        constructor() {
            this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
        }
    }
    Object.defineProperties(Ft.prototype, {
        cacheAsBitmapResolution: {
            get() {
                return this._cacheAsBitmapResolution
            },
            set(t) {
                t !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
            }
        },
        cacheAsBitmapMultisample: {
            get() {
                return this._cacheAsBitmapMultisample
            },
            set(t) {
                t !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
            }
        },
        cacheAsBitmap: {
            get() {
                return this._cacheAsBitmap
            },
            set(t) {
                if (this._cacheAsBitmap === t) return;
                this._cacheAsBitmap = t;
                let e;
                t ? (this._cacheData || (this._cacheData = new GT), e = this._cacheData, e.originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData, e.sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea)
            }
        }
    }), Ft.prototype._renderCached = function(t) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
    }, Ft.prototype._initCachedDisplayObject = function(t) {
        var x;
        var e, r;
        if ((e = this._cacheData) != null && e.sprite) return;
        const i = this.alpha;
        this.alpha = 1, t.batch.flush();
        const n = this.getLocalBounds(null, !0).clone();
        if ((r = this.filters) != null && r.length) {
            const _ = this.filters[0].padding;
            n.pad(_)
        }
        n.ceil(et.RESOLUTION);
        const a = t.renderTexture.current,
            l = t.renderTexture.sourceFrame.clone(),
            h = t.renderTexture.destinationFrame.clone(),
            c = t.projection.transform,
            d = yi.create({
                width: n.width,
                height: n.height,
                resolution: this.cacheAsBitmapResolution || t.resolution,
                multisample: (x = this.cacheAsBitmapMultisample) != null ? x : t.multisample
            }),
            f = `cacheAsBitmap_${wi()}`;
        this._cacheData.textureCacheId = f, mt.addToCache(d.baseTexture, f), Q.addToCache(d, f);
        const g = this.transform.localTransform.copyTo(Ym).invert().translate(-n.x, -n.y);
        this.render = this._cacheData.originalRender, t.render(this, {
            renderTexture: d,
            clear: !0,
            transform: g,
            skipUpdateTransform: !1
        }), t.framebuffer.blit(), t.projection.transform = c, t.renderTexture.bind(a, l, h), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
        const y = new Dr(d);
        y.transform.worldTransform = this.transform.worldTransform, y.anchor.x = -(n.x / n.width), y.anchor.y = -(n.y / n.height), y.alpha = i, y._bounds = this._bounds, this._cacheData.sprite = y, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = y.containsPoint.bind(y)
    }, Ft.prototype._renderCachedCanvas = function(t) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
    }, Ft.prototype._initCachedDisplayObjectCanvas = function(t) {
        var e;
        if ((e = this._cacheData) != null && e.sprite) return;
        const r = this.getLocalBounds(null, !0),
            i = this.alpha;
        this.alpha = 1;
        const n = t.canvasContext.activeContext,
            a = t._projTransform;
        r.ceil(et.RESOLUTION);
        const l = yi.create({
                width: r.width,
                height: r.height
            }),
            h = `cacheAsBitmap_${wi()}`;
        this._cacheData.textureCacheId = h, mt.addToCache(l.baseTexture, h), Q.addToCache(l, h);
        const c = Ym;
        this.transform.localTransform.copyTo(c), c.invert(), c.tx -= r.x, c.ty -= r.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
            renderTexture: l,
            clear: !0,
            transform: c,
            skipUpdateTransform: !1
        }), t.canvasContext.activeContext = n, t._projTransform = a, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
        const d = new Dr(l);
        d.transform.worldTransform = this.transform.worldTransform, d.anchor.x = -(r.x / r.width), d.anchor.y = -(r.y / r.height), d.alpha = i, d._bounds = this._bounds, this._cacheData.sprite = d, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = d.containsPoint.bind(d)
    }, Ft.prototype._calculateCachedBounds = function() {
        this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
    }, Ft.prototype._getCachedLocalBounds = function() {
        return this._cacheData.sprite.getLocalBounds(null)
    }, Ft.prototype._destroyCachedDisplayObject = function() {
        this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, mt.removeFromCache(this._cacheData.textureCacheId), Q.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
    }, Ft.prototype._cacheAsBitmapDestroy = function(t) {
        this.cacheAsBitmap = !1, this.destroy(t)
    }, Ft.prototype.name = null, Kt.prototype.getChildByName = function(t, e) {
        for (let r = 0, i = this.children.length; r < i; r++)
            if (this.children[r].name === t) return this.children[r];
        if (e)
            for (let r = 0, i = this.children.length; r < i; r++) {
                const n = this.children[r];
                if (!n.getChildByName) continue;
                const a = n.getChildByName(t, !0);
                if (a) return a
            }
        return null
    }, Ft.prototype.getGlobalPosition = function(t = new gt, e = !1) {
        return this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
    };
    var zT = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
    uf = class extends ae {
        constructor(t = 1) {
            super(Qp, zT, {
                uAlpha: 1
            }), this.alpha = t
        }
        get alpha() {
            return this.uniforms.uAlpha
        }
        set alpha(t) {
            this.uniforms.uAlpha = t
        }
    };
    const HT = {
            5: [.153388, .221461, .250301],
            7: [.071303, .131514, .189879, .214607],
            9: [.028532, .067234, .124009, .179044, .20236],
            11: [.0093, .028002, .065984, .121703, .175713, .198596],
            13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
            15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
        },
        jT = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

    function WT(t) {
        const e = HT[t],
            r = e.length;
        let i = jT,
            n = "";
        const a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
        let l;
        for (let h = 0; h < t; h++) {
            let c = a.replace("%index%", h.toString());
            l = h, h >= r && (l = t - h - 1), c = c.replace("%value%", e[l].toString()), n += c, n += `
`
        }
        return i = i.replace("%blur%", n), i = i.replace("%size%", t.toString()), i
    }
    const XT = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

    function $T(t, e) {
        const r = Math.ceil(t / 2);
        let i = XT,
            n = "",
            a;
        e ? a = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : a = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
        for (let l = 0; l < t; l++) {
            let h = a.replace("%index%", l.toString());
            h = h.replace("%sampleIndex%", `${l-(r-1)}.0`), n += h, n += `
`
        }
        return i = i.replace("%blur%", n), i = i.replace("%size%", t.toString()), i
    }
    Na = class extends ae {
        constructor(t, e = 8, r = 4, i = ae.defaultResolution, n = 5) {
            const a = $T(n, t),
                l = WT(n);
            super(a, l), this.horizontal = t, this.resolution = i, this._quality = 0, this.quality = r, this.blur = e
        }
        apply(t, e, r, i) {
            if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / e.width) : this.uniforms.strength = 1 / r.height * (r.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1) t.applyFilter(this, e, r, i);
            else {
                const n = t.getFilterTexture(),
                    a = t.renderer;
                let l = e,
                    h = n;
                this.state.blend = !1, t.applyFilter(this, l, h, yr.CLEAR);
                for (let c = 1; c < this.passes - 1; c++) {
                    t.bindAndClear(l, yr.BLIT), this.uniforms.uSampler = h;
                    const d = h;
                    h = l, l = d, a.shader.bind(this), a.geometry.draw(5)
                }
                this.state.blend = !0, t.applyFilter(this, h, r, i), t.returnFilterTexture(n)
            }
        }
        get blur() {
            return this.strength
        }
        set blur(t) {
            this.padding = 1 + Math.abs(t) * 2, this.strength = t
        }
        get quality() {
            return this._quality
        }
        set quality(t) {
            this._quality = t, this.passes = t
        }
    }, of = class extends ae {
        constructor(t = 8, e = 4, r = ae.defaultResolution, i = 5) {
            super(), this.blurXFilter = new Na(!0, t, e, r, i), this.blurYFilter = new Na(!1, t, e, r, i), this.resolution = r, this.quality = e, this.blur = t, this.repeatEdgePixels = !1
        }
        apply(t, e, r, i) {
            const n = Math.abs(this.blurXFilter.strength),
                a = Math.abs(this.blurYFilter.strength);
            if (n && a) {
                const l = t.getFilterTexture();
                this.blurXFilter.apply(t, e, l, yr.CLEAR), this.blurYFilter.apply(t, l, r, i), t.returnFilterTexture(l)
            } else a ? this.blurYFilter.apply(t, e, r, i) : this.blurXFilter.apply(t, e, r, i)
        }
        updatePadding() {
            this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
        }
        get blur() {
            return this.blurXFilter.blur
        }
        set blur(t) {
            this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
        }
        get quality() {
            return this.blurXFilter.quality
        }
        set quality(t) {
            this.blurXFilter.quality = this.blurYFilter.quality = t
        }
        get blurX() {
            return this.blurXFilter.blur
        }
        set blurX(t) {
            this.blurXFilter.blur = t, this.updatePadding()
        }
        get blurY() {
            return this.blurYFilter.blur
        }
        set blurY(t) {
            this.blurYFilter.blur = t, this.updatePadding()
        }
        get blendMode() {
            return this.blurYFilter.blendMode
        }
        set blendMode(t) {
            this.blurYFilter.blendMode = t
        }
        get repeatEdgePixels() {
            return this._repeatEdgePixels
        }
        set repeatEdgePixels(t) {
            this._repeatEdgePixels = t, this.updatePadding()
        }
    };
    var VT = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
    ya = class extends ae {
        constructor() {
            const t = {
                m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                uAlpha: 1
            };
            super(bh, VT, t), this.alpha = 1
        }
        _loadMatrix(t, e = !1) {
            let r = t;
            e && (this._multiply(r, this.uniforms.m, t), r = this._colorMatrix(r)), this.uniforms.m = r
        }
        _multiply(t, e, r) {
            return t[0] = e[0] * r[0] + e[1] * r[5] + e[2] * r[10] + e[3] * r[15], t[1] = e[0] * r[1] + e[1] * r[6] + e[2] * r[11] + e[3] * r[16], t[2] = e[0] * r[2] + e[1] * r[7] + e[2] * r[12] + e[3] * r[17], t[3] = e[0] * r[3] + e[1] * r[8] + e[2] * r[13] + e[3] * r[18], t[4] = e[0] * r[4] + e[1] * r[9] + e[2] * r[14] + e[3] * r[19] + e[4], t[5] = e[5] * r[0] + e[6] * r[5] + e[7] * r[10] + e[8] * r[15], t[6] = e[5] * r[1] + e[6] * r[6] + e[7] * r[11] + e[8] * r[16], t[7] = e[5] * r[2] + e[6] * r[7] + e[7] * r[12] + e[8] * r[17], t[8] = e[5] * r[3] + e[6] * r[8] + e[7] * r[13] + e[8] * r[18], t[9] = e[5] * r[4] + e[6] * r[9] + e[7] * r[14] + e[8] * r[19] + e[9], t[10] = e[10] * r[0] + e[11] * r[5] + e[12] * r[10] + e[13] * r[15], t[11] = e[10] * r[1] + e[11] * r[6] + e[12] * r[11] + e[13] * r[16], t[12] = e[10] * r[2] + e[11] * r[7] + e[12] * r[12] + e[13] * r[17], t[13] = e[10] * r[3] + e[11] * r[8] + e[12] * r[13] + e[13] * r[18], t[14] = e[10] * r[4] + e[11] * r[9] + e[12] * r[14] + e[13] * r[19] + e[14], t[15] = e[15] * r[0] + e[16] * r[5] + e[17] * r[10] + e[18] * r[15], t[16] = e[15] * r[1] + e[16] * r[6] + e[17] * r[11] + e[18] * r[16], t[17] = e[15] * r[2] + e[16] * r[7] + e[17] * r[12] + e[18] * r[17], t[18] = e[15] * r[3] + e[16] * r[8] + e[17] * r[13] + e[18] * r[18], t[19] = e[15] * r[4] + e[16] * r[9] + e[17] * r[14] + e[18] * r[19] + e[19], t
        }
        _colorMatrix(t) {
            const e = new Float32Array(t);
            return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
        }
        brightness(t, e) {
            const r = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(r, e)
        }
        tint(t, e) {
            const r = t >> 16 & 255,
                i = t >> 8 & 255,
                n = t & 255,
                a = [r / 255, 0, 0, 0, 0, 0, i / 255, 0, 0, 0, 0, 0, n / 255, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(a, e)
        }
        greyscale(t, e) {
            const r = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(r, e)
        }
        blackAndWhite(t) {
            const e = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        hue(t, e) {
            t = (t || 0) / 180 * Math.PI;
            const r = Math.cos(t),
                i = Math.sin(t),
                n = Math.sqrt,
                a = 1 / 3,
                l = n(a),
                h = r + (1 - r) * a,
                c = a * (1 - r) - l * i,
                d = a * (1 - r) + l * i,
                f = a * (1 - r) + l * i,
                g = r + a * (1 - r),
                y = a * (1 - r) - l * i,
                x = a * (1 - r) - l * i,
                _ = a * (1 - r) + l * i,
                E = r + a * (1 - r),
                w = [h, c, d, 0, 0, f, g, y, 0, 0, x, _, E, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(w, e)
        }
        contrast(t, e) {
            const r = (t || 0) + 1,
                i = -.5 * (r - 1),
                n = [r, 0, 0, 0, i, 0, r, 0, 0, i, 0, 0, r, 0, i, 0, 0, 0, 1, 0];
            this._loadMatrix(n, e)
        }
        saturate(t = 0, e) {
            const r = t * 2 / 3 + 1,
                i = (r - 1) * -.5,
                n = [r, i, i, 0, 0, i, r, i, 0, 0, i, i, r, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(n, e)
        }
        desaturate() {
            this.saturate(-1)
        }
        negative(t) {
            const e = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        sepia(t) {
            const e = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        technicolor(t) {
            const e = [1.9125277891456085, -.8545344976951645, -.09155508482755584, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491134, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        polaroid(t) {
            const e = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        toBGR(t) {
            const e = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        kodachrome(t) {
            const e = [1.1285582396593523, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964945, 0, 35.62982807460946, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        browni(t) {
            const e = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.03770324983778316, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        vintage(t) {
            const e = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        colorTone(t, e, r, i, n) {
            t = t || .2, e = e || .15, r = r || 16770432, i = i || 3375104;
            const a = (r >> 16 & 255) / 255,
                l = (r >> 8 & 255) / 255,
                h = (r & 255) / 255,
                c = (i >> 16 & 255) / 255,
                d = (i >> 8 & 255) / 255,
                f = (i & 255) / 255,
                g = [.3, .59, .11, 0, 0, a, l, h, t, 0, c, d, f, e, 0, a - c, l - d, h - f, 0, 0];
            this._loadMatrix(g, n)
        }
        night(t, e) {
            t = t || .1;
            const r = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(r, e)
        }
        predator(t, e) {
            const r = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
            this._loadMatrix(r, e)
        }
        lsd(t) {
            const e = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(e, t)
        }
        reset() {
            const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
            this._loadMatrix(t, !1)
        }
        get matrix() {
            return this.uniforms.m
        }
        set matrix(t) {
            this.uniforms.m = t
        }
        get alpha() {
            return this.uniforms.uAlpha
        }
        set alpha(t) {
            this.uniforms.uAlpha = t
        }
    }, ya.prototype.grayscale = ya.prototype.greyscale;
    var YT = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
        qT = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
    rp = class extends ae {
        constructor(t, e) {
            const r = new Ut;
            t.renderable = !1, super(qT, YT, {
                mapSampler: t._texture,
                filterMatrix: r,
                scale: {
                    x: 1,
                    y: 1
                },
                rotation: new Float32Array([1, 0, 0, 1])
            }), this.maskSprite = t, this.maskMatrix = r, e == null && (e = 20), this.scale = new gt(e, e)
        }
        apply(t, e, r, i) {
            this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
            const n = this.maskSprite.worldTransform,
                a = Math.sqrt(n.a * n.a + n.b * n.b),
                l = Math.sqrt(n.c * n.c + n.d * n.d);
            a !== 0 && l !== 0 && (this.uniforms.rotation[0] = n.a / a, this.uniforms.rotation[1] = n.b / a, this.uniforms.rotation[2] = n.c / l, this.uniforms.rotation[3] = n.d / l), t.applyFilter(this, e, r, i)
        }
        get map() {
            return this.uniforms.mapSampler
        }
        set map(t) {
            this.uniforms.mapSampler = t
        }
    };
    var QT = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
        KT = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
    ap = class extends ae {
        constructor() {
            super(KT, QT)
        }
    };
    var ZT = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
    cp = class extends ae {
        constructor(t = .5, e = Math.random()) {
            super(bh, ZT, {
                uNoise: 0,
                uSeed: 0
            }), this.noise = t, this.seed = e
        }
        get noise() {
            return this.uniforms.uNoise
        }
        set noise(t) {
            this.uniforms.uNoise = t
        }
        get seed() {
            return this.uniforms.uSeed
        }
        set seed(t) {
            this.uniforms.uSeed = t
        }
    }, Eh = {
        AlphaFilter: uf,
        BlurFilter: of ,
        BlurFilterPass: Na,
        ColorMatrixFilter: ya,
        DisplacementFilter: rp,
        FXAAFilter: ap,
        NoiseFilter: cp
    }, Object.entries(Eh).forEach(([t, e]) => {
        Object.defineProperty(Eh, t, {
            get() {
                return Tt("7.1.0", `filters.${t} has moved to ${t}`), e
            }
        })
    }), os = class {
        constructor(t) {
            this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = os.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new gt, this.page = new gt, this.AT_TARGET = 1, this.BUBBLING_PHASE = 2, this.CAPTURING_PHASE = 3, this.NONE = 0, this.manager = t
        }
        get layerX() {
            return this.layer.x
        }
        get layerY() {
            return this.layer.y
        }
        get pageX() {
            return this.page.x
        }
        get pageY() {
            return this.page.y
        }
        get data() {
            return this
        }
        composedPath() {
            return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
        }
        initEvent(t, e, r) {
            throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        initUIEvent(t, e, r, i, n) {
            throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
        }
        preventDefault() {
            this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
        }
        stopImmediatePropagation() {
            this.propagationImmediatelyStopped = !0
        }
        stopPropagation() {
            this.propagationStopped = !0
        }
    }, ls = class extends os {
        constructor() {
            super(...arguments), this.client = new gt, this.movement = new gt, this.offset = new gt, this.global = new gt, this.screen = new gt
        }
        get clientX() {
            return this.client.x
        }
        get clientY() {
            return this.client.y
        }
        get x() {
            return this.clientX
        }
        get y() {
            return this.clientY
        }
        get movementX() {
            return this.movement.x
        }
        get movementY() {
            return this.movement.y
        }
        get offsetX() {
            return this.offset.x
        }
        get offsetY() {
            return this.offset.y
        }
        get globalX() {
            return this.global.x
        }
        get globalY() {
            return this.global.y
        }
        get screenX() {
            return this.screen.x
        }
        get screenY() {
            return this.screen.y
        }
        getModifierState(t) {
            return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t)
        }
        initMouseEvent(t, e, r, i, n, a, l, h, c, d, f, g, y, x, _) {
            throw new Error("Method not implemented.")
        }
    }, qe = class extends ls {
        constructor() {
            super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
        }
        getCoalescedEvents() {
            return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
        }
        getPredictedEvents() {
            throw new Error("getPredictedEvents is not supported!")
        }
    }, Ui = class extends ls {
        constructor() {
            super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2
        }
    }, Ui.DOM_DELTA_PIXEL = 0, Ui.DOM_DELTA_LINE = 1, Ui.DOM_DELTA_PAGE = 2;
    const JT = 2048,
        tw = new gt,
        Ou = new gt;
    Zd = class {
        constructor(t) {
            this.dispatch = new An, this.moveOnAll = !1, this.mappingState = {
                trackingData: {}
            }, this.eventPool = new Map, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
        }
        addEventMapping(t, e) {
            this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
                fn: e,
                priority: 0
            }), this.mappingTable[t].sort((r, i) => r.priority - i.priority)
        }
        dispatchEvent(t, e) {
            t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, e), this.dispatch.emit(e || t.type, t)
        }
        mapEvent(t) {
            if (!this.rootTarget) return;
            const e = this.mappingTable[t.type];
            if (e)
                for (let r = 0, i = e.length; r < i; r++) e[r].fn(t)
        }
        hitTest(t, e) {
            const r = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, tw.set(t, e), this.hitTestFn, this.hitPruneFn);
            return r && r[0]
        }
        propagate(t, e) {
            if (!t.target) return;
            const r = t.composedPath();
            t.eventPhase = t.CAPTURING_PHASE;
            for (let i = 0, n = r.length - 1; i < n; i++)
                if (t.currentTarget = r[i], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return;
            if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, e), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
                t.eventPhase = t.BUBBLING_PHASE;
                for (let i = r.length - 2; i >= 0; i--)
                    if (t.currentTarget = r[i], this.notifyTarget(t, e), t.propagationStopped || t.propagationImmediatelyStopped) return
            }
        }
        all(t, e, r = this.rootTarget) {
            t.eventPhase = t.BUBBLING_PHASE;
            const i = r.children;
            if (i)
                for (let n = 0; n < i.length; n++) this.all(t, e, i[n]);
            t.currentTarget = r, this.notifyTarget(t, e)
        }
        propagationPath(t) {
            const e = [t];
            for (let r = 0; r < JT && t !== this.rootTarget; r++) {
                if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
                e.push(t.parent), t = t.parent
            }
            return e.reverse(), e
        }
        hitTestRecursive(t, e, r, i, n) {
            if (!t || !t.visible || n(t, r)) return null;
            if (t.interactiveChildren && t.children) {
                const a = t.children;
                for (let l = a.length - 1; l >= 0; l--) {
                    const h = a[l],
                        c = this.hitTestRecursive(h, e || h.interactive, r, i, n);
                    if (c) {
                        if (c.length > 0 && !c[c.length - 1].parent) continue;
                        return (c.length > 0 || t.interactive) && c.push(t), c
                    }
                }
            }
            return e && i(t, r) ? t.interactive ? [t] : [] : null
        }
        hitPruneFn(t, e) {
            var r;
            if (t.hitArea && (t.worldTransform.applyInverse(e, Ou), !t.hitArea.contains(Ou.x, Ou.y))) return !0;
            if (t._mask) {
                const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                if (i && !((r = i.containsPoint) != null && r.call(i, e))) return !0
            }
            return !1
        }
        hitTestFn(t, e) {
            return t.hitArea ? !0 : t.containsPoint ? t.containsPoint(e) : !1
        }
        notifyTarget(t, e) {
            var r, i;
            e = e != null ? e : t.type;
            const n = `on${e}`;
            (i = (r = t.currentTarget)[n]) == null || i.call(r, t);
            const a = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${e}capture` : e;
            this.notifyListeners(t, a), t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e)
        }
        mapPointerDown(t) {
            if (!(t instanceof qe)) return;
            const e = this.createPointerEvent(t);
            if (this.dispatchEvent(e, "pointerdown"), e.pointerType === "touch") this.dispatchEvent(e, "touchstart");
            else if (e.pointerType === "mouse" || e.pointerType === "pen") {
                const i = e.button === 2;
                this.dispatchEvent(e, i ? "rightdown" : "mousedown")
            }
            const r = this.trackingData(t.pointerId);
            r.pressTargetsByButton[t.button] = e.composedPath(), this.freeEvent(e)
        }
        mapPointerMove(t) {
            var e, r;
            if (!(t instanceof qe)) return;
            const i = this.createPointerEvent(t),
                n = i.pointerType === "mouse" || i.pointerType === "pen",
                a = this.trackingData(t.pointerId),
                l = this.findMountedTarget(a.overTargets);
            if (((e = a.overTargets) == null ? void 0 : e.length) > 0 && l !== i.target) {
                const c = t.type === "mousemove" ? "mouseout" : "pointerout",
                    d = this.createPointerEvent(t, c, l);
                if (this.dispatchEvent(d, "pointerout"), n && this.dispatchEvent(d, "mouseout"), !i.composedPath().includes(l)) {
                    const f = this.createPointerEvent(t, "pointerleave", l);
                    for (f.eventPhase = f.AT_TARGET; f.target && !i.composedPath().includes(f.target);) f.currentTarget = f.target, this.notifyTarget(f), n && this.notifyTarget(f, "mouseleave"), f.target = f.target.parent;
                    this.freeEvent(f)
                }
                this.freeEvent(d)
            }
            if (l !== i.target) {
                const c = t.type === "mousemove" ? "mouseover" : "pointerover",
                    d = this.clonePointerEvent(i, c);
                this.dispatchEvent(d, "pointerover"), n && this.dispatchEvent(d, "mouseover");
                let f = l == null ? void 0 : l.parent;
                for (; f && f !== this.rootTarget.parent && f !== i.target;) f = f.parent;
                if (!f || f === this.rootTarget.parent) {
                    const g = this.clonePointerEvent(i, "pointerenter");
                    for (g.eventPhase = g.AT_TARGET; g.target && g.target !== l && g.target !== this.rootTarget.parent;) g.currentTarget = g.target, this.notifyTarget(g), n && this.notifyTarget(g, "mouseenter"), g.target = g.target.parent;
                    this.freeEvent(g)
                }
                this.freeEvent(d)
            }
            const h = this.moveOnAll ? "all" : "dispatchEvent";
            this[h](i, "pointermove"), this.all(i, "globalpointermove"), i.pointerType === "touch" && (this[h](i, "touchmove"), this.all(i, "globaltouchmove")), n && (this[h](i, "mousemove"), this.all(i, "globalmousemove"), this.cursor = (r = i.target) == null ? void 0 : r.cursor), a.overTargets = i.composedPath(), this.freeEvent(i)
        }
        mapPointerOver(t) {
            var e;
            if (!(t instanceof qe)) return;
            const r = this.trackingData(t.pointerId),
                i = this.createPointerEvent(t),
                n = i.pointerType === "mouse" || i.pointerType === "pen";
            this.dispatchEvent(i, "pointerover"), n && this.dispatchEvent(i, "mouseover"), i.pointerType === "mouse" && (this.cursor = (e = i.target) == null ? void 0 : e.cursor);
            const a = this.clonePointerEvent(i, "pointerenter");
            for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent;) a.currentTarget = a.target, this.notifyTarget(a), n && this.notifyTarget(a, "mouseenter"), a.target = a.target.parent;
            r.overTargets = i.composedPath(), this.freeEvent(i), this.freeEvent(a)
        }
        mapPointerOut(t) {
            if (!(t instanceof qe)) return;
            const e = this.trackingData(t.pointerId);
            if (e.overTargets) {
                const r = t.pointerType === "mouse" || t.pointerType === "pen",
                    i = this.findMountedTarget(e.overTargets),
                    n = this.createPointerEvent(t, "pointerout", i);
                this.dispatchEvent(n), r && this.dispatchEvent(n, "mouseout");
                const a = this.createPointerEvent(t, "pointerleave", i);
                for (a.eventPhase = a.AT_TARGET; a.target && a.target !== this.rootTarget.parent;) a.currentTarget = a.target, this.notifyTarget(a), r && this.notifyTarget(a, "mouseleave"), a.target = a.target.parent;
                e.overTargets = null, this.freeEvent(n), this.freeEvent(a)
            }
            this.cursor = null
        }
        mapPointerUp(t) {
            if (!(t instanceof qe)) return;
            const e = performance.now(),
                r = this.createPointerEvent(t);
            if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
            else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                const l = r.button === 2;
                this.dispatchEvent(r, l ? "rightup" : "mouseup")
            }
            const i = this.trackingData(t.pointerId),
                n = this.findMountedTarget(i.pressTargetsByButton[t.button]);
            let a = n;
            if (n && !r.composedPath().includes(n)) {
                let l = n;
                for (; l && !r.composedPath().includes(l);) {
                    if (r.currentTarget = l, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
                    else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                        const h = r.button === 2;
                        this.notifyTarget(r, h ? "rightupoutside" : "mouseupoutside")
                    }
                    l = l.parent
                }
                delete i.pressTargetsByButton[t.button], a = l
            }
            if (a) {
                const l = this.clonePointerEvent(r, "click");
                l.target = a, l.path = null, i.clicksByButton[t.button] || (i.clicksByButton[t.button] = {
                    clickCount: 0,
                    target: l.target,
                    timeStamp: e
                });
                const h = i.clicksByButton[t.button];
                if (h.target === l.target && e - h.timeStamp < 200 ? ++h.clickCount : h.clickCount = 1, h.target = l.target, h.timeStamp = e, l.detail = h.clickCount, l.pointerType === "mouse") {
                    const c = l.button === 2;
                    this.dispatchEvent(l, c ? "rightclick" : "click")
                } else l.pointerType === "touch" && this.dispatchEvent(l, "tap");
                this.dispatchEvent(l, "pointertap"), this.freeEvent(l)
            }
            this.freeEvent(r)
        }
        mapPointerUpOutside(t) {
            if (!(t instanceof qe)) return;
            const e = this.trackingData(t.pointerId),
                r = this.findMountedTarget(e.pressTargetsByButton[t.button]),
                i = this.createPointerEvent(t);
            if (r) {
                let n = r;
                for (; n;) i.currentTarget = n, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch" ? this.notifyTarget(i, "touchendoutside") : (i.pointerType === "mouse" || i.pointerType === "pen") && this.notifyTarget(i, i.button === 2 ? "rightupoutside" : "mouseupoutside"), n = n.parent;
                delete e.pressTargetsByButton[t.button]
            }
            this.freeEvent(i)
        }
        mapWheel(t) {
            if (!(t instanceof Ui)) return;
            const e = this.createWheelEvent(t);
            this.dispatchEvent(e), this.freeEvent(e)
        }
        findMountedTarget(t) {
            if (!t) return null;
            let e = t[0];
            for (let r = 1; r < t.length && t[r].parent === e; r++) e = t[r];
            return e
        }
        createPointerEvent(t, e, r) {
            const i = this.allocateEvent(qe);
            return this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.nativeEvent = t.nativeEvent, i.originalEvent = t, i.target = r != null ? r : this.hitTest(i.global.x, i.global.y), typeof e == "string" && (i.type = e), i
        }
        createWheelEvent(t) {
            const e = this.allocateEvent(Ui);
            return this.copyWheelData(t, e), this.copyMouseData(t, e), this.copyData(t, e), e.nativeEvent = t.nativeEvent, e.originalEvent = t, e.target = this.hitTest(e.global.x, e.global.y), e
        }
        clonePointerEvent(t, e) {
            const r = this.allocateEvent(qe);
            return r.nativeEvent = t.nativeEvent, r.originalEvent = t.originalEvent, this.copyPointerData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.target = t.target, r.path = t.composedPath().slice(), r.type = e != null ? e : r.type, r
        }
        copyWheelData(t, e) {
            e.deltaMode = t.deltaMode, e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ
        }
        copyPointerData(t, e) {
            t instanceof qe && e instanceof qe && (e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist)
        }
        copyMouseData(t, e) {
            t instanceof ls && e instanceof ls && (e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.copyFrom(t.client), e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.copyFrom(t.movement), e.screen.copyFrom(t.screen), e.global.copyFrom(t.global))
        }
        copyData(t, e) {
            e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.detail = t.detail, e.view = t.view, e.which = t.which, e.layer.copyFrom(t.layer), e.page.copyFrom(t.page)
        }
        trackingData(t) {
            return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            }), this.mappingState.trackingData[t]
        }
        allocateEvent(t) {
            this.eventPool.has(t) || this.eventPool.set(t, []);
            const e = this.eventPool.get(t).pop() || new t(this);
            return e.eventPhase = e.NONE, e.currentTarget = null, e.path = null, e.target = null, e
        }
        freeEvent(t) {
            if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
            const e = t.constructor;
            this.eventPool.has(e) || this.eventPool.set(e, []), this.eventPool.get(e).push(t)
        }
        notifyListeners(t, e) {
            const r = t.currentTarget._events[e];
            if (r)
                if ("fn" in r) r.once && t.currentTarget.removeListener(e, r.fn, void 0, !0), r.fn.call(r.context, t);
                else
                    for (let i = 0, n = r.length; i < n && !t.propagationImmediatelyStopped; i++) r[i].once && t.currentTarget.removeListener(e, r[i].fn, void 0, !0), r[i].fn.call(r[i].context, t)
        }
    };
    const ew = 1,
        rw = {
            touchstart: "pointerdown",
            touchend: "pointerup",
            touchendoutside: "pointerupoutside",
            touchmove: "pointermove",
            touchcancel: "pointercancel"
        };
    Bl = class {
        constructor(t) {
            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new Zd(null), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new qe(null), this.rootWheelEvent = new Ui(null), this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            }, this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
        }
        init() {
            const {
                view: t,
                resolution: e
            } = this.renderer;
            this.setTargetElement(t), this.resolution = e
        }
        resolutionChange(t) {
            this.resolution = t
        }
        destroy() {
            this.setTargetElement(null), this.renderer = null
        }
        setCursor(t) {
            t = t || "default";
            let e = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (e = !1), this.currentCursor === t) return;
            this.currentCursor = t;
            const r = this.cursorStyles[t];
            if (r) switch (typeof r) {
                case "string":
                    e && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(t);
                    break;
                case "object":
                    e && Object.assign(this.domElement.style, r);
                    break
            } else e && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
        }
        onPointerDown(t) {
            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
            const e = this.normalizeToPointerData(t);
            this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
            for (let r = 0, i = e.length; r < i; r++) {
                const n = e[r],
                    a = this.bootstrapEvent(this.rootPointerEvent, n);
                this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerMove(t) {
            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
            const e = this.normalizeToPointerData(t);
            for (let r = 0, i = e.length; r < i; r++) {
                const n = this.bootstrapEvent(this.rootPointerEvent, e[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerUp(t) {
            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
            let e = t.target;
            t.composedPath && t.composedPath().length > 0 && (e = t.composedPath()[0]);
            const r = e !== this.domElement ? "outside" : "",
                i = this.normalizeToPointerData(t);
            for (let n = 0, a = i.length; n < a; n++) {
                const l = this.bootstrapEvent(this.rootPointerEvent, i[n]);
                l.type += r, this.rootBoundary.mapEvent(l)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerOverOut(t) {
            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
            const e = this.normalizeToPointerData(t);
            for (let r = 0, i = e.length; r < i; r++) {
                const n = this.bootstrapEvent(this.rootPointerEvent, e[r]);
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(t) {
            const e = this.normalizeWheelEvent(t);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(e)
        }
        setTargetElement(t) {
            this.removeEvents(), this.domElement = t, this.addEvents()
        }
        addEvents() {
            if (this.eventsAdded || !this.domElement) return;
            const t = this.domElement.style;
            t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)), this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }), this.eventsAdded = !0
        }
        removeEvents() {
            if (!this.eventsAdded || !this.domElement) return;
            const t = this.domElement.style;
            globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1
        }
        mapPositionToPoint(t, e, r) {
            let i;
            this.domElement.parentElement ? i = this.domElement.getBoundingClientRect() : i = {
                x: 0,
                y: 0,
                width: this.domElement.width,
                height: this.domElement.height,
                left: 0,
                top: 0
            };
            const n = 1 / this.resolution;
            t.x = (e - i.left) * (this.domElement.width / i.width) * n, t.y = (r - i.top) * (this.domElement.height / i.height) * n
        }
        normalizeToPointerData(t) {
            const e = [];
            if (this.supportsTouchEvents && t instanceof TouchEvent)
                for (let r = 0, i = t.changedTouches.length; r < i; r++) {
                    const n = t.changedTouches[r];
                    typeof n.button > "u" && (n.button = 0), typeof n.buttons > "u" && (n.buttons = 1), typeof n.isPrimary > "u" && (n.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof n.width > "u" && (n.width = n.radiusX || 1), typeof n.height > "u" && (n.height = n.radiusY || 1), typeof n.tiltX > "u" && (n.tiltX = 0), typeof n.tiltY > "u" && (n.tiltY = 0), typeof n.pointerType > "u" && (n.pointerType = "touch"), typeof n.pointerId > "u" && (n.pointerId = n.identifier || 0), typeof n.pressure > "u" && (n.pressure = n.force || .5), typeof n.twist > "u" && (n.twist = 0), typeof n.tangentialPressure > "u" && (n.tangentialPressure = 0), typeof n.layerX > "u" && (n.layerX = n.offsetX = n.clientX), typeof n.layerY > "u" && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, n.type = t.type, e.push(n)
                } else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
                    const r = t;
                    typeof r.isPrimary > "u" && (r.isPrimary = !0), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = ew), typeof r.pressure > "u" && (r.pressure = .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = !0, e.push(r)
                } else e.push(t);
            return e
        }
        normalizeWheelEvent(t) {
            const e = this.rootWheelEvent;
            return this.transferMouseData(e, t), e.deltaX = t.deltaX, e.deltaY = t.deltaY, e.deltaZ = t.deltaZ, e.deltaMode = t.deltaMode, this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.nativeEvent = t, e.type = t.type, e
        }
        bootstrapEvent(t, e) {
            return t.originalEvent = null, t.nativeEvent = e, t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist, this.transferMouseData(t, e), this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = e.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = rw[t.type] || t.type), t
        }
        transferMouseData(t, e) {
            t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.x = e.clientX, t.client.y = e.clientY, t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.x = e.movementX, t.movement.y = e.movementY, t.page.x = e.pageX, t.page.y = e.pageY, t.relatedTarget = null, t.shiftKey = e.shiftKey
        }
    }, Bl.extension = {
        name: "events",
        type: [Z.RendererSystem, Z.CanvasRendererSystem]
    }, lt.add(Bl), op = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        interactive: !1,
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(t, e, r) {
            const i = typeof r == "boolean" && r || typeof r == "object" && r.capture,
                n = typeof e == "function" ? void 0 : e;
            t = i ? `${t}capture` : t, e = typeof e == "function" ? e : e.handleEvent, this.on(t, e, n)
        },
        removeEventListener(t, e, r) {
            const i = typeof r == "boolean" && r || typeof r == "object" && r.capture,
                n = typeof e == "function" ? void 0 : e;
            t = i ? `${t}capture` : t, e = typeof e == "function" ? e : e.handleEvent, this.off(t, e, n)
        },
        dispatchEvent(t) {
            if (!(t instanceof os)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
            return t.defaultPrevented = !1, t.path = null, t.target = this, t.manager.dispatchEvent(t), !t.defaultPrevented
        }
    }, Ft.mixin(op), Ip = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        accessibleType: "button",
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        renderId: -1
    }, Ft.mixin(Ip);
    const iw = 9,
        go = 100,
        nw = 0,
        sw = 0,
        qm = 2,
        Qm = 1,
        aw = -1e3,
        ow = -1e3,
        lw = 2;
    Sh = class {
        constructor(t) {
            this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (gr.tablet || gr.phone) && this.createTouchHook();
            const e = document.createElement("div");
            e.style.width = `${go}px`, e.style.height = `${go}px`, e.style.position = "absolute", e.style.top = `${nw}px`, e.style.left = `${sw}px`, e.style.zIndex = qm.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
        }
        get isActive() {
            return this._isActive
        }
        get isMobileAccessibility() {
            return this._isMobileAccessibility
        }
        createTouchHook() {
            const t = document.createElement("button");
            t.style.width = `${Qm}px`, t.style.height = `${Qm}px`, t.style.position = "absolute", t.style.top = `${aw}px`, t.style.left = `${ow}px`, t.style.zIndex = lw.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
                this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook()
            }), document.body.appendChild(t), this._hookDiv = t
        }
        destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
        }
        activate() {
            var t;
            this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) == null || t.appendChild(this.div))
        }
        deactivate() {
            var t;
            !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) == null || t.removeChild(this.div))
        }
        updateAccessibleObjects(t) {
            if (!t.visible || !t.accessibleChildren) return;
            t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
            const e = t.children;
            if (e)
                for (let r = 0; r < e.length; r++) this.updateAccessibleObjects(e[r])
        }
        update() {
            const t = performance.now();
            if (gr.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency, !this.renderer.renderingToScreen)) return;
            this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
            const {
                x: e,
                y: r,
                width: i,
                height: n
            } = this.renderer.view.getBoundingClientRect(), {
                width: a,
                height: l,
                resolution: h
            } = this.renderer, c = i / a * h, d = n / l * h;
            let f = this.div;
            f.style.left = `${e}px`, f.style.top = `${r}px`, f.style.width = `${a}px`, f.style.height = `${l}px`;
            for (let g = 0; g < this.children.length; g++) {
                const y = this.children[g];
                if (y.renderId !== this.renderId) y._accessibleActive = !1, Yi(this.children, g, 1), this.div.removeChild(y._accessibleDiv), this.pool.push(y._accessibleDiv), y._accessibleDiv = null, g--;
                else {
                    f = y._accessibleDiv;
                    let x = y.hitArea;
                    const _ = y.worldTransform;
                    y.hitArea ? (f.style.left = `${(_.tx+x.x*_.a)*c}px`, f.style.top = `${(_.ty+x.y*_.d)*d}px`, f.style.width = `${x.width*_.a*c}px`, f.style.height = `${x.height*_.d*d}px`) : (x = y.getBounds(), this.capHitArea(x), f.style.left = `${x.x*c}px`, f.style.top = `${x.y*d}px`, f.style.width = `${x.width*c}px`, f.style.height = `${x.height*d}px`, f.title !== y.accessibleTitle && y.accessibleTitle !== null && (f.title = y.accessibleTitle), f.getAttribute("aria-label") !== y.accessibleHint && y.accessibleHint !== null && f.setAttribute("aria-label", y.accessibleHint)), (y.accessibleTitle !== f.title || y.tabIndex !== f.tabIndex) && (f.title = y.accessibleTitle, f.tabIndex = y.tabIndex, this.debug && this.updateDebugHTML(f))
                }
            }
            this.renderId++
        }
        updateDebugHTML(t) {
            t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
        }
        capHitArea(t) {
            t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
            const {
                width: e,
                height: r
            } = this.renderer;
            t.x + t.width > e && (t.width = e - t.x), t.y + t.height > r && (t.height = r - t.y)
        }
        addChild(t) {
            let e = this.pool.pop();
            e || (e = document.createElement("button"), e.style.width = `${go}px`, e.style.height = `${go}px`, e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = qm.toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = `displayObject ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
        }
        _dispatchEvent(t, e) {
            const {
                displayObject: r
            } = t.target, i = this.renderer.events.rootBoundary, n = Object.assign(new os(i), {
                target: r
            });
            i.rootTarget = this.renderer.lastObjectRendered, e.forEach(a => i.dispatchEvent(n, a))
        }
        _onClick(t) {
            this._dispatchEvent(t, ["click", "pointertap", "tap"])
        }
        _onFocus(t) {
            t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"])
        }
        _onFocusOut(t) {
            t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"])
        }
        _onKeyDown(t) {
            t.keyCode === iw && this.activate()
        }
        _onMouseMove(t) {
            t.movementX === 0 && t.movementY === 0 || this.deactivate()
        }
        destroy() {
            this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
        }
    }, Sh.extension = {
        name: "accessibility",
        type: [Z.RendererPlugin, Z.CanvasRendererPlugin]
    }, lt.add(Sh);
    const Lu = class {
        constructor(t) {
            this.stage = new Kt, t = Object.assign({
                forceCanvas: !1
            }, t), this.renderer = vh(t), Lu._plugins.forEach(e => {
                e.init.call(this, t)
            })
        }
        render() {
            this.renderer.render(this.stage)
        }
        get view() {
            return this.renderer.view
        }
        get screen() {
            return this.renderer.screen
        }
        destroy(t, e) {
            const r = Lu._plugins.slice(0);
            r.reverse(), r.forEach(i => {
                i.destroy.call(this)
            }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null
        }
    };
    gn = Lu, gn._plugins = [], lt.handleByList(Z.Application, gn._plugins), ph = class {
        static init(t) {
            Object.defineProperty(this, "resizeTo", {
                set(e) {
                    globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize())
                },
                get() {
                    return this._resizeTo
                }
            }), this.queueResize = () => {
                this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
            }, this.cancelResize = () => {
                this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
            }, this.resize = () => {
                if (!this._resizeTo) return;
                this.cancelResize();
                let e, r;
                if (this._resizeTo === globalThis.window) e = globalThis.innerWidth, r = globalThis.innerHeight;
                else {
                    const {
                        clientWidth: i,
                        clientHeight: n
                    } = this._resizeTo;
                    e = i, r = n
                }
                this.renderer.resize(e, r), this.render()
            }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
        }
        static destroy() {
            globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
        }
    }, ph.extension = Z.Application, lt.add(ph);
    const Km = {
        loader: Z.LoadParser,
        resolver: Z.ResolveParser,
        cache: Z.CacheParser,
        detection: Z.DetectionParser
    };
    lt.handle(Z.Asset, t => {
        const e = t.ref;
        Object.entries(Km).filter(([r]) => !!e[r]).forEach(([r, i]) => {
            var n;
            return lt.add(Object.assign(e[r], {
                extension: (n = e[r].extension) != null ? n : i
            }))
        })
    }, t => {
        const e = t.ref;
        Object.keys(Km).filter(r => !!e[r]).forEach(r => lt.remove(e[r]))
    });
    class hw {
        constructor(e, r = !1) {
            this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = r
        }
        add(e) {
            e.forEach(r => {
                this._assetList.push(r)
            }), this.verbose, this._isActive && !this._isLoading && this._next()
        }
        async _next() {
            if (this._assetList.length && this._isActive) {
                this._isLoading = !0;
                const e = [],
                    r = Math.min(this._assetList.length, this._maxConcurrent);
                for (let i = 0; i < r; i++) e.push(this._assetList.pop());
                await this._loader.load(e), this._isLoading = !1, this._next()
            }
        }
        get active() {
            return this._isActive
        }
        set active(e) {
            this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next())
        }
    }
    _h = function(t, e) {
        if (Array.isArray(e)) {
            for (const r of e)
                if (t.startsWith(`data:${r}`)) return !0;
            return !1
        }
        return t.startsWith(`data:${e}`)
    }, xs = function(t, e) {
        const r = t.split("?")[0],
            i = ce.extname(r).toLowerCase();
        return Array.isArray(e) ? e.includes(i) : i === e
    }, Or = (t, e) => (Array.isArray(t) || (t = [t]), e ? t.map(r => typeof r == "string" ? e(r) : r) : t), Da = (t, e) => {
        const r = e.split("?")[1];
        return r && (t += `?${r}`), t
    };

    function Zm(t, e, r, i, n) {
        const a = e[r];
        for (let l = 0; l < a.length; l++) {
            const h = a[l];
            r < e.length - 1 ? Zm(t.replace(i[r], h), e, r + 1, i, n) : n.push(t.replace(i[r], h))
        }
    }
    Yp = function(t) {
        const e = /\{(.*?)\}/g,
            r = t.match(e),
            i = [];
        if (r) {
            const n = [];
            r.forEach(a => {
                const l = a.substring(1, a.length - 1).split(",");
                n.push(l)
            }), Zm(t, n, 0, r, i)
        } else i.push(t);
        return i
    }, ys = t => !Array.isArray(t);
    class uw {
        constructor() {
            this._parsers = [], this._cache = new Map, this._cacheMap = new Map
        }
        reset() {
            this._cacheMap.clear(), this._cache.clear()
        }
        has(e) {
            return this._cache.has(e)
        }
        get(e) {
            return this._cache.get(e)
        }
        set(e, r) {
            const i = Or(e);
            let n;
            for (let h = 0; h < this.parsers.length; h++) {
                const c = this.parsers[h];
                if (c.test(r)) {
                    n = c.getCacheableAssets(i, r);
                    break
                }
            }
            n || (n = {}, i.forEach(h => {
                n[h] = r
            }));
            const a = Object.keys(n),
                l = {
                    cacheKeys: a,
                    keys: i
                };
            if (i.forEach(h => {
                    this._cacheMap.set(h, l)
                }), a.forEach(h => {
                    this._cache.has(h) && this._cache.get(h), this._cache.set(h, n[h])
                }), r instanceof Q) {
                const h = r;
                i.forEach(c => {
                    h.baseTexture !== Q.EMPTY.baseTexture && mt.addToCache(h.baseTexture, c), Q.addToCache(h, c)
                })
            }
        }
        remove(e) {
            if (this._cacheMap.get(e), !this._cacheMap.has(e)) return;
            const r = this._cacheMap.get(e);
            r.cacheKeys.forEach(i => {
                this._cache.delete(i)
            }), r.keys.forEach(i => {
                this._cacheMap.delete(i)
            })
        }
        get parsers() {
            return this._parsers
        }
    }
    wn = new uw;
    class cw {
        constructor() {
            this._parsers = [], this.promiseCache = {}
        }
        reset() {
            this.promiseCache = {}
        }
        _getLoadPromiseAndParser(e, r) {
            const i = {
                promise: null,
                parser: null
            };
            return i.promise = (async () => {
                var n, a;
                let l = null;
                for (let h = 0; h < this.parsers.length; h++) {
                    const c = this.parsers[h];
                    if (c.load && (n = c.test) != null && n.call(c, e, r, this)) {
                        l = await c.load(e, r, this), i.parser = c;
                        break
                    }
                }
                if (!i.parser) return null;
                for (let h = 0; h < this.parsers.length; h++) {
                    const c = this.parsers[h];
                    c.parse && c.parse && await ((a = c.testParse) == null ? void 0 : a.call(c, l, r, this)) && (l = await c.parse(l, r, this) || l, i.parser = c)
                }
                return l
            })(), i
        }
        async load(e, r) {
            let i = 0;
            const n = {},
                a = ys(e),
                l = Or(e, d => ({
                    src: d
                })),
                h = l.length,
                c = l.map(async d => {
                    const f = ce.toAbsolute(d.src);
                    if (!n[d.src]) try {
                        this.promiseCache[f] || (this.promiseCache[f] = this._getLoadPromiseAndParser(f, d)), n[d.src] = await this.promiseCache[f].promise, r && r(++i / h)
                    } catch (g) {
                        throw delete this.promiseCache[f], delete n[d.src], new Error(`[Loader.load] Failed to load ${f}.
${g}`)
                    }
                });
            return await Promise.all(c), a ? n[l[0].src] : n
        }
        async unload(e) {
            const r = Or(e, i => ({
                src: i
            })).map(async i => {
                var n, a;
                const l = ce.toAbsolute(i.src),
                    h = this.promiseCache[l];
                if (h) {
                    const c = await h.promise;
                    (a = (n = h.parser) == null ? void 0 : n.unload) == null || a.call(n, c, i, this), delete this.promiseCache[l]
                }
            });
            await Promise.all(r)
        }
        get parsers() {
            return this._parsers
        }
    }
    pr = (t => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(pr || {}), Np = {
        extension: {
            type: Z.LoadParser,
            priority: pr.Low
        },
        test(t) {
            return ce.extname(t).toLowerCase() === ".json"
        },
        async load(t) {
            return await (await et.ADAPTER.fetch(t)).json()
        }
    }, lt.add(Np), Bp = {
        extension: {
            type: Z.LoadParser,
            priority: pr.Low
        },
        test(t) {
            return ce.extname(t).toLowerCase() === ".txt"
        },
        async load(t) {
            return await (await et.ADAPTER.fetch(t)).text()
        }
    }, lt.add(Bp);
    const dw = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
        pw = [".ttf", ".otf", ".woff", ".woff2"],
        fw = ["font/ttf", "font/otf", "font/woff", "font/woff2"];
    nf = function(t) {
        const e = ce.extname(t);
        return ce.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(r => r.charAt(0).toUpperCase() + r.slice(1)).join(" ")
    }, kp = {
        extension: {
            type: Z.LoadParser,
            priority: pr.Low
        },
        test(t) {
            return _h(t, fw) || xs(t, pw)
        },
        async load(t, e) {
            var l, h, c;
            var r, i, n;
            const a = et.ADAPTER.getFontFaceSet();
            if (a) {
                const d = [],
                    f = (l = (r = e.data) == null ? void 0 : r.family) != null ? l : nf(t),
                    g = (h = (n = (i = e.data) == null ? void 0 : i.weights) == null ? void 0 : n.filter(x => dw.includes(x))) != null ? h : ["normal"],
                    y = (c = e.data) != null ? c : {};
                for (let x = 0; x < g.length; x++) {
                    const _ = g[x],
                        E = new FontFace(f, `url(${encodeURI(t)})`, Qd(Kr({}, y), {
                            weight: _
                        }));
                    await E.load(), a.add(E), d.push(E)
                }
                return d.length === 1 ? d[0] : d
            }
            return null
        },
        unload(t) {
            (Array.isArray(t) ? t : [t]).forEach(e => et.ADAPTER.getFontFaceSet().delete(e))
        }
    }, lt.add(kp);
    let Jm = 0,
        Bu;
    const mw = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",
        gw = {
            id: "checkImageBitmap",
            code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${mw}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
        },
        yw = {
            id: "loadImageBitmap",
            code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
        };
    let ku;
    class vw {
        constructor() {
            this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {}
        }
        isImageBitmapSupported() {
            return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(e => {
                const r = URL.createObjectURL(new Blob([gw.code], {
                        type: "application/javascript"
                    })),
                    i = new Worker(r);
                i.addEventListener("message", n => {
                    i.terminate(), URL.revokeObjectURL(r), e(n.data)
                })
            }), this._isImageBitmapSupported)
        }
        loadImageBitmap(e) {
            return this._run("loadImageBitmap", [e])
        }
        async _initWorkers() {
            this._initialized || (this._initialized = !0)
        }
        getWorker() {
            Bu === void 0 && (Bu = navigator.hardwareConcurrency || 4);
            let e = this.workerPool.pop();
            return !e && this._createdWorkers < Bu && (ku || (ku = URL.createObjectURL(new Blob([yw.code], {
                type: "application/javascript"
            }))), this._createdWorkers++, e = new Worker(ku), e.addEventListener("message", r => {
                this.complete(r.data), this.returnWorker(r.target), this.next()
            })), e
        }
        returnWorker(e) {
            this.workerPool.push(e)
        }
        complete(e) {
            e.error !== void 0 ? this.resolveHash[e.uuid].reject(e.error) : this.resolveHash[e.uuid].resolve(e.data), this.resolveHash[e.uuid] = null
        }
        async _run(e, r) {
            await this._initWorkers();
            const i = new Promise((n, a) => {
                this.queue.push({
                    id: e,
                    arguments: r,
                    resolve: n,
                    reject: a
                })
            });
            return this.next(), i
        }
        next() {
            if (!this.queue.length) return;
            const e = this.getWorker();
            if (!e) return;
            const r = this.queue.pop(),
                i = r.id;
            this.resolveHash[Jm] = {
                resolve: r.resolve,
                reject: r.reject
            }, e.postMessage({
                data: r.arguments,
                uuid: Jm++,
                id: i
            })
        }
    }
    const tg = new vw;
    _s = function(t, e, r) {
        const i = new Q(t);
        return i.baseTexture.on("dispose", () => {
            delete e.promiseCache[r]
        }), i
    };
    const xw = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
        _w = ["image/jpeg", "image/png", "image/webp", "image/avif"];
    Dp = async function(t) {
        const e = await et.ADAPTER.fetch(t);
        if (!e.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`);
        const r = await e.blob();
        return await createImageBitmap(r)
    }, Tn = {
        extension: {
            type: Z.LoadParser,
            priority: pr.High
        },
        config: {
            preferWorkers: !0
        },
        test(t) {
            return _h(t, _w) || xs(t, xw)
        },
        async load(t, e, r) {
            let i = null;
            globalThis.createImageBitmap ? this.config.preferWorkers && await tg.isImageBitmapSupported() ? i = await tg.loadImageBitmap(t) : i = await Dp(t) : i = await new Promise(a => {
                i = new Image, i.crossOrigin = "anonymous", i.src = t, i.complete ? a(i) : i.onload = () => {
                    a(i)
                }
            });
            const n = new mt(i, Kr({
                resolution: ni(t)
            }, e.data));
            return n.resource.src = t, _s(n, r, t)
        },
        unload(t) {
            t.destroy(!0)
        }
    }, lt.add(Tn), Lp = {
        extension: {
            type: Z.LoadParser,
            priority: pr.High
        },
        test(t) {
            return ce.extname(t).toLowerCase() === ".svg"
        },
        async testParse(t) {
            return En.test(t)
        },
        async parse(t, e, r) {
            var i, n, a;
            const l = new En(t, (i = e == null ? void 0 : e.data) == null ? void 0 : i.resourceOptions),
                h = new mt(l, Kr({
                    resolution: ni(t)
                }, e == null ? void 0 : e.data));
            h.resource.src = t;
            const c = _s(h, r, t);
            return (a = (n = e == null ? void 0 : e.data) == null ? void 0 : n.resourceOptions) != null && a.autoLoad || await l.load(), c
        },
        async load(t, e) {
            return (await et.ADAPTER.fetch(t)).text()
        },
        unload: Tn.unload
    }, lt.add(Lp);
    class bw {
        constructor() {
            this._defaultBundleIdentifierOptions = {
                connector: "-",
                createBundleAssetId: (e, r) => `${e}${this._bundleIdConnector}${r}`,
                extractAssetIdFromBundle: (e, r) => r.replace(`${e}${this._bundleIdConnector}`, "")
            }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
        }
        setBundleIdentifier(e) {
            var r, i, n;
            if (this._bundleIdConnector = (r = e.connector) != null ? r : this._bundleIdConnector, this._createBundleAssetId = (i = e.createBundleAssetId) != null ? i : this._createBundleAssetId, this._extractAssetIdFromBundle = (n = e.extractAssetIdFromBundle) != null ? n : this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
        }
        prefer(...e) {
            e.forEach(r => {
                this._preferredOrder.push(r), r.priority || (r.priority = Object.keys(r.params))
            }), this._resolverHash = {}
        }
        set basePath(e) {
            this._basePath = e
        }
        get basePath() {
            return this._basePath
        }
        set rootPath(e) {
            this._rootPath = e
        }
        get rootPath() {
            return this._rootPath
        }
        get parsers() {
            return this._parsers
        }
        reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
        }
        setDefaultSearchParams(e) {
            if (typeof e == "string") this._defaultSearchParams = e;
            else {
                const r = e;
                this._defaultSearchParams = Object.keys(r).map(i => `${encodeURIComponent(i)}=${encodeURIComponent(r[i])}`).join("&")
            }
        }
        addManifest(e) {
            this._manifest, this._manifest = e, e.bundles.forEach(r => {
                this.addBundle(r.name, r.assets)
            })
        }
        addBundle(e, r) {
            const i = [];
            Array.isArray(r) ? r.forEach(n => {
                if (typeof n.name == "string") {
                    const a = this._createBundleAssetId(e, n.name);
                    i.push(a), this.add([n.name, a], n.srcs, n.data)
                } else {
                    const a = n.name.map(l => this._createBundleAssetId(e, l));
                    a.forEach(l => {
                        i.push(l)
                    }), this.add([...n.name, ...a], n.srcs)
                }
            }) : Object.keys(r).forEach(n => {
                i.push(this._createBundleAssetId(e, n)), this.add([n, this._createBundleAssetId(e, n)], r[n])
            }), this._bundles[e] = i
        }
        add(e, r, i) {
            const n = Or(e);
            n.forEach(l => {
                this.hasKey(l)
            }), Array.isArray(r) || (typeof r == "string" ? r = Yp(r) : r = [r]);
            const a = r.map(l => {
                var c;
                let h = l;
                if (typeof l == "string") {
                    let d = !1;
                    for (let f = 0; f < this._parsers.length; f++) {
                        const g = this._parsers[f];
                        if (g.test(l)) {
                            h = g.parse(l), d = !0;
                            break
                        }
                    }
                    d || (h = {
                        src: l
                    })
                }
                return h.format || (h.format = h.src.split(".").pop()), h.alias || (h.alias = n), (this._basePath || this._rootPath) && (h.src = ce.toAbsolute(h.src, this._basePath, this._rootPath)), h.src = this._appendDefaultSearchParams(h.src), h.data = (c = h.data) != null ? c : i, h
            });
            n.forEach(l => {
                this._assetMap[l] = a
            })
        }
        resolveBundle(e) {
            const r = ys(e);
            e = Or(e);
            const i = {};
            return e.forEach(n => {
                const a = this._bundles[n];
                if (a) {
                    const l = this.resolve(a),
                        h = {};
                    for (const c in l) {
                        const d = l[c];
                        h[this._extractAssetIdFromBundle(n, c)] = d
                    }
                    i[n] = h
                }
            }), r ? i[e[0]] : i
        }
        resolveUrl(e) {
            const r = this.resolve(e);
            if (typeof e != "string") {
                const i = {};
                for (const n in r) i[n] = r[n].src;
                return i
            }
            return r.src
        }
        resolve(e) {
            const r = ys(e);
            e = Or(e);
            const i = {};
            return e.forEach(n => {
                var a;
                if (!this._resolverHash[n])
                    if (this._assetMap[n]) {
                        let l = this._assetMap[n];
                        const h = this._getPreferredOrder(l),
                            c = l[0];
                        h == null || h.priority.forEach(d => {
                            h.params[d].forEach(f => {
                                const g = l.filter(y => y[d] ? y[d] === f : !1);
                                g.length && (l = g)
                            })
                        }), this._resolverHash[n] = (a = l[0]) != null ? a : c
                    } else {
                        let l = n;
                        (this._basePath || this._rootPath) && (l = ce.toAbsolute(l, this._basePath, this._rootPath)), l = this._appendDefaultSearchParams(l), this._resolverHash[n] = {
                            src: l
                        }
                    }
                i[n] = this._resolverHash[n]
            }), r ? i[e[0]] : i
        }
        hasKey(e) {
            return !!this._assetMap[e]
        }
        hasBundle(e) {
            return !!this._bundles[e]
        }
        _getPreferredOrder(e) {
            for (let r = 0; r < e.length; r++) {
                const i = e[0],
                    n = this._preferredOrder.find(a => a.params.format.includes(i.format));
                if (n) return n
            }
            return this._preferredOrder[0]
        }
        _appendDefaultSearchParams(e) {
            if (!this._defaultSearchParams) return e;
            const r = /\?/.test(e) ? "&" : "?";
            return `${e}${r}${this._defaultSearchParams}`
        }
    }
    Jd = class {
        constructor() {
            this._detections = [], this._initialized = !1, this.resolver = new bw, this.loader = new cw, this.cache = wn, this._backgroundLoader = new hw(this.loader), this._backgroundLoader.active = !0, this.reset()
        }
        async init(t = {}) {
            var h;
            var e, r, i;
            if (this._initialized) return;
            if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
                let c = t.manifest;
                typeof c == "string" && (c = await this.load(c)), this.resolver.addManifest(c)
            }
            const n = (h = (e = t.texturePreference) == null ? void 0 : e.resolution) != null ? h : 1,
                a = typeof n == "number" ? [n] : n;
            let l = [];
            if ((r = t.texturePreference) != null && r.format) {
                const c = (i = t.texturePreference) == null ? void 0 : i.format;
                l = typeof c == "string" ? [c] : c;
                for (const d of this._detections) await d.test() || (l = await d.remove(l))
            } else
                for (const c of this._detections) await c.test() && (l = await c.add(l));
            this.resolver.prefer({
                params: {
                    format: l,
                    resolution: a
                }
            })
        }
        add(t, e, r) {
            this.resolver.add(t, e, r)
        }
        async load(t, e) {
            this._initialized || await this.init();
            const r = ys(t),
                i = Or(t).map(l => typeof l != "string" ? (this.resolver.add(l.src, l), l.src) : (this.resolver.hasKey(l) || this.resolver.add(l, l), l)),
                n = this.resolver.resolve(i),
                a = await this._mapLoadToResolve(n, e);
            return r ? a[i[0]] : a
        }
        addBundle(t, e) {
            this.resolver.addBundle(t, e)
        }
        async loadBundle(t, e) {
            this._initialized || await this.init();
            let r = !1;
            typeof t == "string" && (r = !0, t = [t]);
            const i = this.resolver.resolveBundle(t),
                n = {},
                a = Object.keys(i);
            let l = 0,
                h = 0;
            const c = () => {
                    e == null || e(++l / h)
                },
                d = a.map(f => {
                    const g = i[f];
                    return h += Object.keys(g).length, this._mapLoadToResolve(g, c).then(y => {
                        n[f] = y
                    })
                });
            return await Promise.all(d), r ? n[t[0]] : n
        }
        async backgroundLoad(t) {
            this._initialized || await this.init(), typeof t == "string" && (t = [t]);
            const e = this.resolver.resolve(t);
            this._backgroundLoader.add(Object.values(e))
        }
        async backgroundLoadBundle(t) {
            this._initialized || await this.init(), typeof t == "string" && (t = [t]);
            const e = this.resolver.resolveBundle(t);
            Object.values(e).forEach(r => {
                this._backgroundLoader.add(Object.values(r))
            })
        }
        reset() {
            this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
        }
        get(t) {
            if (typeof t == "string") return wn.get(t);
            const e = {};
            for (let r = 0; r < t.length; r++) e[r] = wn.get(t[r]);
            return e
        }
        async _mapLoadToResolve(t, e) {
            const r = Object.values(t),
                i = Object.keys(t);
            this._backgroundLoader.active = !1;
            const n = await this.loader.load(r, e);
            this._backgroundLoader.active = !0;
            const a = {};
            return r.forEach((l, h) => {
                const c = n[l.src],
                    d = [l.src];
                l.alias && d.push(...l.alias), a[i[h]] = c, wn.set(d, c)
            }), a
        }
        async unload(t) {
            this._initialized || await this.init();
            const e = Or(t).map(i => typeof i != "string" ? i.src : i),
                r = this.resolver.resolve(e);
            await this._unloadFromResolved(r)
        }
        async unloadBundle(t) {
            this._initialized || await this.init(), t = Or(t);
            const e = this.resolver.resolveBundle(t),
                r = Object.keys(e).map(i => this._unloadFromResolved(e[i]));
            await Promise.all(r)
        }
        async _unloadFromResolved(t) {
            const e = Object.values(t);
            e.forEach(r => {
                wn.remove(r.src)
            }), await this.loader.unload(e)
        }
        get detections() {
            return this._detections
        }
        get preferWorkers() {
            return Tn.config.preferWorkers
        }
        set preferWorkers(t) {
            Tn.config.preferWorkers = t
        }
    }, mn = new Jd, lt.handleByList(Z.LoadParser, mn.loader.parsers).handleByList(Z.ResolveParser, mn.resolver.parsers).handleByList(Z.CacheParser, mn.cache.parsers).handleByList(Z.DetectionParser, mn.detections), $p = {
        extension: Z.CacheParser,
        test: t => Array.isArray(t) && t.every(e => e instanceof Q),
        getCacheableAssets: (t, e) => {
            const r = {};
            return t.forEach(i => {
                e.forEach((n, a) => {
                    r[i + (a === 0 ? "" : a + 1)] = n
                })
            }), r
        }
    }, lt.add($p), Kp = {
        extension: {
            type: Z.DetectionParser,
            priority: 1
        },
        test: async () => {
            if (!globalThis.createImageBitmap) return !1;
            const t = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",
                e = await et.ADAPTER.fetch(t).then(r => r.blob());
            return createImageBitmap(e).then(() => !0, () => !1)
        },
        add: async t => [...t, "avif"],
        remove: async t => t.filter(e => e !== "avif")
    }, lt.add(Kp), tf = {
        extension: {
            type: Z.DetectionParser,
            priority: 0
        },
        test: async () => {
            if (!globalThis.createImageBitmap) return !1;
            const t = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",
                e = await et.ADAPTER.fetch(t).then(r => r.blob());
            return createImageBitmap(e).then(() => !0, () => !1)
        },
        add: async t => [...t, "webp"],
        remove: async t => t.filter(e => e !== "webp")
    }, lt.add(tf);
    let Fu;
    Fu = ["png", "jpg", "jpeg"], Jp = {
        extension: {
            type: Z.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async t => [...t, ...Fu],
        remove: async t => t.filter(e => !Fu.includes(e))
    }, lt.add(Jp), zp = {
        extension: Z.ResolveParser,
        test: Tn.test,
        parse: t => {
            var r;
            var e;
            return {
                resolution: parseFloat((r = (e = et.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) != null ? r : "1"),
                format: t.split(".").pop(),
                src: t
            }
        }
    }, lt.add(zp), Oe = (t => (t[t.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t[t.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t[t.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t[t.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t[t.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t[t.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t[t.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t[t.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t[t.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t[t.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t[t.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", t[t.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t[t.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t[t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t[t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t[t.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t[t.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t[t.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", t[t.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", t))(Oe || {}), ds = {
        33776: .5,
        33777: .5,
        33778: 1,
        33779: 1,
        35916: .5,
        35917: .5,
        35918: 1,
        35919: 1,
        37488: .5,
        37489: .5,
        37490: 1,
        37491: 1,
        37492: .5,
        37496: 1,
        37493: .5,
        37497: 1,
        37494: .5,
        37495: .5,
        35840: .5,
        35842: .5,
        35841: .25,
        35843: .25,
        36196: .5,
        35986: .5,
        35986: 1,
        34798: 1,
        37808: 1
    };
    let si, Fn;

    function eg() {
        Fn = {
            s3tc: si.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: si.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: si.getExtension("WEBGL_compressed_texture_etc"),
            etc1: si.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: si.getExtension("WEBGL_compressed_texture_pvrtc") || si.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: si.getExtension("WEBGL_compressed_texture_atc"),
            astc: si.getExtension("WEBGL_compressed_texture_astc")
        }
    }
    Zp = {
        extension: {
            type: Z.DetectionParser,
            priority: 2
        },
        test: async () => {
            const t = et.ADAPTER.createCanvas().getContext("webgl");
            return t ? (si = t, !0) : !1
        },
        add: async t => {
            Fn || eg();
            const e = [];
            for (const r in Fn) Fn[r] && e.push(r);
            return [...e, ...t]
        },
        remove: async t => (Fn || eg(), t.filter(e => !(e in Fn)))
    }, lt.add(Zp), cf = class extends yn {
        constructor(t, e = {
            width: 1,
            height: 1,
            autoLoad: !0
        }) {
            let r, i;
            typeof t == "string" ? (r = t, i = new Uint8Array) : (r = null, i = t), super(i, e), this.origin = r, this.buffer = i ? new Ia(i) : null, this.origin && e.autoLoad !== !1 && this.load(), i != null && i.length && (this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData))
        }
        onBlobLoaded(t) {}
        async load() {
            const t = await (await (await fetch(this.origin)).blob()).arrayBuffer();
            return this.data = new Uint32Array(t), this.buffer = new Ia(t), this.loaded = !0, this.onBlobLoaded(t), this.update(), this
        }
    }, ji = class extends cf {
        constructor(t, e) {
            super(t, e), this.format = e.format, this.levels = e.levels || 1, this._width = e.width, this._height = e.height, this._extension = ji._formatToExtension(this.format), (e.levelBuffers || this.buffer) && (this._levelBuffers = e.levelBuffers || ji._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
        }
        upload(t, e, r) {
            const i = t.gl;
            if (!t.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
            if (!this._levelBuffers) return !1;
            for (let n = 0, a = this.levels; n < a; n++) {
                const {
                    levelID: l,
                    levelWidth: h,
                    levelHeight: c,
                    levelBuffer: d
                } = this._levelBuffers[n];
                i.compressedTexImage2D(i.TEXTURE_2D, l, this.format, h, c, 0, d)
            }
            return !0
        }
        onBlobLoaded() {
            this._levelBuffers = ji._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
        }
        static _formatToExtension(t) {
            if (t >= 33776 && t <= 33779) return "s3tc";
            if (t >= 37488 && t <= 37497) return "etc";
            if (t >= 35840 && t <= 35843) return "pvrtc";
            if (t >= 36196) return "etc1";
            if (t >= 35986 && t <= 34798) return "atc";
            throw new Error("Invalid (compressed) texture format given!")
        }
        static _createLevelBuffers(t, e, r, i, n, a, l) {
            const h = new Array(r);
            let c = t.byteOffset,
                d = a,
                f = l,
                g = d + i - 1 & ~(i - 1),
                y = f + n - 1 & ~(n - 1),
                x = g * y * ds[e];
            for (let _ = 0; _ < r; _++) h[_] = {
                levelID: _,
                levelWidth: r > 1 ? d : g,
                levelHeight: r > 1 ? f : y,
                levelBuffer: new Uint8Array(t.buffer, c, x)
            }, c += x, d = d >> 1 || 1, f = f >> 1 || 1, g = d + i - 1 & ~(i - 1), y = f + n - 1 & ~(n - 1), x = g * y * ds[e];
            return h
        }
    };
    const Uu = 4,
        yo = 124,
        Ew = 32,
        rg = 20,
        Tw = 542327876,
        vo = {
            SIZE: 1,
            FLAGS: 2,
            HEIGHT: 3,
            WIDTH: 4,
            MIPMAP_COUNT: 7,
            PIXEL_FORMAT: 19
        },
        ww = {
            SIZE: 0,
            FLAGS: 1,
            FOURCC: 2,
            RGB_BITCOUNT: 3,
            R_BIT_MASK: 4,
            G_BIT_MASK: 5,
            B_BIT_MASK: 6,
            A_BIT_MASK: 7
        },
        xo = {
            DXGI_FORMAT: 0,
            RESOURCE_DIMENSION: 1,
            MISC_FLAG: 2,
            ARRAY_SIZE: 3,
            MISC_FLAGS2: 4
        },
        Sw = 1,
        Aw = 2,
        Pw = 4,
        Cw = 64,
        Iw = 512,
        Rw = 131072,
        Mw = 827611204,
        Dw = 861165636,
        Nw = 894720068,
        Ow = 808540228,
        Lw = 4,
        Bw = {
            [Mw]: Oe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            [Dw]: Oe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            [Nw]: Oe.COMPRESSED_RGBA_S3TC_DXT5_EXT
        },
        kw = {
            70: Oe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            71: Oe.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            73: Oe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            74: Oe.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            76: Oe.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            77: Oe.COMPRESSED_RGBA_S3TC_DXT5_EXT,
            72: Oe.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            75: Oe.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            78: Oe.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        };
    Fp = function(t) {
        const e = new Uint32Array(t);
        if (e[0] !== Tw) throw new Error("Invalid DDS file magic word");
        const r = new Uint32Array(t, 0, yo / Uint32Array.BYTES_PER_ELEMENT),
            i = r[vo.HEIGHT],
            n = r[vo.WIDTH],
            a = r[vo.MIPMAP_COUNT],
            l = new Uint32Array(t, vo.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, Ew / Uint32Array.BYTES_PER_ELEMENT),
            h = l[Sw];
        if (h & Pw) {
            const c = l[ww.FOURCC];
            if (c !== Ow) {
                const S = Bw[c],
                    T = Uu + yo,
                    P = new Uint8Array(t, T);
                return [new ji(P, {
                    format: S,
                    width: n,
                    height: i,
                    levels: a
                })]
            }
            const d = Uu + yo,
                f = new Uint32Array(e.buffer, d, rg / Uint32Array.BYTES_PER_ELEMENT),
                g = f[xo.DXGI_FORMAT],
                y = f[xo.RESOURCE_DIMENSION],
                x = f[xo.MISC_FLAG],
                _ = f[xo.ARRAY_SIZE],
                E = kw[g];
            if (E === void 0) throw new Error(`DDSParser cannot parse texture data with DXGI format ${g}`);
            if (x === Lw) throw new Error("DDSParser does not support cubemap textures");
            if (y === 6) throw new Error("DDSParser does not supported 3D texture data");
            const w = new Array,
                I = Uu + yo + rg;
            if (_ === 1) w.push(new Uint8Array(t, I));
            else {
                const S = ds[E];
                let T = 0,
                    P = n,
                    z = i;
                for (let O = 0; O < a; O++) {
                    const M = Math.max(1, P + 3 & -4),
                        $ = Math.max(1, z + 3 & -4),
                        nt = M * $ * S;
                    T += nt, P = P >>> 1, z = z >>> 1
                }
                let X = I;
                for (let O = 0; O < _; O++) w.push(new Uint8Array(t, X, T)), X += T
            }
            return w.map(S => new ji(S, {
                format: E,
                width: n,
                height: i,
                levels: a
            }))
        }
        throw h & Cw ? new Error("DDSParser does not support uncompressed texture data.") : h & Iw ? new Error("DDSParser does not supported YUV uncompressed texture data.") : h & Rw ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : h & Aw ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
    };
    let Gu, ig, er, _o;
    Gu = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ig = 67305985, er = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    }, _o = 64, nh = {
        [dt.UNSIGNED_BYTE]: 1,
        [dt.UNSIGNED_SHORT]: 2,
        [dt.INT]: 4,
        [dt.UNSIGNED_INT]: 4,
        [dt.FLOAT]: 4,
        [dt.HALF_FLOAT]: 8
    }, sp = {
        [V.RGBA]: 4,
        [V.RGB]: 3,
        [V.RG]: 2,
        [V.RED]: 1,
        [V.LUMINANCE]: 1,
        [V.LUMINANCE_ALPHA]: 2,
        [V.ALPHA]: 1
    }, bp = {
        [dt.UNSIGNED_SHORT_4_4_4_4]: 2,
        [dt.UNSIGNED_SHORT_5_5_5_1]: 2,
        [dt.UNSIGNED_SHORT_5_6_5]: 2
    }, Up = function(t, e, r = !1) {
        const i = new DataView(e);
        if (!Fw(t, i)) return null;
        const n = i.getUint32(er.ENDIANNESS, !0) === ig,
            a = i.getUint32(er.GL_TYPE, n),
            l = i.getUint32(er.GL_FORMAT, n),
            h = i.getUint32(er.GL_INTERNAL_FORMAT, n),
            c = i.getUint32(er.PIXEL_WIDTH, n),
            d = i.getUint32(er.PIXEL_HEIGHT, n) || 1,
            f = i.getUint32(er.PIXEL_DEPTH, n) || 1,
            g = i.getUint32(er.NUMBER_OF_ARRAY_ELEMENTS, n) || 1,
            y = i.getUint32(er.NUMBER_OF_FACES, n),
            x = i.getUint32(er.NUMBER_OF_MIPMAP_LEVELS, n),
            _ = i.getUint32(er.BYTES_OF_KEY_VALUE_DATA, n);
        if (d === 0 || f !== 1) throw new Error("Only 2D textures are supported");
        if (y !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
        if (g !== 1) throw new Error("WebGL does not support array textures");
        const E = 4,
            w = 4,
            I = c + 3 & -4,
            S = d + 3 & -4,
            T = new Array(g);
        let P = c * d;
        a === 0 && (P = I * S);
        let z;
        if (a !== 0 ? nh[a] ? z = nh[a] * sp[l] : z = bp[a] : z = ds[h], z === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
        const X = r ? Gw(i, _, n) : null;
        let O = P * z,
            M = c,
            $ = d,
            nt = I,
            Y = S,
            q = _o + _;
        for (let B = 0; B < x; B++) {
            const G = i.getUint32(q, n);
            let pt = q + 4;
            for (let ft = 0; ft < g; ft++) {
                let J = T[ft];
                J || (J = T[ft] = new Array(x)), J[B] = {
                    levelID: B,
                    levelWidth: x > 1 || a !== 0 ? M : nt,
                    levelHeight: x > 1 || a !== 0 ? $ : Y,
                    levelBuffer: new Uint8Array(e, pt, O)
                }, pt += O
            }
            q += G + 4, q = q % 4 !== 0 ? q + 4 - q % 4 : q, M = M >> 1 || 1, $ = $ >> 1 || 1, nt = M + E - 1 & ~(E - 1), Y = $ + w - 1 & ~(w - 1), O = nt * Y * z
        }
        return a !== 0 ? {
            uncompressed: T.map(B => {
                let G = B[0].levelBuffer,
                    pt = !1;
                return a === dt.FLOAT ? G = new Float32Array(B[0].levelBuffer.buffer, B[0].levelBuffer.byteOffset, B[0].levelBuffer.byteLength / 4) : a === dt.UNSIGNED_INT ? (pt = !0, G = new Uint32Array(B[0].levelBuffer.buffer, B[0].levelBuffer.byteOffset, B[0].levelBuffer.byteLength / 4)) : a === dt.INT && (pt = !0, G = new Int32Array(B[0].levelBuffer.buffer, B[0].levelBuffer.byteOffset, B[0].levelBuffer.byteLength / 4)), {
                    resource: new yn(G, {
                        width: B[0].levelWidth,
                        height: B[0].levelHeight
                    }),
                    type: a,
                    format: pt ? Uw(l) : l
                }
            }),
            kvData: X
        } : {
            compressed: T.map(B => new ji(null, {
                format: h,
                width: c,
                height: d,
                levels: x,
                levelBuffers: B
            })),
            kvData: X
        }
    };

    function Fw(t, e) {
        for (let r = 0; r < Gu.length; r++)
            if (e.getUint8(r) !== Gu[r]) return !1;
        return !0
    }

    function Uw(t) {
        switch (t) {
            case V.RGBA:
                return V.RGBA_INTEGER;
            case V.RGB:
                return V.RGB_INTEGER;
            case V.RG:
                return V.RG_INTEGER;
            case V.RED:
                return V.RED_INTEGER;
            default:
                return t
        }
    }

    function Gw(t, e, r) {
        const i = new Map;
        let n = 0;
        for (; n < e;) {
            const a = t.getUint32(_o + n, r),
                l = _o + n + 4,
                h = 3 - (a + 3) % 4;
            if (a === 0 || a > e - n) break;
            let c = 0;
            for (; c < a && t.getUint8(l + c) !== 0; c++);
            if (c === -1) break;
            const d = new TextDecoder().decode(new Uint8Array(t.buffer, l, c)),
                f = new DataView(t.buffer, l + c + 1, a - c - 1);
            i.set(d, f), n += 4 + a + h
        }
        return i
    }
    Mp = {
        extension: {
            type: Z.LoadParser,
            priority: pr.High
        },
        test(t) {
            return xs(t, ".dds")
        },
        async load(t, e, r) {
            const i = await (await et.ADAPTER.fetch(t)).arrayBuffer(),
                n = Fp(i).map(a => {
                    const l = new mt(a, Kr({
                        mipmap: fr.OFF,
                        alphaMode: tr.NO_PREMULTIPLIED_ALPHA,
                        resolution: ni(t)
                    }, e.data));
                    return _s(l, r, t)
                });
            return n.length === 1 ? n[0] : n
        },
        unload(t) {
            Array.isArray(t) ? t.forEach(e => e.destroy(!0)) : t.destroy(!0)
        }
    }, lt.add(Mp), Op = {
        extension: {
            type: Z.LoadParser,
            priority: pr.High
        },
        test(t) {
            return xs(t, ".ktx")
        },
        async load(t, e, r) {
            const i = await (await et.ADAPTER.fetch(t)).arrayBuffer(),
                {
                    compressed: n,
                    uncompressed: a,
                    kvData: l
                } = Up(t, i),
                h = n != null ? n : a,
                c = Kr({
                    mipmap: fr.OFF,
                    alphaMode: tr.NO_PREMULTIPLIED_ALPHA,
                    resolution: ni(t)
                }, e.data),
                d = h.map(f => {
                    h === a && Object.assign(c, {
                        type: f.type,
                        format: f.format
                    });
                    const g = new mt(f, c);
                    return g.ktxKeyValueData = l, _s(g, r, t)
                });
            return d.length === 1 ? d[0] : d
        },
        unload(t) {
            Array.isArray(t) ? t.forEach(e => e.destroy(!0)) : t.destroy(!0)
        }
    }, lt.add(Op), Gp = {
        extension: Z.ResolveParser,
        test: t => {
            const e = t.split("?")[0].split(".").pop();
            return ["basis", "ktx", "dds"].includes(e)
        },
        parse: t => {
            var i, n;
            var e, r;
            if (t.split("?")[0].split(".").pop() === "ktx") {
                const a = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
                if (a.some(l => t.endsWith(l))) return {
                    resolution: parseFloat((i = (e = et.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) != null ? i : "1"),
                    format: a.find(l => t.endsWith(l)),
                    src: t
                }
            }
            return {
                resolution: parseFloat((n = (r = et.RETINA_PREFIX.exec(t)) == null ? void 0 : r[1]) != null ? n : "1"),
                format: t.split(".").pop(),
                src: t
            }
        }
    }, lt.add(Gp);
    const zw = new bt,
        Hw = 4,
        zu = class {
            constructor(t) {
                this.renderer = t
            }
            async image(t, e, r) {
                const i = new Image;
                return i.src = await this.base64(t, e, r), i
            }
            async base64(t, e, r) {
                const i = this.canvas(t);
                if (i.toDataURL !== void 0) return i.toDataURL(e, r);
                if (i.convertToBlob !== void 0) {
                    const n = await i.convertToBlob({
                        type: e,
                        quality: r
                    });
                    return await new Promise(a => {
                        const l = new FileReader;
                        l.onload = () => a(l.result), l.readAsDataURL(n)
                    })
                }
                throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
            }
            canvas(t, e) {
                const {
                    pixels: r,
                    width: i,
                    height: n,
                    flipY: a
                } = this._rawPixels(t, e);
                let l = new yu(i, n, 1);
                const h = l.context.getImageData(0, 0, i, n);
                if (zu.arrayPostDivide(r, h.data), l.context.putImageData(h, 0, 0), a) {
                    const c = new yu(l.width, l.height, 1);
                    c.context.scale(1, -1), c.context.drawImage(l.canvas, 0, -n), l.destroy(), l = c
                }
                return l.canvas
            }
            pixels(t, e) {
                const {
                    pixels: r
                } = this._rawPixels(t, e);
                return zu.arrayPostDivide(r, r), r
            }
            _rawPixels(t, e) {
                const r = this.renderer;
                let i, n = !1,
                    a, l = !1;
                if (t)
                    if (t instanceof yi) a = t;
                    else {
                        const g = r.context.webGLVersion >= 2 ? r.multisample : Wt.NONE;
                        if (a = this.renderer.generateTexture(t, {
                                multisample: g
                            }), g !== Wt.NONE) {
                            const y = yi.create({
                                width: a.width,
                                height: a.height
                            });
                            r.framebuffer.bind(a.framebuffer), r.framebuffer.blit(y.framebuffer), r.framebuffer.bind(null), a.destroy(!0), a = y
                        }
                        l = !0
                    }
                a ? (i = a.baseTexture.resolution, e = e != null ? e : a.frame, n = !1, r.renderTexture.bind(a)) : (i = r.resolution, e || (e = zw, e.width = r.width, e.height = r.height), n = !0, r.renderTexture.bind(null));
                const h = Math.round(e.width * i),
                    c = Math.round(e.height * i),
                    d = new Uint8Array(Hw * h * c),
                    f = r.gl;
                return f.readPixels(Math.round(e.x * i), Math.round(e.y * i), h, c, f.RGBA, f.UNSIGNED_BYTE, d), l && a.destroy(!0), {
                    pixels: d,
                    width: h,
                    height: c,
                    flipY: n
                }
            }
            destroy() {
                this.renderer = null
            }
            static arrayPostDivide(t, e) {
                for (let r = 0; r < t.length; r += 4) {
                    const i = e[r + 3] = t[r + 3];
                    i !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / i, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / i, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / i, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2])
                }
            }
        };
    kl = zu, kl.extension = {
        name: "extract",
        type: Z.RendererSystem
    }, lt.add(kl);
    const Us = {
        build(t) {
            const e = t.points;
            let r, i, n, a, l, h;
            if (t.type === le.CIRC) {
                const _ = t.shape;
                r = _.x, i = _.y, l = h = _.radius, n = a = 0
            } else if (t.type === le.ELIP) {
                const _ = t.shape;
                r = _.x, i = _.y, l = _.width, h = _.height, n = a = 0
            } else {
                const _ = t.shape,
                    E = _.width / 2,
                    w = _.height / 2;
                r = _.x + E, i = _.y + w, l = h = Math.max(0, Math.min(_.radius, Math.min(E, w))), n = E - l, a = w - h
            }
            if (!(l >= 0 && h >= 0 && n >= 0 && a >= 0)) {
                e.length = 0;
                return
            }
            const c = Math.ceil(2.3 * Math.sqrt(l + h)),
                d = c * 8 + (n ? 4 : 0) + (a ? 4 : 0);
            if (e.length = d, d === 0) return;
            if (c === 0) {
                e.length = 8, e[0] = e[6] = r + n, e[1] = e[3] = i + a, e[2] = e[4] = r - n, e[5] = e[7] = i - a;
                return
            }
            let f = 0,
                g = c * 4 + (n ? 2 : 0) + 2,
                y = g,
                x = d; {
                const _ = n + l,
                    E = a,
                    w = r + _,
                    I = r - _,
                    S = i + E;
                if (e[f++] = w, e[f++] = S, e[--g] = S, e[--g] = I, a) {
                    const T = i - E;
                    e[y++] = I, e[y++] = T, e[--x] = T, e[--x] = w
                }
            }
            for (let _ = 1; _ < c; _++) {
                const E = Math.PI / 2 * (_ / c),
                    w = n + Math.cos(E) * l,
                    I = a + Math.sin(E) * h,
                    S = r + w,
                    T = r - w,
                    P = i + I,
                    z = i - I;
                e[f++] = S, e[f++] = P, e[--g] = P, e[--g] = T, e[y++] = T, e[y++] = z, e[--x] = z, e[--x] = S
            } {
                const _ = n,
                    E = a + h,
                    w = r + _,
                    I = r - _,
                    S = i + E,
                    T = i - E;
                e[f++] = w, e[f++] = S, e[--x] = T, e[--x] = w, n && (e[f++] = I, e[f++] = S, e[--x] = T, e[--x] = I)
            }
        },
        triangulate(t, e) {
            const r = t.points,
                i = e.points,
                n = e.indices;
            if (r.length === 0) return;
            let a = i.length / 2;
            const l = a;
            let h, c;
            if (t.type !== le.RREC) {
                const f = t.shape;
                h = f.x, c = f.y
            } else {
                const f = t.shape;
                h = f.x + f.width / 2, c = f.y + f.height / 2
            }
            const d = t.matrix;
            i.push(t.matrix ? d.a * h + d.c * c + d.tx : h, t.matrix ? d.b * h + d.d * c + d.ty : c), a++, i.push(r[0], r[1]);
            for (let f = 2; f < r.length; f += 2) i.push(r[f], r[f + 1]), n.push(a++, l, a);
            n.push(l + 1, l, a)
        }
    };

    function ng(t, e = !1) {
        const r = t.length;
        if (r < 6) return;
        let i = 0;
        for (let n = 0, a = t[r - 2], l = t[r - 1]; n < r; n += 2) {
            const h = t[n],
                c = t[n + 1];
            i += (h - a) * (c + l), a = h, l = c
        }
        if (!e && i > 0 || e && i <= 0) {
            const n = r / 2;
            for (let a = n + n % 2; a < r; a += 2) {
                const l = r - a - 2,
                    h = r - a - 1,
                    c = a,
                    d = a + 1;
                [t[l], t[c]] = [t[c], t[l]], [t[h], t[d]] = [t[d], t[h]]
            }
        }
    }
    const Hu = {
            build(t) {
                t.points = t.shape.points.slice()
            },
            triangulate(t, e) {
                let r = t.points;
                const i = t.holes,
                    n = e.points,
                    a = e.indices;
                if (r.length >= 6) {
                    ng(r, !1);
                    const l = [];
                    for (let d = 0; d < i.length; d++) {
                        const f = i[d];
                        ng(f.points, !0), l.push(r.length / 2), r = r.concat(f.points)
                    }
                    const h = Df(r, l, 2);
                    if (!h) return;
                    const c = n.length / 2;
                    for (let d = 0; d < h.length; d += 3) a.push(h[d] + c), a.push(h[d + 1] + c), a.push(h[d + 2] + c);
                    for (let d = 0; d < r.length; d++) n.push(r[d])
                }
            }
        },
        sg = {
            build(t) {
                const e = t.shape,
                    r = e.x,
                    i = e.y,
                    n = e.width,
                    a = e.height,
                    l = t.points;
                l.length = 0, n >= 0 && a >= 0 && l.push(r, i, r + n, i, r + n, i + a, r, i + a)
            },
            triangulate(t, e) {
                const r = t.points,
                    i = e.points;
                if (r.length === 0) return;
                const n = i.length / 2;
                i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), e.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3)
            }
        },
        ag = {
            build(t) {
                Us.build(t)
            },
            triangulate(t, e) {
                Us.triangulate(t, e)
            }
        };
    Qe = (t => (t.MITER = "miter", t.BEVEL = "bevel", t.ROUND = "round", t))(Qe || {}), mi = (t => (t.BUTT = "butt", t.ROUND = "round", t.SQUARE = "square", t))(mi || {}), _i = {
        adaptive: !0,
        maxLength: 10,
        minSegments: 8,
        maxSegments: 2048,
        epsilon: 1e-4,
        _segmentsCount(t, e = 20) {
            if (!this.adaptive || !t || isNaN(t)) return e;
            let r = Math.ceil(t / this.maxLength);
            return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r
        }
    }, hv = _i;
    class ju {
        static curveTo(e, r, i, n, a, l) {
            const h = l[l.length - 2],
                c = l[l.length - 1] - r,
                d = h - e,
                f = n - r,
                g = i - e,
                y = Math.abs(c * g - d * f);
            if (y < 1e-8 || a === 0) return (l[l.length - 2] !== e || l[l.length - 1] !== r) && l.push(e, r), null;
            const x = c * c + d * d,
                _ = f * f + g * g,
                E = c * f + d * g,
                w = a * Math.sqrt(x) / y,
                I = a * Math.sqrt(_) / y,
                S = w * E / x,
                T = I * E / _,
                P = w * g + I * d,
                z = w * f + I * c,
                X = d * (I + S),
                O = c * (I + S),
                M = g * (w + T),
                $ = f * (w + T),
                nt = Math.atan2(O - z, X - P),
                Y = Math.atan2($ - z, M - P);
            return {
                cx: P + e,
                cy: z + r,
                radius: a,
                startAngle: nt,
                endAngle: Y,
                anticlockwise: d * f > g * c
            }
        }
        static arc(e, r, i, n, a, l, h, c, d) {
            const f = h - l,
                g = _i._segmentsCount(Math.abs(f) * a, Math.ceil(Math.abs(f) / cs) * 40),
                y = f / (g * 2),
                x = y * 2,
                _ = Math.cos(y),
                E = Math.sin(y),
                w = g - 1,
                I = w % 1 / w;
            for (let S = 0; S <= w; ++S) {
                const T = S + I * S,
                    P = y + l + x * T,
                    z = Math.cos(P),
                    X = -Math.sin(P);
                d.push((_ * z + E * X) * a + i, (_ * -X + E * z) * a + n)
            }
        }
    }
    class og {
        constructor() {
            this.reset()
        }
        begin(e, r, i) {
            this.reset(), this.style = e, this.start = r, this.attribStart = i
        }
        end(e, r) {
            this.attribSize = r - this.attribStart, this.size = e - this.start
        }
        reset() {
            this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
        }
    }
    class bo {
        static curveLength(e, r, i, n, a, l, h, c) {
            let d = 0,
                f = 0,
                g = 0,
                y = 0,
                x = 0,
                _ = 0,
                E = 0,
                w = 0,
                I = 0,
                S = 0,
                T = 0,
                P = e,
                z = r;
            for (let X = 1; X <= 10; ++X) f = X / 10, g = f * f, y = g * f, x = 1 - f, _ = x * x, E = _ * x, w = E * e + 3 * _ * f * i + 3 * x * g * a + y * h, I = E * r + 3 * _ * f * n + 3 * x * g * l + y * c, S = P - w, T = z - I, P = w, z = I, d += Math.sqrt(S * S + T * T);
            return d
        }
        static curveTo(e, r, i, n, a, l, h) {
            const c = h[h.length - 2],
                d = h[h.length - 1];
            h.length -= 2;
            const f = _i._segmentsCount(bo.curveLength(c, d, e, r, i, n, a, l));
            let g = 0,
                y = 0,
                x = 0,
                _ = 0,
                E = 0;
            h.push(c, d);
            for (let w = 1, I = 0; w <= f; ++w) I = w / f, g = 1 - I, y = g * g, x = y * g, _ = I * I, E = _ * I, h.push(x * c + 3 * y * I * e + 3 * g * _ * i + E * a, x * d + 3 * y * I * r + 3 * g * _ * n + E * l)
        }
    }

    function lg(t, e, r, i, n, a, l, h) {
        const c = t - r * n,
            d = e - i * n,
            f = t + r * a,
            g = e + i * a;
        let y, x;
        l ? (y = i, x = -r) : (y = -i, x = r);
        const _ = c + y,
            E = d + x,
            w = f + y,
            I = g + x;
        return h.push(_, E, w, I), 2
    }

    function en(t, e, r, i, n, a, l, h) {
        const c = r - t,
            d = i - e;
        let f = Math.atan2(c, d),
            g = Math.atan2(n - t, a - e);
        h && f < g ? f += Math.PI * 2 : !h && f > g && (g += Math.PI * 2);
        let y = f;
        const x = g - f,
            _ = Math.abs(x),
            E = Math.sqrt(c * c + d * d),
            w = (15 * _ * Math.sqrt(E) / Math.PI >> 0) + 1,
            I = x / w;
        if (y += I, h) {
            l.push(t, e, r, i);
            for (let S = 1, T = y; S < w; S++, T += I) l.push(t, e, t + Math.sin(T) * E, e + Math.cos(T) * E);
            l.push(t, e, n, a)
        } else {
            l.push(r, i, t, e);
            for (let S = 1, T = y; S < w; S++, T += I) l.push(t + Math.sin(T) * E, e + Math.cos(T) * E, t, e);
            l.push(n, a, t, e)
        }
        return w * 2
    }

    function jw(t, e) {
        const r = t.shape;
        let i = t.points || r.points.slice();
        const n = e.closePointEps;
        if (i.length === 0) return;
        const a = t.lineStyle,
            l = new gt(i[0], i[1]),
            h = new gt(i[i.length - 2], i[i.length - 1]),
            c = r.type !== le.POLY || r.closeStroke,
            d = Math.abs(l.x - h.x) < n && Math.abs(l.y - h.y) < n;
        if (c) {
            i = i.slice(), d && (i.pop(), i.pop(), h.set(i[i.length - 2], i[i.length - 1]));
            const J = (l.x + h.x) * .5,
                j = (h.y + l.y) * .5;
            i.unshift(J, j), i.push(J, j)
        }
        const f = e.points,
            g = i.length / 2;
        let y = i.length;
        const x = f.length / 2,
            _ = a.width / 2,
            E = _ * _,
            w = a.miterLimit * a.miterLimit;
        let I = i[0],
            S = i[1],
            T = i[2],
            P = i[3],
            z = 0,
            X = 0,
            O = -(S - P),
            M = I - T,
            $ = 0,
            nt = 0,
            Y = Math.sqrt(O * O + M * M);
        O /= Y, M /= Y, O *= _, M *= _;
        const q = a.alignment,
            B = (1 - q) * 2,
            G = q * 2;
        c || (a.cap === mi.ROUND ? y += en(I - O * (B - G) * .5, S - M * (B - G) * .5, I - O * B, S - M * B, I + O * G, S + M * G, f, !0) + 2 : a.cap === mi.SQUARE && (y += lg(I, S, O, M, B, G, !0, f))), f.push(I - O * B, S - M * B, I + O * G, S + M * G);
        for (let J = 1; J < g - 1; ++J) {
            I = i[(J - 1) * 2], S = i[(J - 1) * 2 + 1], T = i[J * 2], P = i[J * 2 + 1], z = i[(J + 1) * 2], X = i[(J + 1) * 2 + 1], O = -(S - P), M = I - T, Y = Math.sqrt(O * O + M * M), O /= Y, M /= Y, O *= _, M *= _, $ = -(P - X), nt = T - z, Y = Math.sqrt($ * $ + nt * nt), $ /= Y, nt /= Y, $ *= _, nt *= _;
            const j = T - I,
                rt = S - P,
                D = T - z,
                tt = X - P,
                ht = j * D + rt * tt,
                _t = rt * D - tt * j,
                vt = _t < 0;
            if (Math.abs(_t) < .001 * Math.abs(ht)) {
                f.push(T - O * B, P - M * B, T + O * G, P + M * G), ht >= 0 && (a.join === Qe.ROUND ? y += en(T, P, T - O * B, P - M * B, T - $ * B, P - nt * B, f, !1) + 4 : y += 2, f.push(T - $ * G, P - nt * G, T + $ * B, P + nt * B));
                continue
            }
            const Nt = (-O + I) * (-M + P) - (-O + T) * (-M + S),
                Ct = (-$ + z) * (-nt + P) - (-$ + T) * (-nt + X),
                Ot = (j * Ct - D * Nt) / _t,
                de = (tt * Nt - rt * Ct) / _t,
                xe = (Ot - T) * (Ot - T) + (de - P) * (de - P),
                qt = T + (Ot - T) * B,
                xt = P + (de - P) * B,
                kt = T - (Ot - T) * G,
                St = P - (de - P) * G,
                rr = Math.min(j * j + rt * rt, D * D + tt * tt),
                ir = vt ? B : G,
                sn = rr + ir * ir * E,
                Lc = xe <= sn;
            let jn = a.join;
            if (jn === Qe.MITER && xe / E > w && (jn = Qe.BEVEL), Lc) switch (jn) {
                case Qe.MITER:
                    {
                        f.push(qt, xt, kt, St);
                        break
                    }
                case Qe.BEVEL:
                    {
                        vt ? f.push(qt, xt, T + O * G, P + M * G, qt, xt, T + $ * G, P + nt * G) : f.push(T - O * B, P - M * B, kt, St, T - $ * B, P - nt * B, kt, St),
                        y += 2;
                        break
                    }
                case Qe.ROUND:
                    {
                        vt ? (f.push(qt, xt, T + O * G, P + M * G), y += en(T, P, T + O * G, P + M * G, T + $ * G, P + nt * G, f, !0) + 4, f.push(qt, xt, T + $ * G, P + nt * G)) : (f.push(T - O * B, P - M * B, kt, St), y += en(T, P, T - O * B, P - M * B, T - $ * B, P - nt * B, f, !1) + 4, f.push(T - $ * B, P - nt * B, kt, St));
                        break
                    }
            } else {
                switch (f.push(T - O * B, P - M * B, T + O * G, P + M * G), jn) {
                    case Qe.MITER:
                        {
                            vt ? f.push(kt, St, kt, St) : f.push(qt, xt, qt, xt),
                            y += 2;
                            break
                        }
                    case Qe.ROUND:
                        {
                            vt ? y += en(T, P, T + O * G, P + M * G, T + $ * G, P + nt * G, f, !0) + 2 : y += en(T, P, T - O * B, P - M * B, T - $ * B, P - nt * B, f, !1) + 2;
                            break
                        }
                }
                f.push(T - $ * B, P - nt * B, T + $ * G, P + nt * G), y += 2
            }
        }
        I = i[(g - 2) * 2], S = i[(g - 2) * 2 + 1], T = i[(g - 1) * 2], P = i[(g - 1) * 2 + 1], O = -(S - P), M = I - T, Y = Math.sqrt(O * O + M * M), O /= Y, M /= Y, O *= _, M *= _, f.push(T - O * B, P - M * B, T + O * G, P + M * G), c || (a.cap === mi.ROUND ? y += en(T - O * (B - G) * .5, P - M * (B - G) * .5, T - O * B, P - M * B, T + O * G, P + M * G, f, !1) + 2 : a.cap === mi.SQUARE && (y += lg(T, P, O, M, B, G, !1, f)));
        const pt = e.indices,
            ft = _i.epsilon * _i.epsilon;
        for (let J = x; J < y + x - 2; ++J) I = f[J * 2], S = f[J * 2 + 1], T = f[(J + 1) * 2], P = f[(J + 1) * 2 + 1], z = f[(J + 2) * 2], X = f[(J + 2) * 2 + 1], !(Math.abs(I * (P - X) + T * (X - S) + z * (S - P)) < ft) && pt.push(J, J + 1, J + 2)
    }

    function Ww(t, e) {
        let r = 0;
        const i = t.shape,
            n = t.points || i.points,
            a = i.type !== le.POLY || i.closeStroke;
        if (n.length === 0) return;
        const l = e.points,
            h = e.indices,
            c = n.length / 2,
            d = l.length / 2;
        let f = d;
        for (l.push(n[0], n[1]), r = 1; r < c; r++) l.push(n[r * 2], n[r * 2 + 1]), h.push(f, f + 1), f++;
        a && h.push(f, d)
    }

    function Wu(t, e) {
        t.lineStyle.native ? Ww(t, e) : jw(t, e)
    }
    class Eo {
        static curveLength(e, r, i, n, a, l) {
            const h = e - 2 * i + a,
                c = r - 2 * n + l,
                d = 2 * i - 2 * e,
                f = 2 * n - 2 * r,
                g = 4 * (h * h + c * c),
                y = 4 * (h * d + c * f),
                x = d * d + f * f,
                _ = 2 * Math.sqrt(g + y + x),
                E = Math.sqrt(g),
                w = 2 * g * E,
                I = 2 * Math.sqrt(x),
                S = y / E;
            return (w * _ + E * y * (_ - I) + (4 * x * g - y * y) * Math.log((2 * E + S + _) / (S + I))) / (4 * w)
        }
        static curveTo(e, r, i, n, a) {
            const l = a[a.length - 2],
                h = a[a.length - 1],
                c = _i._segmentsCount(Eo.curveLength(l, h, e, r, i, n));
            let d = 0,
                f = 0;
            for (let g = 1; g <= c; ++g) {
                const y = g / c;
                d = l + (e - l) * y, f = h + (r - h) * y, a.push(d + (e + (i - e) * y - d) * y, f + (r + (n - r) * y - f) * y)
            }
        }
    }
    const To = {
            [le.POLY]: Hu,
            [le.CIRC]: Us,
            [le.ELIP]: Us,
            [le.RECT]: sg,
            [le.RREC]: ag
        },
        Xu = [],
        Gs = [];
    Ta = class {
        constructor(t, e = null, r = null, i = null) {
            this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = i, this.type = t.type
        }
        clone() {
            return new Ta(this.shape, this.fillStyle, this.lineStyle, this.matrix)
        }
        destroy() {
            this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
        }
    };
    const Un = new gt,
        hg = class extends Ml {
            constructor() {
                super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new as, this.boundsDirty = -1
            }
            get bounds() {
                return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
            }
            invalidate() {
                this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
                for (let t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].texArray.clear(), Gs.push(this.drawCalls[t]);
                this.drawCalls.length = 0;
                for (let t = 0; t < this.batches.length; t++) {
                    const e = this.batches[t];
                    e.reset(), Xu.push(e)
                }
                this.batches.length = 0
            }
            clear() {
                return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
            }
            drawShape(t, e = null, r = null, i = null) {
                const n = new Ta(t, e, r, i);
                return this.graphicsData.push(n), this.dirty++, this
            }
            drawHole(t, e = null) {
                if (!this.graphicsData.length) return null;
                const r = new Ta(t, null, null, e),
                    i = this.graphicsData[this.graphicsData.length - 1];
                return r.lineStyle = i.lineStyle, i.holes.push(r), this.dirty++, this
            }
            destroy() {
                super.destroy();
                for (let t = 0; t < this.graphicsData.length; ++t) this.graphicsData[t].destroy();
                this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
            }
            containsPoint(t) {
                const e = this.graphicsData;
                for (let r = 0; r < e.length; ++r) {
                    const i = e[r];
                    if (i.fillStyle.visible && i.shape && (i.matrix ? i.matrix.applyInverse(t, Un) : Un.copyFrom(t), i.shape.contains(Un.x, Un.y))) {
                        let n = !1;
                        if (i.holes) {
                            for (let a = 0; a < i.holes.length; a++)
                                if (i.holes[a].shape.contains(Un.x, Un.y)) {
                                    n = !0;
                                    break
                                }
                        }
                        if (!n) return !0
                    }
                }
                return !1
            }
            updateBatches() {
                if (!this.graphicsData.length) {
                    this.batchable = !0;
                    return
                }
                if (!this.validateBatching()) return;
                this.cacheDirty = this.dirty;
                const t = this.uvs,
                    e = this.graphicsData;
                let r = null,
                    i = null;
                this.batches.length > 0 && (r = this.batches[this.batches.length - 1], i = r.style);
                for (let h = this.shapeIndex; h < e.length; h++) {
                    this.shapeIndex++;
                    const c = e[h],
                        d = c.fillStyle,
                        f = c.lineStyle;
                    To[c.type].build(c), c.matrix && this.transformPoints(c.points, c.matrix), (d.visible || f.visible) && this.processHoles(c.holes);
                    for (let g = 0; g < 2; g++) {
                        const y = g === 0 ? d : f;
                        if (!y.visible) continue;
                        const x = y.texture.baseTexture,
                            _ = this.indices.length,
                            E = this.points.length / 2;
                        x.wrapMode = Nr.REPEAT, g === 0 ? this.processFill(c) : this.processLine(c);
                        const w = this.points.length / 2 - E;
                        w !== 0 && (r && !this._compareStyles(i, y) && (r.end(_, E), r = null), r || (r = Xu.pop() || new og, r.begin(y, _, E), this.batches.push(r), i = y), this.addUvs(this.points, t, y.texture, E, w, y.matrix))
                    }
                }
                const n = this.indices.length,
                    a = this.points.length / 2;
                if (r && r.end(n, a), this.batches.length === 0) {
                    this.batchable = !0;
                    return
                }
                const l = a > 65535;
                this.indicesUint16 && this.indices.length === this.indicesUint16.length && l === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = l ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
            }
            _compareStyles(t, e) {
                return !(!t || !e || t.texture.baseTexture !== e.texture.baseTexture || t.color + t.alpha !== e.color + e.alpha || !!t.native != !!e.native)
            }
            validateBatching() {
                if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
                for (let t = 0, e = this.graphicsData.length; t < e; t++) {
                    const r = this.graphicsData[t],
                        i = r.fillStyle,
                        n = r.lineStyle;
                    if (i && !i.texture.baseTexture.valid || n && !n.texture.baseTexture.valid) return !1
                }
                return !0
            }
            packBatches() {
                this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
                const t = this.batches;
                for (let e = 0, r = t.length; e < r; e++) {
                    const i = t[e];
                    for (let n = 0; n < i.size; n++) {
                        const a = i.start + n;
                        this.indicesUint16[a] = this.indicesUint16[a] - i.attribStart
                    }
                }
            }
            isBatchable() {
                if (this.points.length > 65535 * 2) return !1;
                const t = this.batches;
                for (let e = 0; e < t.length; e++)
                    if (t[e].style.native) return !1;
                return this.points.length < hg.BATCHABLE_SIZE * 2
            }
            buildDrawCalls() {
                let t = ++mt._globalBatch;
                for (let f = 0; f < this.drawCalls.length; f++) this.drawCalls[f].texArray.clear(), Gs.push(this.drawCalls[f]);
                this.drawCalls.length = 0;
                const e = this.colors,
                    r = this.textureIds;
                let i = Gs.pop();
                i || (i = new va, i.texArray = new ga), i.texArray.count = 0, i.start = 0, i.size = 0, i.type = Ye.TRIANGLES;
                let n = 0,
                    a = null,
                    l = 0,
                    h = !1,
                    c = Ye.TRIANGLES,
                    d = 0;
                this.drawCalls.push(i);
                for (let f = 0; f < this.batches.length; f++) {
                    const g = this.batches[f],
                        y = 8,
                        x = g.style,
                        _ = x.texture.baseTexture;
                    h !== !!x.native && (h = !!x.native, c = h ? Ye.LINES : Ye.TRIANGLES, a = null, n = y, t++), a !== _ && (a = _, _._batchEnabled !== t && (n === y && (t++, n = 0, i.size > 0 && (i = Gs.pop(), i || (i = new va, i.texArray = new ga), this.drawCalls.push(i)), i.start = d, i.size = 0, i.texArray.count = 0, i.type = c), _.touched = 1, _._batchEnabled = t, _._batchLocation = n, _.wrapMode = Nr.REPEAT, i.texArray.elements[i.texArray.count++] = _, n++)), i.size += g.size, d += g.size, l = _._batchLocation, this.addColors(e, x.color, x.alpha, g.attribSize, g.attribStart), this.addTextureIds(r, l, g.attribSize, g.attribStart)
                }
                mt._globalBatch = t, this.packAttributes()
            }
            packAttributes() {
                const t = this.points,
                    e = this.uvs,
                    r = this.colors,
                    i = this.textureIds,
                    n = new ArrayBuffer(t.length * 3 * 4),
                    a = new Float32Array(n),
                    l = new Uint32Array(n);
                let h = 0;
                for (let c = 0; c < t.length / 2; c++) a[h++] = t[c * 2], a[h++] = t[c * 2 + 1], a[h++] = e[c * 2], a[h++] = e[c * 2 + 1], l[h++] = r[c], a[h++] = i[c];
                this._buffer.update(n), this._indexBuffer.update(this.indicesUint16)
            }
            processFill(t) {
                t.holes.length ? Hu.triangulate(t, this) : To[t.type].triangulate(t, this)
            }
            processLine(t) {
                Wu(t, this);
                for (let e = 0; e < t.holes.length; e++) Wu(t.holes[e], this)
            }
            processHoles(t) {
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    To[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix)
                }
            }
            calculateBounds() {
                const t = this._bounds;
                t.clear(), t.addVertexData(this.points, 0, this.points.length), t.pad(this.boundsPadding, this.boundsPadding)
            }
            transformPoints(t, e) {
                for (let r = 0; r < t.length / 2; r++) {
                    const i = t[r * 2],
                        n = t[r * 2 + 1];
                    t[r * 2] = e.a * i + e.c * n + e.tx, t[r * 2 + 1] = e.b * i + e.d * n + e.ty
                }
            }
            addColors(t, e, r, i, n = 0) {
                const a = (e >> 16) + (e & 65280) + ((e & 255) << 16),
                    l = Ja(a, r);
                t.length = Math.max(t.length, n + i);
                for (let h = 0; h < i; h++) t[n + h] = l
            }
            addTextureIds(t, e, r, i = 0) {
                t.length = Math.max(t.length, i + r);
                for (let n = 0; n < r; n++) t[i + n] = e
            }
            addUvs(t, e, r, i, n, a = null) {
                let l = 0;
                const h = e.length,
                    c = r.frame;
                for (; l < n;) {
                    let f = t[(i + l) * 2],
                        g = t[(i + l) * 2 + 1];
                    if (a) {
                        const y = a.a * f + a.c * g + a.tx;
                        g = a.b * f + a.d * g + a.ty, f = y
                    }
                    l++, e.push(f / c.width, g / c.height)
                }
                const d = r.baseTexture;
                (c.width < d.width || c.height < d.height) && this.adjustUvs(e, r, h, n)
            }
            adjustUvs(t, e, r, i) {
                const n = e.baseTexture,
                    a = 1e-6,
                    l = r + i * 2,
                    h = e.frame,
                    c = h.width / n.width,
                    d = h.height / n.height;
                let f = h.x / h.width,
                    g = h.y / h.height,
                    y = Math.floor(t[r] + a),
                    x = Math.floor(t[r + 1] + a);
                for (let _ = r + 2; _ < l; _ += 2) y = Math.min(y, Math.floor(t[_] + a)), x = Math.min(x, Math.floor(t[_ + 1] + a));
                f -= y, g -= x;
                for (let _ = r; _ < l; _ += 2) t[_] = (t[_] + f) * c, t[_ + 1] = (t[_ + 1] + g) * d
            }
        };
    Vl = hg, Vl.BATCHABLE_SIZE = 100, xa = class {
        constructor() {
            this.color = 16777215, this.alpha = 1, this.texture = Q.WHITE, this.matrix = null, this.visible = !1, this.reset()
        }
        clone() {
            const t = new xa;
            return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t
        }
        reset() {
            this.color = 16777215, this.alpha = 1, this.texture = Q.WHITE, this.matrix = null, this.visible = !1
        }
        destroy() {
            this.texture = null, this.matrix = null
        }
    }, Fl = class extends xa {
        constructor() {
            super(...arguments), this.width = 0, this.alignment = .5, this.native = !1, this.cap = mi.BUTT, this.join = Qe.MITER, this.miterLimit = 10
        }
        clone() {
            const t = new Fl;
            return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
        }
        reset() {
            super.reset(), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
        }
    };
    const Xw = new Float32Array(3),
        $u = {},
        wo = class extends Kt {
            constructor(t = null) {
                super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new xa, this._lineStyle = new Fl, this._matrix = null, this._holeMode = !1, this.state = ei.for2d(), this._geometry = t || new Vl, this._geometry.refCount++, this._transformID = -1, this.tint = 16777215, this.blendMode = ut.NORMAL
            }
            get geometry() {
                return this._geometry
            }
            clone() {
                return this.finishPoly(), new wo(this._geometry)
            }
            set blendMode(t) {
                this.state.blendMode = t
            }
            get blendMode() {
                return this.state.blendMode
            }
            get tint() {
                return this._tint
            }
            set tint(t) {
                this._tint = t
            }
            get fill() {
                return this._fillStyle
            }
            get line() {
                return this._lineStyle
            }
            lineStyle(t = null, e = 0, r = 1, i = .5, n = !1) {
                return typeof t == "number" && (t = {
                    width: t,
                    color: e,
                    alpha: r,
                    alignment: i,
                    native: n
                }), this.lineTextureStyle(t)
            }
            lineTextureStyle(t) {
                t = Object.assign({
                    width: 0,
                    texture: Q.WHITE,
                    color: t != null && t.texture ? 16777215 : 0,
                    alpha: 1,
                    matrix: null,
                    alignment: .5,
                    native: !1,
                    cap: mi.BUTT,
                    join: Qe.MITER,
                    miterLimit: 10
                }, t), this.currentPath && this.startPoly();
                const e = t.width > 0 && t.alpha > 0;
                return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
                    visible: e
                }, t)) : this._lineStyle.reset(), this
            }
            startPoly() {
                if (this.currentPath) {
                    const t = this.currentPath.points,
                        e = this.currentPath.points.length;
                    e > 2 && (this.drawShape(this.currentPath), this.currentPath = new _n, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
                } else this.currentPath = new _n, this.currentPath.closeStroke = !1
            }
            finishPoly() {
                this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
            }
            moveTo(t, e) {
                return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
            }
            lineTo(t, e) {
                this.currentPath || this.moveTo(0, 0);
                const r = this.currentPath.points,
                    i = r[r.length - 2],
                    n = r[r.length - 1];
                return (i !== t || n !== e) && r.push(t, e), this
            }
            _initCurve(t = 0, e = 0) {
                this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
            }
            quadraticCurveTo(t, e, r, i) {
                this._initCurve();
                const n = this.currentPath.points;
                return n.length === 0 && this.moveTo(0, 0), Eo.curveTo(t, e, r, i, n), this
            }
            bezierCurveTo(t, e, r, i, n, a) {
                return this._initCurve(), bo.curveTo(t, e, r, i, n, a, this.currentPath.points), this
            }
            arcTo(t, e, r, i, n) {
                this._initCurve(t, e);
                const a = this.currentPath.points,
                    l = ju.curveTo(t, e, r, i, n, a);
                if (l) {
                    const {
                        cx: h,
                        cy: c,
                        radius: d,
                        startAngle: f,
                        endAngle: g,
                        anticlockwise: y
                    } = l;
                    this.arc(h, c, d, f, g, y)
                }
                return this
            }
            arc(t, e, r, i, n, a = !1) {
                if (i === n) return this;
                if (!a && n <= i ? n += cs : a && i <= n && (i += cs), n - i === 0) return this;
                const l = t + Math.cos(i) * r,
                    h = e + Math.sin(i) * r,
                    c = this._geometry.closePointEps;
                let d = this.currentPath ? this.currentPath.points : null;
                if (d) {
                    const f = Math.abs(d[d.length - 2] - l),
                        g = Math.abs(d[d.length - 1] - h);
                    f < c && g < c || d.push(l, h)
                } else this.moveTo(l, h), d = this.currentPath.points;
                return ju.arc(l, h, t, e, r, i, n, a, d), this
            }
            beginFill(t = 0, e = 1) {
                return this.beginTextureFill({
                    texture: Q.WHITE,
                    color: t,
                    alpha: e
                })
            }
            beginTextureFill(t) {
                t = Object.assign({
                    texture: Q.WHITE,
                    color: 16777215,
                    alpha: 1,
                    matrix: null
                }, t), this.currentPath && this.startPoly();
                const e = t.alpha > 0;
                return e ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
                    visible: e
                }, t)) : this._fillStyle.reset(), this
            }
            endFill() {
                return this.finishPoly(), this._fillStyle.reset(), this
            }
            drawRect(t, e, r, i) {
                return this.drawShape(new bt(t, e, r, i))
            }
            drawRoundedRect(t, e, r, i, n) {
                return this.drawShape(new fh(t, e, r, i, n))
            }
            drawCircle(t, e, r) {
                return this.drawShape(new Ch(t, e, r))
            }
            drawEllipse(t, e, r, i) {
                return this.drawShape(new Ol(t, e, r, i))
            }
            drawPolygon(...t) {
                let e, r = !0;
                const i = t[0];
                i.points ? (r = i.closeStroke, e = i.points) : Array.isArray(t[0]) ? e = t[0] : e = t;
                const n = new _n(e);
                return n.closeStroke = r, this.drawShape(n), this
            }
            drawShape(t) {
                return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
            }
            clear() {
                return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
            }
            isFastRect() {
                const t = this._geometry.graphicsData;
                return t.length === 1 && t[0].shape.type === le.RECT && !t[0].matrix && !t[0].holes.length && !(t[0].lineStyle.visible && t[0].lineStyle.width)
            }
            _render(t) {
                this.finishPoly();
                const e = this._geometry;
                e.updateBatches(), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
            }
            _populateBatches() {
                const t = this._geometry,
                    e = this.blendMode,
                    r = t.batches.length;
                this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = r, this.vertexData = new Float32Array(t.points);
                for (let i = 0; i < r; i++) {
                    const n = t.batches[i],
                        a = n.style.color,
                        l = new Float32Array(this.vertexData.buffer, n.attribStart * 4 * 2, n.attribSize * 2),
                        h = new Float32Array(t.uvsFloat32.buffer, n.attribStart * 4 * 2, n.attribSize * 2),
                        c = new Uint16Array(t.indicesUint16.buffer, n.start * 2, n.size),
                        d = {
                            vertexData: l,
                            blendMode: e,
                            indices: c,
                            uvs: h,
                            _batchRGB: xi(a),
                            _tintRGB: a,
                            _texture: n.style.texture,
                            alpha: n.style.alpha,
                            worldAlpha: 1
                        };
                    this.batches[i] = d
                }
            }
            _renderBatched(t) {
                if (this.batches.length) {
                    t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                    for (let e = 0, r = this.batches.length; e < r; e++) {
                        const i = this.batches[e];
                        i.worldAlpha = this.worldAlpha * i.alpha, t.plugins[this.pluginName].render(i)
                    }
                }
            }
            _renderDirect(t) {
                const e = this._resolveDirectShader(t),
                    r = this._geometry,
                    i = this.tint,
                    n = this.worldAlpha,
                    a = e.uniforms,
                    l = r.drawCalls;
                a.translationMatrix = this.transform.worldTransform, a.tint[0] = (i >> 16 & 255) / 255 * n, a.tint[1] = (i >> 8 & 255) / 255 * n, a.tint[2] = (i & 255) / 255 * n, a.tint[3] = n, t.shader.bind(e), t.geometry.bind(r, e), t.state.set(this.state);
                for (let h = 0, c = l.length; h < c; h++) this._renderDrawCallDirect(t, r.drawCalls[h])
            }
            _renderDrawCallDirect(t, e) {
                const {
                    texArray: r,
                    type: i,
                    size: n,
                    start: a
                } = e, l = r.count;
                for (let h = 0; h < l; h++) t.texture.bind(r.elements[h], h);
                t.geometry.draw(i, n, a)
            }
            _resolveDirectShader(t) {
                let e = this.shader;
                const r = this.pluginName;
                if (!e) {
                    if (!$u[r]) {
                        const {
                            maxTextures: i
                        } = t.plugins[r], n = new Int32Array(i);
                        for (let h = 0; h < i; h++) n[h] = h;
                        const a = {
                                tint: new Float32Array([1, 1, 1, 1]),
                                translationMatrix: new Ut,
                                default: mr.from({
                                    uSamplers: n
                                }, !0)
                            },
                            l = t.plugins[r]._shader.program;
                        $u[r] = new Mr(l, a)
                    }
                    e = $u[r]
                }
                return e
            }
            _calculateBounds() {
                this.finishPoly();
                const t = this._geometry;
                if (!t.graphicsData.length) return;
                const {
                    minX: e,
                    minY: r,
                    maxX: i,
                    maxY: n
                } = t.bounds;
                this._bounds.addFrame(this.transform, e, r, i, n)
            }
            containsPoint(t) {
                return this.worldTransform.applyInverse(t, wo._TEMP_POINT), this._geometry.containsPoint(wo._TEMP_POINT)
            }
            calculateTints() {
                if (this.batchTint !== this.tint) {
                    this.batchTint = this.tint;
                    const t = xi(this.tint, Xw);
                    for (let e = 0; e < this.batches.length; e++) {
                        const r = this.batches[e],
                            i = r._batchRGB,
                            n = t[0] * i[0] * 255,
                            a = t[1] * i[1] * 255,
                            l = t[2] * i[2] * 255,
                            h = (n << 16) + (a << 8) + (l | 0);
                        r._tintRGB = (h >> 16) + (h & 65280) + ((h & 255) << 16)
                    }
                }
            }
            calculateVertices() {
                const t = this.transform._worldID;
                if (this._transformID === t) return;
                this._transformID = t;
                const e = this.transform.worldTransform,
                    r = e.a,
                    i = e.b,
                    n = e.c,
                    a = e.d,
                    l = e.tx,
                    h = e.ty,
                    c = this._geometry.points,
                    d = this.vertexData;
                let f = 0;
                for (let g = 0; g < c.length; g += 2) {
                    const y = c[g],
                        x = c[g + 1];
                    d[f++] = r * y + n * x + l, d[f++] = a * x + i * y + h
                }
            }
            closePath() {
                const t = this.currentPath;
                return t && (t.closeStroke = !0, this.finishPoly()), this
            }
            setMatrix(t) {
                return this._matrix = t, this
            }
            beginHole() {
                return this.finishPoly(), this._holeMode = !0, this
            }
            endHole() {
                return this.finishPoly(), this._holeMode = !1, this
            }
            destroy(t) {
                this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(t)
            }
        };
    ti = wo, ti.curves = _i, ti._TEMP_POINT = new gt, mv = {
        buildPoly: Hu,
        buildCircle: Us,
        buildRectangle: sg,
        buildRoundedRectangle: ag,
        buildLine: Wu,
        ArcUtils: ju,
        BezierUtils: bo,
        QuadraticUtils: Eo,
        BatchPart: og,
        FILL_COMMANDS: To,
        BATCH_POOL: Xu,
        DRAW_CALL_POOL: Gs
    }, hp = class {
        constructor(t, e) {
            this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
        }
        update(t) {
            if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
            this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
            const e = this.uvBuffer.data;
            (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
        }
    };
    const Vu = new gt,
        ug = new _n,
        cg = class extends Kt {
            constructor(t, e, r, i = Ye.TRIANGLES) {
                super(), this.geometry = t, this.shader = e, this.state = r || ei.for2d(), this.drawMode = i, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = et.ROUND_PIXELS, this.batchUvs = null
            }
            get geometry() {
                return this._geometry
            }
            set geometry(t) {
                this._geometry !== t && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = t, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
            }
            get uvBuffer() {
                return this.geometry.buffers[1]
            }
            get verticesBuffer() {
                return this.geometry.buffers[0]
            }
            set material(t) {
                this.shader = t
            }
            get material() {
                return this.shader
            }
            set blendMode(t) {
                this.state.blendMode = t
            }
            get blendMode() {
                return this.state.blendMode
            }
            set roundPixels(t) {
                this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
            }
            get roundPixels() {
                return this._roundPixels
            }
            get tint() {
                return "tint" in this.shader ? this.shader.tint : null
            }
            set tint(t) {
                this.shader.tint = t
            }
            get texture() {
                return "texture" in this.shader ? this.shader.texture : null
            }
            set texture(t) {
                this.shader.texture = t
            }
            _render(t) {
                const e = this.geometry.buffers[0].data;
                this.shader.batchable && this.drawMode === Ye.TRIANGLES && e.length < cg.BATCHABLE_SIZE * 2 ? this._renderToBatch(t) : this._renderDefault(t)
            }
            _renderDefault(t) {
                const e = this.shader;
                e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
            }
            _renderToBatch(t) {
                const e = this.geometry,
                    r = this.shader;
                r.uvMatrix && (r.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = r._tintRGB, this._texture = r.texture;
                const i = this.material.pluginName;
                t.batch.setObjectRenderer(t.plugins[i]), t.plugins[i].render(this)
            }
            calculateVertices() {
                const t = this.geometry.buffers[0],
                    e = t.data,
                    r = t._updateID;
                if (r === this.vertexDirty && this._transformID === this.transform._worldID) return;
                this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
                const i = this.transform.worldTransform,
                    n = i.a,
                    a = i.b,
                    l = i.c,
                    h = i.d,
                    c = i.tx,
                    d = i.ty,
                    f = this.vertexData;
                for (let g = 0; g < f.length / 2; g++) {
                    const y = e[g * 2],
                        x = e[g * 2 + 1];
                    f[g * 2] = n * y + l * x + c, f[g * 2 + 1] = a * y + h * x + d
                }
                if (this._roundPixels) {
                    const g = et.RESOLUTION;
                    for (let y = 0; y < f.length; ++y) f[y] = Math.round(f[y] * g) / g
                }
                this.vertexDirty = r
            }
            calculateUvs() {
                const t = this.geometry.buffers[1],
                    e = this.shader;
                e.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new hp(t, e.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
            }
            _calculateBounds() {
                this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
            }
            containsPoint(t) {
                if (!this.getBounds().contains(t.x, t.y)) return !1;
                this.worldTransform.applyInverse(t, Vu);
                const e = this.geometry.getBuffer("aVertexPosition").data,
                    r = ug.points,
                    i = this.geometry.getIndex().data,
                    n = i.length,
                    a = this.drawMode === 4 ? 3 : 1;
                for (let l = 0; l + 2 < n; l += a) {
                    const h = i[l] * 2,
                        c = i[l + 1] * 2,
                        d = i[l + 2] * 2;
                    if (r[0] = e[h], r[1] = e[h + 1], r[2] = e[c], r[3] = e[c + 1], r[4] = e[d], r[5] = e[d + 1], ug.contains(Vu.x, Vu.y)) return !0
                }
                return !1
            }
            destroy(t) {
                super.destroy(t), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
            }
        };
    Fi = cg, Fi.BATCHABLE_SIZE = 100, hs = class extends fi {
        constructor(t, e, r) {
            super();
            const i = new Zt(t),
                n = new Zt(e, !0),
                a = new Zt(r, !0, !0);
            this.addAttribute("aVertexPosition", i, 2, !1, dt.FLOAT).addAttribute("aTextureCoord", n, 2, !1, dt.FLOAT).addIndex(a), this._updateId = -1
        }
        get vertexDirtyId() {
            return this.buffers[0]._updateID
        }
    };
    var $w = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
        Vw = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
    vn = class extends Mr {
        constructor(t, e) {
            const r = {
                uSampler: t,
                alpha: 1,
                uTextureMatrix: Ut.IDENTITY,
                uColor: new Float32Array([1, 1, 1, 1])
            };
            e = Object.assign({
                tint: 16777215,
                alpha: 1,
                pluginName: "batch"
            }, e), e.uniforms && Object.assign(r, e.uniforms), super(e.program || Ke.from(Vw, $w), r), this._colorDirty = !1, this.uvMatrix = new Sa(t), this.batchable = e.program === void 0, this.pluginName = e.pluginName, this.tint = e.tint, this.alpha = e.alpha
        }
        get texture() {
            return this.uniforms.uSampler
        }
        set texture(t) {
            this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t)
        }
        set alpha(t) {
            t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
        }
        get alpha() {
            return this._alpha
        }
        set tint(t) {
            t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16), this._colorDirty = !0)
        }
        get tint() {
            return this._tint
        }
        update() {
            if (this._colorDirty) {
                this._colorDirty = !1;
                const t = this.texture.baseTexture;
                pu(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
            }
            this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
        }
    }, np = class extends hs {
        constructor(t = 100, e = 100, r = 10, i = 10) {
            super(), this.segWidth = r, this.segHeight = i, this.width = t, this.height = e, this.build()
        }
        build() {
            const t = this.segWidth * this.segHeight,
                e = [],
                r = [],
                i = [],
                n = this.segWidth - 1,
                a = this.segHeight - 1,
                l = this.width / n,
                h = this.height / a;
            for (let d = 0; d < t; d++) {
                const f = d % this.segWidth,
                    g = d / this.segWidth | 0;
                e.push(f * l, g * h), r.push(f / n, g / a)
            }
            const c = n * a;
            for (let d = 0; d < c; d++) {
                const f = d % n,
                    g = d / n | 0,
                    y = g * this.segWidth + f,
                    x = g * this.segWidth + f + 1,
                    _ = (g + 1) * this.segWidth + f,
                    E = (g + 1) * this.segWidth + f + 1;
                i.push(y, x, _, x, E, _)
            }
            this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(r), this.indexBuffer.data = new Uint16Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
        }
    }, wp = class extends hs {
        constructor(t = 200, e, r = 0) {
            super(new Float32Array(e.length * 4), new Float32Array(e.length * 4), new Uint16Array((e.length - 1) * 6)), this.points = e, this._width = t, this.textureScale = r, this.build()
        }
        get width() {
            return this._width
        }
        build() {
            const t = this.points;
            if (!t) return;
            const e = this.getBuffer("aVertexPosition"),
                r = this.getBuffer("aTextureCoord"),
                i = this.getIndex();
            if (t.length < 1) return;
            e.data.length / 4 !== t.length && (e.data = new Float32Array(t.length * 4), r.data = new Float32Array(t.length * 4), i.data = new Uint16Array((t.length - 1) * 6));
            const n = r.data,
                a = i.data;
            n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1;
            let l = 0,
                h = t[0];
            const c = this._width * this.textureScale,
                d = t.length;
            for (let g = 0; g < d; g++) {
                const y = g * 4;
                if (this.textureScale > 0) {
                    const x = h.x - t[g].x,
                        _ = h.y - t[g].y,
                        E = Math.sqrt(x * x + _ * _);
                    h = t[g], l += E / c
                } else l = g / (d - 1);
                n[y] = l, n[y + 1] = 0, n[y + 2] = l, n[y + 3] = 1
            }
            let f = 0;
            for (let g = 0; g < d - 1; g++) {
                const y = g * 2;
                a[f++] = y, a[f++] = y + 1, a[f++] = y + 2, a[f++] = y + 2, a[f++] = y + 1, a[f++] = y + 3
            }
            r.update(), i.update(), this.updateVertices()
        }
        updateVertices() {
            const t = this.points;
            if (t.length < 1) return;
            let e = t[0],
                r, i = 0,
                n = 0;
            const a = this.buffers[0].data,
                l = t.length,
                h = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            for (let c = 0; c < l; c++) {
                const d = t[c],
                    f = c * 4;
                c < t.length - 1 ? r = t[c + 1] : r = d, n = -(r.x - e.x), i = r.y - e.y;
                const g = Math.sqrt(i * i + n * n);
                g < 1e-6 ? (i = 0, n = 0) : (i /= g, n /= g, i *= h, n *= h), a[f] = d.x + i, a[f + 1] = d.y + n, a[f + 2] = d.x - i, a[f + 3] = d.y - n, e = d
            }
            this.buffers[0].update()
        }
        update() {
            this.textureScale > 0 ? this.build() : this.updateVertices()
        }
    }, Ap = class extends Fi {
        constructor(t, e, r) {
            const i = new np(t.width, t.height, e, r),
                n = new vn(Q.WHITE);
            super(i, n), this.texture = t, this.autoResize = !0
        }
        textureUpdated() {
            this._textureID = this.shader.texture._updateID;
            const t = this.geometry,
                {
                    width: e,
                    height: r
                } = this.shader.texture;
            this.autoResize && (t.width !== e || t.height !== r) && (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build())
        }
        set texture(t) {
            this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
        }
        get texture() {
            return this.shader.texture
        }
        _render(t) {
            this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(t)
        }
        destroy(t) {
            this.shader.texture.off("update", this.textureUpdated, this), super.destroy(t)
        }
    };
    const So = 10;
    up = class extends Ap {
        constructor(t, e = So, r = So, i = So, n = So) {
            super(Q.WHITE, 4, 4), this._origWidth = t.orig.width, this._origHeight = t.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = e, this._rightWidth = i, this._topHeight = r, this._bottomHeight = n, this.texture = t
        }
        textureUpdated() {
            this._textureID = this.shader.texture._updateID, this._refresh()
        }
        get vertices() {
            return this.geometry.getBuffer("aVertexPosition").data
        }
        set vertices(t) {
            this.geometry.getBuffer("aVertexPosition").data = t
        }
        updateHorizontalVertices() {
            const t = this.vertices,
                e = this._getMinScale();
            t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
        }
        updateVerticalVertices() {
            const t = this.vertices,
                e = this._getMinScale();
            t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
        }
        _getMinScale() {
            const t = this._leftWidth + this._rightWidth,
                e = this._width > t ? 1 : this._width / t,
                r = this._topHeight + this._bottomHeight,
                i = this._height > r ? 1 : this._height / r;
            return Math.min(e, i)
        }
        get width() {
            return this._width
        }
        set width(t) {
            this._width = t, this._refresh()
        }
        get height() {
            return this._height
        }
        set height(t) {
            this._height = t, this._refresh()
        }
        get leftWidth() {
            return this._leftWidth
        }
        set leftWidth(t) {
            this._leftWidth = t, this._refresh()
        }
        get rightWidth() {
            return this._rightWidth
        }
        set rightWidth(t) {
            this._rightWidth = t, this._refresh()
        }
        get topHeight() {
            return this._topHeight
        }
        set topHeight(t) {
            this._topHeight = t, this._refresh()
        }
        get bottomHeight() {
            return this._bottomHeight
        }
        set bottomHeight(t) {
            this._bottomHeight = t, this._refresh()
        }
        _refresh() {
            const t = this.texture,
                e = this.geometry.buffers[1].data;
            this._origWidth = t.orig.width, this._origHeight = t.orig.height;
            const r = 1 / this._origWidth,
                i = 1 / this._origHeight;
            e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = r * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - r * this._rightWidth, e[9] = e[11] = e[13] = e[15] = i * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - i * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
        }
    }, Sp = class extends Fi {
        constructor(t = Q.EMPTY, e, r, i, n) {
            const a = new hs(e, r, i);
            a.getBuffer("aVertexPosition").static = !1;
            const l = new vn(t);
            super(a, l, null, n), this.autoUpdate = !0
        }
        get vertices() {
            return this.geometry.getBuffer("aVertexPosition").data
        }
        set vertices(t) {
            this.geometry.getBuffer("aVertexPosition").data = t
        }
        _render(t) {
            this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(t)
        }
    }, Pp = class extends Fi {
        constructor(t, e, r = 0) {
            const i = new wp(t.height, e, r),
                n = new vn(t);
            r > 0 && (t.baseTexture.wrapMode = Nr.REPEAT), super(i, n), this.autoUpdate = !0
        }
        _render(t) {
            const e = this.geometry;
            (this.autoUpdate || e._width !== this.shader.texture.height) && (e._width = this.shader.texture.height, e.update()), super._render(t)
        }
    }, dp = class extends Kt {
        constructor(t = 1500, e, r = 16384, i = !1) {
            super();
            const n = 16384;
            r > n && (r = n), this._properties = [!1, !0, !1, !1, !1], this._maxSize = t, this._batchSize = r, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = ut.NORMAL, this.autoResize = i, this.roundPixels = !0, this.baseTexture = null, this.setProperties(e), this._tint = 0, this.tintRgb = new Float32Array(4), this.tint = 16777215
        }
        setProperties(t) {
            t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
        }
        updateTransform() {
            this.displayObjectUpdateTransform()
        }
        get tint() {
            return this._tint
        }
        set tint(t) {
            this._tint = t, xi(t, this.tintRgb)
        }
        render(t) {
            !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
        }
        onChildrenChange(t) {
            const e = Math.floor(t / this._batchSize);
            for (; this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0);
            this._bufferUpdateIDs[e] = ++this._updateID
        }
        dispose() {
            if (this._buffers) {
                for (let t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
                this._buffers = null
            }
        }
        destroy(t) {
            super.destroy(t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
        }
    };
    class dg {
        constructor(e, r, i) {
            this.geometry = new fi, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
            for (let n = 0; n < e.length; ++n) {
                let a = e[n];
                a = {
                    attributeName: a.attributeName,
                    size: a.size,
                    uploadFunction: a.uploadFunction,
                    type: a.type || dt.FLOAT,
                    offset: a.offset
                }, r[n] ? this.dynamicProperties.push(a) : this.staticProperties.push(a)
            }
            this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
        }
        initBuffers() {
            const e = this.geometry;
            let r = 0;
            this.indexBuffer = new Zt(_m(this.size), !0, !0), e.addIndex(this.indexBuffer), this.dynamicStride = 0;
            for (let l = 0; l < this.dynamicProperties.length; ++l) {
                const h = this.dynamicProperties[l];
                h.offset = r, r += h.size, this.dynamicStride += h.size
            }
            const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
            this.dynamicData = new Float32Array(i), this.dynamicDataUint32 = new Uint32Array(i), this.dynamicBuffer = new Zt(this.dynamicData, !1, !1);
            let n = 0;
            this.staticStride = 0;
            for (let l = 0; l < this.staticProperties.length; ++l) {
                const h = this.staticProperties[l];
                h.offset = n, n += h.size, this.staticStride += h.size
            }
            const a = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
            this.staticData = new Float32Array(a), this.staticDataUint32 = new Uint32Array(a), this.staticBuffer = new Zt(this.staticData, !0, !1);
            for (let l = 0; l < this.dynamicProperties.length; ++l) {
                const h = this.dynamicProperties[l];
                e.addAttribute(h.attributeName, this.dynamicBuffer, 0, h.type === dt.UNSIGNED_BYTE, h.type, this.dynamicStride * 4, h.offset * 4)
            }
            for (let l = 0; l < this.staticProperties.length; ++l) {
                const h = this.staticProperties[l];
                e.addAttribute(h.attributeName, this.staticBuffer, 0, h.type === dt.UNSIGNED_BYTE, h.type, this.staticStride * 4, h.offset * 4)
            }
        }
        uploadDynamic(e, r, i) {
            for (let n = 0; n < this.dynamicProperties.length; n++) {
                const a = this.dynamicProperties[n];
                a.uploadFunction(e, r, i, a.type === dt.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, a.offset)
            }
            this.dynamicBuffer._updateID++
        }
        uploadStatic(e, r, i) {
            for (let n = 0; n < this.staticProperties.length; n++) {
                const a = this.staticProperties[n];
                a.uploadFunction(e, r, i, a.type === dt.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, a.offset)
            }
            this.staticBuffer._updateID++
        }
        destroy() {
            this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
        }
    }
    var Yw = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
        qw = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
    Hl = class extends us {
        constructor(t) {
            super(t), this.shader = null, this.properties = null, this.tempMatrix = new Ut, this.properties = [{
                attributeName: "aVertexPosition",
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0
            }, {
                attributeName: "aPositionCoord",
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0
            }, {
                attributeName: "aRotation",
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0
            }, {
                attributeName: "aTextureCoord",
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0
            }, {
                attributeName: "aColor",
                size: 1,
                type: dt.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0
            }], this.shader = Mr.from(qw, Yw, {}), this.state = ei.for2d()
        }
        render(t) {
            const e = t.children,
                r = t._maxSize,
                i = t._batchSize,
                n = this.renderer;
            let a = e.length;
            if (a === 0) return;
            a > r && !t.autoResize && (a = r);
            let l = t._buffers;
            l || (l = t._buffers = this.generateBuffers(t));
            const h = e[0]._texture.baseTexture,
                c = h.alphaMode > 0;
            this.state.blendMode = du(t.blendMode, c), n.state.set(this.state);
            const d = n.gl,
                f = t.worldTransform.copyTo(this.tempMatrix);
            f.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = f.toArray(!0), this.shader.uniforms.uColor = vm(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, c), this.shader.uniforms.uSampler = h, this.renderer.shader.bind(this.shader);
            let g = !1;
            for (let y = 0, x = 0; y < a; y += i, x += 1) {
                let _ = a - y;
                _ > i && (_ = i), x >= l.length && l.push(this._generateOneMoreBuffer(t));
                const E = l[x];
                E.uploadDynamic(e, y, _);
                const w = t._bufferUpdateIDs[x] || 0;
                g = g || E._updateID < w, g && (E._updateID = t._updateID, E.uploadStatic(e, y, _)), n.geometry.bind(E.geometry), d.drawElements(d.TRIANGLES, _ * 6, d.UNSIGNED_SHORT, 0)
            }
        }
        generateBuffers(t) {
            const e = [],
                r = t._maxSize,
                i = t._batchSize,
                n = t._properties;
            for (let a = 0; a < r; a += i) e.push(new dg(this.properties, n, i));
            return e
        }
        _generateOneMoreBuffer(t) {
            const e = t._batchSize,
                r = t._properties;
            return new dg(this.properties, r, e)
        }
        uploadVertices(t, e, r, i, n, a) {
            let l = 0,
                h = 0,
                c = 0,
                d = 0;
            for (let f = 0; f < r; ++f) {
                const g = t[e + f],
                    y = g._texture,
                    x = g.scale.x,
                    _ = g.scale.y,
                    E = y.trim,
                    w = y.orig;
                E ? (h = E.x - g.anchor.x * w.width, l = h + E.width, d = E.y - g.anchor.y * w.height, c = d + E.height) : (l = w.width * (1 - g.anchor.x), h = w.width * -g.anchor.x, c = w.height * (1 - g.anchor.y), d = w.height * -g.anchor.y), i[a] = h * x, i[a + 1] = d * _, i[a + n] = l * x, i[a + n + 1] = d * _, i[a + n * 2] = l * x, i[a + n * 2 + 1] = c * _, i[a + n * 3] = h * x, i[a + n * 3 + 1] = c * _, a += n * 4
            }
        }
        uploadPosition(t, e, r, i, n, a) {
            for (let l = 0; l < r; l++) {
                const h = t[e + l].position;
                i[a] = h.x, i[a + 1] = h.y, i[a + n] = h.x, i[a + n + 1] = h.y, i[a + n * 2] = h.x, i[a + n * 2 + 1] = h.y, i[a + n * 3] = h.x, i[a + n * 3 + 1] = h.y, a += n * 4
            }
        }
        uploadRotation(t, e, r, i, n, a) {
            for (let l = 0; l < r; l++) {
                const h = t[e + l].rotation;
                i[a] = h, i[a + n] = h, i[a + n * 2] = h, i[a + n * 3] = h, a += n * 4
            }
        }
        uploadUvs(t, e, r, i, n, a) {
            for (let l = 0; l < r; ++l) {
                const h = t[e + l]._texture._uvs;
                h ? (i[a] = h.x0, i[a + 1] = h.y0, i[a + n] = h.x1, i[a + n + 1] = h.y1, i[a + n * 2] = h.x2, i[a + n * 2 + 1] = h.y2, i[a + n * 3] = h.x3, i[a + n * 3 + 1] = h.y3, a += n * 4) : (i[a] = 0, i[a + 1] = 0, i[a + n] = 0, i[a + n + 1] = 0, i[a + n * 2] = 0, i[a + n * 2 + 1] = 0, i[a + n * 3] = 0, i[a + n * 3 + 1] = 0, a += n * 4)
            }
        }
        uploadTint(t, e, r, i, n, a) {
            for (let l = 0; l < r; ++l) {
                const h = t[e + l],
                    c = h._texture.baseTexture.alphaMode > 0,
                    d = h.alpha,
                    f = d < 1 && c ? Ja(h._tintRGB, d) : h._tintRGB + (d * 255 << 24);
                i[a] = f, i[a + n] = f, i[a + n * 2] = f, i[a + n * 3] = f, a += n * 4
            }
        }
        destroy() {
            super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
        }
    }, Hl.extension = {
        name: "particle",
        type: Z.RendererPlugin
    }, lt.add(Hl), ps = (t => (t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", t))(ps || {});
    const Ao = {
            willReadFrequently: !0
        },
        at = class {
            static get experimentalLetterSpacingSupported() {
                let t = at._experimentalLetterSpacingSupported;
                if (t !== void 0) {
                    const e = et.ADAPTER.getCanvasRenderingContext2D().prototype;
                    t = at._experimentalLetterSpacingSupported = "letterSpacing" in e || "textLetterSpacing" in e
                }
                return t
            }
            constructor(t, e, r, i, n, a, l, h, c) {
                this.text = t, this.style = e, this.width = r, this.height = i, this.lines = n, this.lineWidths = a, this.lineHeight = l, this.maxLineWidth = h, this.fontProperties = c
            }
            static measureText(t, e, r, i = at._canvas) {
                r = r != null ? r : e.wordWrap;
                const n = e.toFontString(),
                    a = at.measureFont(n);
                a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);
                const l = i.getContext("2d", Ao);
                l.font = n;
                const h = (r ? at.wordWrap(t, e, i) : t).split(/(?:\r\n|\r|\n)/),
                    c = new Array(h.length);
                let d = 0;
                for (let x = 0; x < h.length; x++) {
                    const _ = at._measureText(h[x], e.letterSpacing, l);
                    c[x] = _, d = Math.max(d, _)
                }
                let f = d + e.strokeThickness;
                e.dropShadow && (f += e.dropShadowDistance);
                const g = e.lineHeight || a.fontSize + e.strokeThickness;
                let y = Math.max(g, a.fontSize + e.strokeThickness * 2) + (h.length - 1) * (g + e.leading);
                return e.dropShadow && (y += e.dropShadowDistance), new at(t, e, f, y, h, c, g + e.leading, d, a)
            }
            static _measureText(t, e, r) {
                let i = !1;
                at.experimentalLetterSpacingSupported && (at.experimentalLetterSpacing ? (r.letterSpacing = `${e}px`, r.textLetterSpacing = `${e}px`, i = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
                let n = r.measureText(t).width;
                return n > 0 && (i ? n -= e : n += (at.graphemeSegmenter(t).length - 1) * e), n
            }
            static wordWrap(t, e, r = at._canvas) {
                const i = r.getContext("2d", Ao);
                let n = 0,
                    a = "",
                    l = "";
                const h = Object.create(null),
                    {
                        letterSpacing: c,
                        whiteSpace: d
                    } = e,
                    f = at.collapseSpaces(d),
                    g = at.collapseNewlines(d);
                let y = !f;
                const x = e.wordWrapWidth + c,
                    _ = at.tokenize(t);
                for (let E = 0; E < _.length; E++) {
                    let w = _[E];
                    if (at.isNewline(w)) {
                        if (!g) {
                            l += at.addLine(a), y = !f, a = "", n = 0;
                            continue
                        }
                        w = " "
                    }
                    if (f) {
                        const S = at.isBreakingSpace(w),
                            T = at.isBreakingSpace(a[a.length - 1]);
                        if (S && T) continue
                    }
                    const I = at.getFromCache(w, c, h, i);
                    if (I > x)
                        if (a !== "" && (l += at.addLine(a), a = "", n = 0), at.canBreakWords(w, e.breakWords)) {
                            const S = at.wordWrapSplit(w);
                            for (let T = 0; T < S.length; T++) {
                                let P = S[T],
                                    z = P,
                                    X = 1;
                                for (; S[T + X];) {
                                    const M = S[T + X];
                                    if (!at.canBreakChars(z, M, w, T, e.breakWords)) P += M;
                                    else break;
                                    z = M, X++
                                }
                                T += X - 1;
                                const O = at.getFromCache(P, c, h, i);
                                O + n > x && (l += at.addLine(a), y = !1, a = "", n = 0), a += P, n += O
                            }
                        } else {
                            a.length > 0 && (l += at.addLine(a), a = "", n = 0);
                            const S = E === _.length - 1;
                            l += at.addLine(w, !S), y = !1, a = "", n = 0
                        }
                    else I + n > x && (y = !1, l += at.addLine(a), a = "", n = 0), (a.length > 0 || !at.isBreakingSpace(w) || y) && (a += w, n += I)
                }
                return l += at.addLine(a, !1), l
            }
            static addLine(t, e = !0) {
                return t = at.trimRight(t), t = e ? `${t}
` : t, t
            }
            static getFromCache(t, e, r, i) {
                let n = r[t];
                return typeof n != "number" && (n = at._measureText(t, e, i) + e, r[t] = n), n
            }
            static collapseSpaces(t) {
                return t === "normal" || t === "pre-line"
            }
            static collapseNewlines(t) {
                return t === "normal"
            }
            static trimRight(t) {
                if (typeof t != "string") return "";
                for (let e = t.length - 1; e >= 0; e--) {
                    const r = t[e];
                    if (!at.isBreakingSpace(r)) break;
                    t = t.slice(0, -1)
                }
                return t
            }
            static isNewline(t) {
                return typeof t != "string" ? !1 : at._newlines.includes(t.charCodeAt(0))
            }
            static isBreakingSpace(t, e) {
                return typeof t != "string" ? !1 : at._breakingSpaces.includes(t.charCodeAt(0))
            }
            static tokenize(t) {
                const e = [];
                let r = "";
                if (typeof t != "string") return e;
                for (let i = 0; i < t.length; i++) {
                    const n = t[i],
                        a = t[i + 1];
                    if (at.isBreakingSpace(n, a) || at.isNewline(n)) {
                        r !== "" && (e.push(r), r = ""), e.push(n);
                        continue
                    }
                    r += n
                }
                return r !== "" && e.push(r), e
            }
            static canBreakWords(t, e) {
                return e
            }
            static canBreakChars(t, e, r, i, n) {
                return !0
            }
            static wordWrapSplit(t) {
                return at.graphemeSegmenter(t)
            }
            static measureFont(t) {
                if (at._fonts[t]) return at._fonts[t];
                const e = {
                        ascent: 0,
                        descent: 0,
                        fontSize: 0
                    },
                    r = at._canvas,
                    i = at._context;
                i.font = t;
                const n = at.METRICS_STRING + at.BASELINE_SYMBOL,
                    a = Math.ceil(i.measureText(n).width);
                let l = Math.ceil(i.measureText(at.BASELINE_SYMBOL).width);
                const h = Math.ceil(at.HEIGHT_MULTIPLIER * l);
                if (l = l * at.BASELINE_MULTIPLIER | 0, a === 0 || h === 0) return at._fonts[t] = e, e;
                r.width = a, r.height = h, i.fillStyle = "#f00", i.fillRect(0, 0, a, h), i.font = t, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(n, 0, l);
                const c = i.getImageData(0, 0, a, h).data,
                    d = c.length,
                    f = a * 4;
                let g = 0,
                    y = 0,
                    x = !1;
                for (g = 0; g < l; ++g) {
                    for (let _ = 0; _ < f; _ += 4)
                        if (c[y + _] !== 255) {
                            x = !0;
                            break
                        }
                    if (!x) y += f;
                    else break
                }
                for (e.ascent = l - g, y = d - f, x = !1, g = h; g > l; --g) {
                    for (let _ = 0; _ < f; _ += 4)
                        if (c[y + _] !== 255) {
                            x = !0;
                            break
                        }
                    if (!x) y -= f;
                    else break
                }
                return e.descent = g - l, e.fontSize = e.ascent + e.descent, at._fonts[t] = e, e
            }
            static clearMetrics(t = "") {
                t ? delete at._fonts[t] : at._fonts = {}
            }
            static get _canvas() {
                if (!at.__canvas) {
                    let t;
                    try {
                        const e = new OffscreenCanvas(0, 0),
                            r = e.getContext("2d", Ao);
                        if (r != null && r.measureText) return at.__canvas = e, e;
                        t = et.ADAPTER.createCanvas()
                    } catch (e) {
                        t = et.ADAPTER.createCanvas()
                    }
                    t.width = t.height = 10, at.__canvas = t
                }
                return at.__canvas
            }
            static get _context() {
                return at.__context || (at.__context = at._canvas.getContext("2d", Ao)), at.__context
            }
        };
    oe = at, oe.METRICS_STRING = "|\xC9q\xC5", oe.BASELINE_SYMBOL = "M", oe.BASELINE_MULTIPLIER = 1.4, oe.HEIGHT_MULTIPLIER = 2, oe.graphemeSegmenter = (() => {
        if (typeof(Intl == null ? void 0 : Intl.Segmenter) == "function") {
            const t = new Intl.Segmenter;
            return e => [...t.segment(e)].map(r => r.segment)
        }
        return t => [...t]
    })(), oe.experimentalLetterSpacing = !1, oe._fonts = {}, oe._newlines = [10, 13], oe._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
    const Qw = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
        zs = class {
            constructor(t) {
                this.styleID = 0, this.reset(), qu(this, t, t)
            }
            clone() {
                const t = {};
                return qu(t, this, zs.defaultStyle), new zs(t)
            }
            reset() {
                qu(this, zs.defaultStyle, zs.defaultStyle)
            }
            get align() {
                return this._align
            }
            set align(t) {
                this._align !== t && (this._align = t, this.styleID++)
            }
            get breakWords() {
                return this._breakWords
            }
            set breakWords(t) {
                this._breakWords !== t && (this._breakWords = t, this.styleID++)
            }
            get dropShadow() {
                return this._dropShadow
            }
            set dropShadow(t) {
                this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
            }
            get dropShadowAlpha() {
                return this._dropShadowAlpha
            }
            set dropShadowAlpha(t) {
                this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
            }
            get dropShadowAngle() {
                return this._dropShadowAngle
            }
            set dropShadowAngle(t) {
                this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
            }
            get dropShadowBlur() {
                return this._dropShadowBlur
            }
            set dropShadowBlur(t) {
                this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
            }
            get dropShadowColor() {
                return this._dropShadowColor
            }
            set dropShadowColor(t) {
                const e = Yu(t);
                this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
            }
            get dropShadowDistance() {
                return this._dropShadowDistance
            }
            set dropShadowDistance(t) {
                this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
            }
            get fill() {
                return this._fill
            }
            set fill(t) {
                const e = Yu(t);
                this._fill !== e && (this._fill = e, this.styleID++)
            }
            get fillGradientType() {
                return this._fillGradientType
            }
            set fillGradientType(t) {
                this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
            }
            get fillGradientStops() {
                return this._fillGradientStops
            }
            set fillGradientStops(t) {
                Kw(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
            }
            get fontFamily() {
                return this._fontFamily
            }
            set fontFamily(t) {
                this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
            }
            get fontSize() {
                return this._fontSize
            }
            set fontSize(t) {
                this._fontSize !== t && (this._fontSize = t, this.styleID++)
            }
            get fontStyle() {
                return this._fontStyle
            }
            set fontStyle(t) {
                this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
            }
            get fontVariant() {
                return this._fontVariant
            }
            set fontVariant(t) {
                this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
            }
            get fontWeight() {
                return this._fontWeight
            }
            set fontWeight(t) {
                this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
            }
            get letterSpacing() {
                return this._letterSpacing
            }
            set letterSpacing(t) {
                this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
            }
            get lineHeight() {
                return this._lineHeight
            }
            set lineHeight(t) {
                this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
            }
            get leading() {
                return this._leading
            }
            set leading(t) {
                this._leading !== t && (this._leading = t, this.styleID++)
            }
            get lineJoin() {
                return this._lineJoin
            }
            set lineJoin(t) {
                this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
            }
            get miterLimit() {
                return this._miterLimit
            }
            set miterLimit(t) {
                this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
            }
            get padding() {
                return this._padding
            }
            set padding(t) {
                this._padding !== t && (this._padding = t, this.styleID++)
            }
            get stroke() {
                return this._stroke
            }
            set stroke(t) {
                const e = Yu(t);
                this._stroke !== e && (this._stroke = e, this.styleID++)
            }
            get strokeThickness() {
                return this._strokeThickness
            }
            set strokeThickness(t) {
                this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
            }
            get textBaseline() {
                return this._textBaseline
            }
            set textBaseline(t) {
                this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
            }
            get trim() {
                return this._trim
            }
            set trim(t) {
                this._trim !== t && (this._trim = t, this.styleID++)
            }
            get whiteSpace() {
                return this._whiteSpace
            }
            set whiteSpace(t) {
                this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
            }
            get wordWrap() {
                return this._wordWrap
            }
            set wordWrap(t) {
                this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
            }
            get wordWrapWidth() {
                return this._wordWrapWidth
            }
            set wordWrapWidth(t) {
                this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
            }
            toFontString() {
                const t = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
                let e = this.fontFamily;
                Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
                for (let r = e.length - 1; r >= 0; r--) {
                    let i = e[r].trim();
                    !/([\"\'])[^\'\"]+\1/.test(i) && !Qw.includes(i) && (i = `"${i}"`), e[r] = i
                }
                return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(",")}`
            }
        };
    gi = zs, gi.defaultStyle = {
        align: "left",
        breakWords: !1,
        dropShadow: !1,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: "black",
        dropShadowDistance: 5,
        fill: "black",
        fillGradientType: ps.LINEAR_VERTICAL,
        fillGradientStops: [],
        fontFamily: "Arial",
        fontSize: 26,
        fontStyle: "normal",
        fontVariant: "normal",
        fontWeight: "normal",
        leading: 0,
        letterSpacing: 0,
        lineHeight: 0,
        lineJoin: "miter",
        miterLimit: 10,
        padding: 0,
        stroke: "black",
        strokeThickness: 0,
        textBaseline: "alphabetic",
        trim: !1,
        whiteSpace: "pre",
        wordWrap: !1,
        wordWrapWidth: 100
    };

    function pg(t) {
        return typeof t == "number" ? uu(t) : (typeof t == "string" && t.startsWith("0x") && (t = t.replace("0x", "#")), t)
    }

    function Yu(t) {
        if (Array.isArray(t)) {
            for (let e = 0; e < t.length; ++e) t[e] = pg(t[e]);
            return t
        } else return pg(t)
    }

    function Kw(t, e) {
        if (!Array.isArray(t) || !Array.isArray(e) || t.length !== e.length) return !1;
        for (let r = 0; r < t.length; ++r)
            if (t[r] !== e[r]) return !1;
        return !0
    }

    function qu(t, e, r) {
        for (const i in r) Array.isArray(e[i]) ? t[i] = e[i].slice() : t[i] = e[i]
    }
    const Zw = {
            texture: !0,
            children: !1,
            baseTexture: !0
        },
        Qu = class extends Dr {
            constructor(t, e, r) {
                var a;
                let i = !1;
                r || (r = et.ADAPTER.createCanvas(), i = !0), r.width = 3, r.height = 3;
                const n = Q.from(r);
                n.orig = new bt, n.trim = new bt, super(n), this._ownCanvas = i, this.canvas = r, this.context = r.getContext("2d", {
                    willReadFrequently: !0
                }), this._resolution = (a = Qu.defaultResolution) != null ? a : et.RESOLUTION, this._autoResolution = Qu.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = t, this.style = e, this.localStyleID = -1
            }
            static get experimentalLetterSpacing() {
                return oe.experimentalLetterSpacing
            }
            static set experimentalLetterSpacing(t) {
                Tt("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), oe.experimentalLetterSpacing = t
            }
            updateText(t) {
                const e = this._style;
                if (this.localStyleID !== e.styleID && (this.dirty = !0, this.localStyleID = e.styleID), !this.dirty && t) return;
                this._font = this._style.toFontString();
                const r = this.context,
                    i = oe.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                    n = i.width,
                    a = i.height,
                    l = i.lines,
                    h = i.lineHeight,
                    c = i.lineWidths,
                    d = i.maxLineWidth,
                    f = i.fontProperties;
                this.canvas.width = Math.ceil(Math.ceil(Math.max(1, n) + e.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, a) + e.padding * 2) * this._resolution), r.scale(this._resolution, this._resolution), r.clearRect(0, 0, this.canvas.width, this.canvas.height), r.font = this._font, r.lineWidth = e.strokeThickness, r.textBaseline = e.textBaseline, r.lineJoin = e.lineJoin, r.miterLimit = e.miterLimit;
                let g, y;
                const x = e.dropShadow ? 2 : 1;
                for (let _ = 0; _ < x; ++_) {
                    const E = e.dropShadow && _ === 0,
                        w = E ? Math.ceil(Math.max(1, a) + e.padding * 2) : 0,
                        I = w * this._resolution;
                    if (E) {
                        r.fillStyle = "black", r.strokeStyle = "black";
                        const T = e.dropShadowColor,
                            P = xi(typeof T == "number" ? T : Za(T)),
                            z = e.dropShadowBlur * this._resolution,
                            X = e.dropShadowDistance * this._resolution;
                        r.shadowColor = `rgba(${P[0]*255},${P[1]*255},${P[2]*255},${e.dropShadowAlpha})`, r.shadowBlur = z, r.shadowOffsetX = Math.cos(e.dropShadowAngle) * X, r.shadowOffsetY = Math.sin(e.dropShadowAngle) * X + I
                    } else r.fillStyle = this._generateFillStyle(e, l, i), r.strokeStyle = e.stroke, r.shadowColor = "black", r.shadowBlur = 0, r.shadowOffsetX = 0, r.shadowOffsetY = 0;
                    let S = (h - f.fontSize) / 2;
                    h - f.fontSize < 0 && (S = 0);
                    for (let T = 0; T < l.length; T++) g = e.strokeThickness / 2, y = e.strokeThickness / 2 + T * h + f.ascent + S, e.align === "right" ? g += d - c[T] : e.align === "center" && (g += (d - c[T]) / 2), e.stroke && e.strokeThickness && this.drawLetterSpacing(l[T], g + e.padding, y + e.padding - w, !0), e.fill && this.drawLetterSpacing(l[T], g + e.padding, y + e.padding - w)
                }
                this.updateTexture()
            }
            drawLetterSpacing(t, e, r, i = !1) {
                const n = this._style.letterSpacing;
                let a = !1;
                if (oe.experimentalLetterSpacingSupported && (oe.experimentalLetterSpacing ? (this.context.letterSpacing = `${n}px`, this.context.textLetterSpacing = `${n}px`, a = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), n === 0 || a) {
                    i ? this.context.strokeText(t, e, r) : this.context.fillText(t, e, r);
                    return
                }
                let l = e;
                const h = oe.graphemeSegmenter(t);
                let c = this.context.measureText(t).width,
                    d = 0;
                for (let f = 0; f < h.length; ++f) {
                    const g = h[f];
                    i ? this.context.strokeText(g, l, r) : this.context.fillText(g, l, r);
                    let y = "";
                    for (let x = f + 1; x < h.length; ++x) y += h[x];
                    d = this.context.measureText(y).width, l += c - d + n, c = d
                }
            }
            updateTexture() {
                const t = this.canvas;
                if (this._style.trim) {
                    const a = Sm(t);
                    a.data && (t.width = a.width, t.height = a.height, this.context.putImageData(a.data, 0, 0))
                }
                const e = this._texture,
                    r = this._style,
                    i = r.trim ? 0 : r.padding,
                    n = e.baseTexture;
                e.trim.width = e._frame.width = t.width / this._resolution, e.trim.height = e._frame.height = t.height / this._resolution, e.trim.x = -i, e.trim.y = -i, e.orig.width = e._frame.width - i * 2, e.orig.height = e._frame.height - i * 2, this._onTextureUpdate(), n.setRealSize(t.width, t.height, this._resolution), e.updateUvs(), this.dirty = !1
            }
            _render(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), super._render(t)
            }
            updateTransform() {
                this.updateText(!0), super.updateTransform()
            }
            getBounds(t, e) {
                return this.updateText(!0), this._textureID === -1 && (t = !1), super.getBounds(t, e)
            }
            getLocalBounds(t) {
                return this.updateText(!0), super.getLocalBounds.call(this, t)
            }
            _calculateBounds() {
                this.calculateVertices(), this._bounds.addQuad(this.vertexData)
            }
            _generateFillStyle(t, e, r) {
                const i = t.fill;
                if (Array.isArray(i)) {
                    if (i.length === 1) return i[0]
                } else return i;
                let n;
                const a = t.dropShadow ? t.dropShadowDistance : 0,
                    l = t.padding || 0,
                    h = this.canvas.width / this._resolution - a - l * 2,
                    c = this.canvas.height / this._resolution - a - l * 2,
                    d = i.slice(),
                    f = t.fillGradientStops.slice();
                if (!f.length) {
                    const g = d.length + 1;
                    for (let y = 1; y < g; ++y) f.push(y / g)
                }
                if (d.unshift(i[0]), f.unshift(0), d.push(i[i.length - 1]), f.push(1), t.fillGradientType === ps.LINEAR_VERTICAL) {
                    n = this.context.createLinearGradient(h / 2, l, h / 2, c + l);
                    const g = r.fontProperties.fontSize + t.strokeThickness;
                    for (let y = 0; y < e.length; y++) {
                        const x = r.lineHeight * (y - 1) + g,
                            _ = r.lineHeight * y;
                        let E = _;
                        y > 0 && x > _ && (E = (_ + x) / 2);
                        const w = _ + g,
                            I = r.lineHeight * (y + 1);
                        let S = w;
                        y + 1 < e.length && I < w && (S = (w + I) / 2);
                        const T = (S - E) / c;
                        for (let P = 0; P < d.length; P++) {
                            let z = 0;
                            typeof f[P] == "number" ? z = f[P] : z = P / d.length;
                            let X = Math.min(1, Math.max(0, E / c + z * T));
                            X = Number(X.toFixed(5)), n.addColorStop(X, d[P])
                        }
                    }
                } else {
                    n = this.context.createLinearGradient(l, c / 2, h + l, c / 2);
                    const g = d.length + 1;
                    let y = 1;
                    for (let x = 0; x < d.length; x++) {
                        let _;
                        typeof f[x] == "number" ? _ = f[x] : _ = y / g, n.addColorStop(_, d[x]), y++
                    }
                }
                return n
            }
            destroy(t) {
                typeof t == "boolean" && (t = {
                    children: t
                }), t = Object.assign({}, Zw, t), super.destroy(t), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
            }
            get width() {
                return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
            }
            set width(t) {
                this.updateText(!0);
                const e = qi(this.scale.x) || 1;
                this.scale.x = e * t / this._texture.orig.width, this._width = t
            }
            get height() {
                return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
            }
            set height(t) {
                this.updateText(!0);
                const e = qi(this.scale.y) || 1;
                this.scale.y = e * t / this._texture.orig.height, this._height = t
            }
            get style() {
                return this._style
            }
            set style(t) {
                t = t || {}, t instanceof gi ? this._style = t : this._style = new gi(t), this.localStyleID = -1, this.dirty = !0
            }
            get text() {
                return this._text
            }
            set text(t) {
                t = String(t != null ? t : ""), this._text !== t && (this._text = t, this.dirty = !0)
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
            }
        };
    fs = Qu, fs.defaultAutoResolution = !0, tp = class {
        constructor(t) {
            this.maxItemsPerFrame = t, this.itemsLeft = 0
        }
        beginFrame() {
            this.itemsLeft = this.maxItemsPerFrame
        }
        allowedToUpload() {
            return this.itemsLeft-- > 0
        }
    };

    function Jw(t, e) {
        var r;
        let i = !1;
        if ((r = t == null ? void 0 : t._textures) != null && r.length) {
            for (let n = 0; n < t._textures.length; n++)
                if (t._textures[n] instanceof Q) {
                    const a = t._textures[n].baseTexture;
                    e.includes(a) || (e.push(a), i = !0)
                }
        }
        return i
    }

    function tS(t, e) {
        if (t.baseTexture instanceof mt) {
            const r = t.baseTexture;
            return e.includes(r) || e.push(r), !0
        }
        return !1
    }

    function eS(t, e) {
        if (t._texture && t._texture instanceof Q) {
            const r = t._texture.baseTexture;
            return e.includes(r) || e.push(r), !0
        }
        return !1
    }

    function rS(t, e) {
        return e instanceof fs ? (e.updateText(!0), !0) : !1
    }

    function iS(t, e) {
        if (e instanceof gi) {
            const r = e.toFontString();
            return oe.measureFont(r), !0
        }
        return !1
    }

    function nS(t, e) {
        if (t instanceof fs) {
            e.includes(t.style) || e.push(t.style), e.includes(t) || e.push(t);
            const r = t._texture.baseTexture;
            return e.includes(r) || e.push(r), !0
        }
        return !1
    }

    function sS(t, e) {
        return t instanceof gi ? (e.includes(t) || e.push(t), !0) : !1
    }
    const fg = class {
        constructor(t) {
            this.limiter = new tp(fg.uploadsPerFrame), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
                this.queue && this.prepareItems()
            }, this.registerFindHook(nS), this.registerFindHook(sS), this.registerFindHook(Jw), this.registerFindHook(tS), this.registerFindHook(eS), this.registerUploadHook(rS), this.registerUploadHook(iS)
        }
        upload(t) {
            return new Promise(e => {
                t && this.add(t), this.queue.length ? (this.completes.push(e), this.ticking || (this.ticking = !0, Vt.system.addOnce(this.tick, this, vi.UTILITY))) : e()
            })
        }
        tick() {
            setTimeout(this.delayedTick, 0)
        }
        prepareItems() {
            for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
                const t = this.queue[0];
                let e = !1;
                if (t && !t._destroyed) {
                    for (let r = 0, i = this.uploadHooks.length; r < i; r++)
                        if (this.uploadHooks[r](this.uploadHookHelper, t)) {
                            this.queue.shift(), e = !0;
                            break
                        }
                }
                e || this.queue.shift()
            }
            if (this.queue.length) Vt.system.addOnce(this.tick, this, vi.UTILITY);
            else {
                this.ticking = !1;
                const t = this.completes.slice(0);
                this.completes.length = 0;
                for (let e = 0, r = t.length; e < r; e++) t[e]()
            }
        }
        registerFindHook(t) {
            return t && this.addHooks.push(t), this
        }
        registerUploadHook(t) {
            return t && this.uploadHooks.push(t), this
        }
        add(t) {
            for (let e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++);
            if (t instanceof Kt)
                for (let e = t.children.length - 1; e >= 0; e--) this.add(t.children[e]);
            return this
        }
        destroy() {
            this.ticking && Vt.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
        }
    };
    bs = fg, bs.uploadsPerFrame = 4, Object.defineProperties(et, {
        UPLOADS_PER_FRAME: {
            get() {
                return bs.uploadsPerFrame
            },
            set(t) {
                Tt("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), bs.uploadsPerFrame = t
            }
        }
    });

    function mg(t, e) {
        return e instanceof mt ? (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0) : !1
    }

    function aS(t, e) {
        if (!(e instanceof ti)) return !1;
        const {
            geometry: r
        } = e;
        e.finishPoly(), r.updateBatches();
        const {
            batches: i
        } = r;
        for (let n = 0; n < i.length; n++) {
            const {
                texture: a
            } = i[n].style;
            a && mg(t, a.baseTexture)
        }
        return r.batchable || t.geometry.bind(r, e._resolveDirectShader(t)), !0
    }

    function oS(t, e) {
        return t instanceof ti ? (e.push(t), !0) : !1
    }
    Zl = class extends bs {
        constructor(t) {
            super(t), this.uploadHookHelper = this.renderer, this.registerFindHook(oS), this.registerUploadHook(mg), this.registerUploadHook(aS)
        }
    }, Zl.extension = {
        name: "prepare",
        type: Z.RendererSystem
    }, lt.add(Zl), cv = class {
        constructor(t) {
            this.maxMilliseconds = t, this.frameStart = 0
        }
        beginFrame() {
            this.frameStart = Date.now()
        }
        allowedToUpload() {
            return Date.now() - this.frameStart < this.maxMilliseconds
        }
    }, Es = class extends Dr {
        constructor(t, e = !0) {
            super(t[0] instanceof Q ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = e, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = t
        }
        stop() {
            this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Vt.shared.remove(this.update, this), this._isConnectedToTicker = !1))
        }
        play() {
            this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Vt.shared.add(this.update, this, vi.HIGH), this._isConnectedToTicker = !0))
        }
        gotoAndStop(t) {
            this.stop(), this.currentFrame = t
        }
        gotoAndPlay(t) {
            this.currentFrame = t, this.play()
        }
        update(t) {
            if (!this._playing) return;
            const e = this.animationSpeed * t,
                r = this.currentFrame;
            if (this._durations !== null) {
                let i = this._currentTime % 1 * this._durations[this.currentFrame];
                for (i += e / 60 * 1e3; i < 0;) this._currentTime--, i += this._durations[this.currentFrame];
                const n = Math.sign(this.animationSpeed * t);
                for (this._currentTime = Math.floor(this._currentTime); i >= this._durations[this.currentFrame];) i -= this._durations[this.currentFrame] * n, this._currentTime += n;
                this._currentTime += i / this._durations[this.currentFrame]
            } else this._currentTime += e;
            this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : r !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < r || this.animationSpeed < 0 && this.currentFrame > r) && this.onLoop(), this.updateTexture())
        }
        updateTexture() {
            const t = this.currentFrame;
            this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
        }
        destroy(t) {
            this.stop(), super.destroy(t), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
        }
        static fromFrames(t) {
            const e = [];
            for (let r = 0; r < t.length; ++r) e.push(Q.from(t[r]));
            return new Es(e)
        }
        static fromImages(t) {
            const e = [];
            for (let r = 0; r < t.length; ++r) e.push(Q.from(t[r]));
            return new Es(e)
        }
        get totalFrames() {
            return this._textures.length
        }
        get textures() {
            return this._textures
        }
        set textures(t) {
            if (t[0] instanceof Q) this._textures = t, this._durations = null;
            else {
                this._textures = [], this._durations = [];
                for (let e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
            }
            this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
        }
        get currentFrame() {
            let t = Math.floor(this._currentTime) % this._textures.length;
            return t < 0 && (t += this._textures.length), t
        }
        set currentFrame(t) {
            if (t < 0 || t > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
            const e = this.currentFrame;
            this._currentTime = t, e !== this.currentFrame && this.updateTexture()
        }
        get playing() {
            return this._playing
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(t) {
            t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Vt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Vt.shared.add(this.update, this), this._isConnectedToTicker = !0))
        }
    };
    const Hs = new gt;
    lh = class extends Dr {
        constructor(t, e = 100, r = 100) {
            super(t), this.tileTransform = new gs, this._width = e, this._height = r, this.uvMatrix = this.texture.uvMatrix || new Sa(t), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1
        }
        get clampMargin() {
            return this.uvMatrix.clampMargin
        }
        set clampMargin(t) {
            this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
        }
        get tileScale() {
            return this.tileTransform.scale
        }
        set tileScale(t) {
            this.tileTransform.scale.copyFrom(t)
        }
        get tilePosition() {
            return this.tileTransform.position
        }
        set tilePosition(t) {
            this.tileTransform.position.copyFrom(t)
        }
        _onTextureUpdate() {
            this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
        }
        _render(t) {
            const e = this._texture;
            !e || !e.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
        }
        _calculateBounds() {
            const t = this._width * -this._anchor._x,
                e = this._height * -this._anchor._y,
                r = this._width * (1 - this._anchor._x),
                i = this._height * (1 - this._anchor._y);
            this._bounds.addFrame(this.transform, t, e, r, i)
        }
        getLocalBounds(t) {
            return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new bt), t = this._localBoundsRect), this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
        }
        containsPoint(t) {
            this.worldTransform.applyInverse(t, Hs);
            const e = this._width,
                r = this._height,
                i = -e * this.anchor._x;
            if (Hs.x >= i && Hs.x < i + e) {
                const n = -r * this.anchor._y;
                if (Hs.y >= n && Hs.y < n + r) return !0
            }
            return !1
        }
        destroy(t) {
            super.destroy(t), this.tileTransform = null, this.uvMatrix = null
        }
        static from(t, e) {
            const r = t instanceof Q ? t : Q.from(t, e);
            return new lh(r, e.width, e.height)
        }
        get width() {
            return this._width
        }
        set width(t) {
            this._width = t
        }
        get height() {
            return this._height
        }
        set height(t) {
            this._height = t
        }
    };
    var lS = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
        hS = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
        uS = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
        gg = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
        cS = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
    const Po = new Ut;
    hh = class extends us {
        constructor(t) {
            super(t), t.runners.contextChange.add(this), this.quad = new th, this.state = ei.for2d()
        }
        contextChange() {
            const t = this.renderer,
                e = {
                    globals: t.globalUniforms
                };
            this.simpleShader = Mr.from(gg, cS, e), this.shader = t.context.webGLVersion > 1 ? Mr.from(hS, lS, e) : Mr.from(gg, uS, e)
        }
        render(t) {
            const e = this.renderer,
                r = this.quad;
            let i = r.vertices;
            i[0] = i[6] = t._width * -t.anchor.x, i[1] = i[3] = t._height * -t.anchor.y, i[2] = i[4] = t._width * (1 - t.anchor.x), i[5] = i[7] = t._height * (1 - t.anchor.y);
            const n = t.uvRespectAnchor ? t.anchor.x : 0,
                a = t.uvRespectAnchor ? t.anchor.y : 0;
            i = r.uvs, i[0] = i[6] = -n, i[1] = i[3] = -a, i[2] = i[4] = 1 - n, i[5] = i[7] = 1 - a, r.invalidate();
            const l = t._texture,
                h = l.baseTexture,
                c = h.alphaMode > 0,
                d = t.tileTransform.localTransform,
                f = t.uvMatrix;
            let g = h.isPowerOfTwo && l.frame.width === h.width && l.frame.height === h.height;
            g && (h._glTextures[e.CONTEXT_UID] ? g = h.wrapMode !== Nr.CLAMP : h.wrapMode === Nr.CLAMP && (h.wrapMode = Nr.REPEAT));
            const y = g ? this.simpleShader : this.shader,
                x = l.width,
                _ = l.height,
                E = t._width,
                w = t._height;
            Po.set(d.a * x / E, d.b * x / w, d.c * _ / E, d.d * _ / w, d.tx / E, d.ty / w), Po.invert(), g ? Po.prepend(f.mapCoord) : (y.uniforms.uMapCoord = f.mapCoord.toArray(!0), y.uniforms.uClampFrame = f.uClampFrame, y.uniforms.uClampOffset = f.uClampOffset), y.uniforms.uTransform = Po.toArray(!0), y.uniforms.uColor = pu(t.tint, t.worldAlpha, y.uniforms.uColor, c), y.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), y.uniforms.uSampler = l, e.shader.bind(y), e.geometry.bind(r), this.state.blendMode = du(t.blendMode, c), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
        }
    }, hh.extension = {
        name: "tilingSprite",
        type: Z.RendererPlugin
    }, lt.add(hh);
    const js = class {
        constructor(t, e, r = null) {
            this.linkedSheets = [], this._texture = t instanceof Q ? t : null, this.baseTexture = t instanceof mt ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
            const i = this.baseTexture.resource;
            this.resolution = this._updateResolution(r || (i ? i.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
        }
        _updateResolution(t = null) {
            const {
                scale: e
            } = this.data.meta;
            let r = ni(t, null);
            return r === null && (r = parseFloat(e != null ? e : "1")), r !== 1 && this.baseTexture.setResolution(r), r
        }
        parse() {
            return new Promise(t => {
                this._callback = t, this._batchIndex = 0, this._frameKeys.length <= js.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
            })
        }
        _processFrames(t) {
            let e = t;
            const r = js.BATCH_SIZE;
            for (; e - t < r && e < this._frameKeys.length;) {
                const i = this._frameKeys[e],
                    n = this._frames[i],
                    a = n.frame;
                if (a) {
                    let l = null,
                        h = null;
                    const c = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame,
                        d = new bt(0, 0, Math.floor(c.w) / this.resolution, Math.floor(c.h) / this.resolution);
                    n.rotated ? l = new bt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : l = new bt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), n.trimmed !== !1 && n.spriteSourceSize && (h = new bt(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[i] = new Q(this.baseTexture, l, d, h, n.rotated ? 2 : 0, n.anchor), Q.addToCache(this.textures[i], i)
                }
                e++
            }
        }
        _processAnimations() {
            const t = this.data.animations || {};
            for (const e in t) {
                this.animations[e] = [];
                for (let r = 0; r < t[e].length; r++) {
                    const i = t[e][r];
                    this.animations[e].push(this.textures[i])
                }
            }
        }
        _parseComplete() {
            const t = this._callback;
            this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * js.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
                this._batchIndex * js.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
            }, 0)
        }
        destroy(t = !1) {
            var e;
            for (const r in this.textures) this.textures[r].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) == null || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = []
        }
    };
    Pa = js, Pa.BATCH_SIZE = 1e3;
    const dS = ["jpg", "png", "jpeg", "avif", "webp"];

    function yg(t, e, r) {
        const i = {};
        if (t.forEach(n => {
                i[n] = e
            }), Object.keys(e.textures).forEach(n => {
                i[n] = e.textures[n]
            }), !r) {
            const n = ce.dirname(t[0]);
            e.linkedSheets.forEach((a, l) => {
                const h = yg([`${n}/${e.data.meta.related_multi_packs[l]}`], a, !0);
                Object.assign(i, h)
            })
        }
        return i
    }
    Hp = {
        extension: Z.Asset,
        cache: {
            test: t => t instanceof Pa,
            getCacheableAssets: (t, e) => yg(t, e, !1)
        },
        resolver: {
            test: t => {
                const e = t.split("?")[0].split("."),
                    r = e.pop(),
                    i = e.pop();
                return r === "json" && dS.includes(i)
            },
            parse: t => {
                var i;
                var e;
                const r = t.split(".");
                return {
                    resolution: parseFloat((i = (e = et.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) != null ? i : "1"),
                    format: r[r.length - 2],
                    src: t
                }
            }
        },
        loader: {
            extension: {
                type: Z.LoadParser,
                priority: pr.Normal
            },
            async testParse(t, e) {
                return ce.extname(e.src).toLowerCase() === ".json" && !!t.frames
            },
            async parse(t, e, r) {
                var i, n;
                let a = ce.dirname(e.src);
                a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
                let l = a + t.meta.image;
                l = Da(l, e.src);
                const h = (await r.load([l]))[l],
                    c = new Pa(h.baseTexture, t, e.src);
                await c.parse();
                const d = (i = t == null ? void 0 : t.meta) == null ? void 0 : i.related_multi_packs;
                if (Array.isArray(d)) {
                    const f = [];
                    for (const y of d) {
                        if (typeof y != "string") continue;
                        let x = a + y;
                        (n = e.data) != null && n.ignoreMultiPack || (x = Da(x, e.src), f.push(r.load({
                            src: x,
                            data: {
                                ignoreMultiPack: !0
                            }
                        })))
                    }
                    const g = await Promise.all(f);
                    c.linkedSheets = g, g.forEach(y => {
                        y.linkedSheets = [c].concat(c.linkedSheets.filter(x => x !== y))
                    })
                }
                return c
            },
            unload(t) {
                t.destroy(!0)
            }
        }
    }, lt.add(Hp), ss = class {
        constructor() {
            this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
        }
    }, ms = class {
        static test(t) {
            return typeof t == "string" && t.startsWith("info face=")
        }
        static parse(t) {
            const e = t.match(/^[a-z]+\s+.+$/gm),
                r = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: []
                };
            for (const n in e) {
                const a = e[n].match(/^[a-z]+/gm)[0],
                    l = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                    h = {};
                for (const c in l) {
                    const d = l[c].split("="),
                        f = d[0],
                        g = d[1].replace(/"/gm, ""),
                        y = parseFloat(g),
                        x = isNaN(y) ? g : y;
                    h[f] = x
                }
                r[a].push(h)
            }
            const i = new ss;
            return r.info.forEach(n => i.info.push({
                face: n.face,
                size: parseInt(n.size, 10)
            })), r.common.forEach(n => i.common.push({
                lineHeight: parseInt(n.lineHeight, 10)
            })), r.page.forEach(n => i.page.push({
                id: parseInt(n.id, 10),
                file: n.file
            })), r.char.forEach(n => i.char.push({
                id: parseInt(n.id, 10),
                page: parseInt(n.page, 10),
                x: parseInt(n.x, 10),
                y: parseInt(n.y, 10),
                width: parseInt(n.width, 10),
                height: parseInt(n.height, 10),
                xoffset: parseInt(n.xoffset, 10),
                yoffset: parseInt(n.yoffset, 10),
                xadvance: parseInt(n.xadvance, 10)
            })), r.kerning.forEach(n => i.kerning.push({
                first: parseInt(n.first, 10),
                second: parseInt(n.second, 10),
                amount: parseInt(n.amount, 10)
            })), r.distanceField.forEach(n => i.distanceField.push({
                distanceRange: parseInt(n.distanceRange, 10),
                fieldType: n.fieldType
            })), i
        }
    }, Ra = class {
        static test(t) {
            const e = t;
            return "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
        }
        static parse(t) {
            const e = new ss,
                r = t.getElementsByTagName("info"),
                i = t.getElementsByTagName("common"),
                n = t.getElementsByTagName("page"),
                a = t.getElementsByTagName("char"),
                l = t.getElementsByTagName("kerning"),
                h = t.getElementsByTagName("distanceField");
            for (let c = 0; c < r.length; c++) e.info.push({
                face: r[c].getAttribute("face"),
                size: parseInt(r[c].getAttribute("size"), 10)
            });
            for (let c = 0; c < i.length; c++) e.common.push({
                lineHeight: parseInt(i[c].getAttribute("lineHeight"), 10)
            });
            for (let c = 0; c < n.length; c++) e.page.push({
                id: parseInt(n[c].getAttribute("id"), 10) || 0,
                file: n[c].getAttribute("file")
            });
            for (let c = 0; c < a.length; c++) {
                const d = a[c];
                e.char.push({
                    id: parseInt(d.getAttribute("id"), 10),
                    page: parseInt(d.getAttribute("page"), 10) || 0,
                    x: parseInt(d.getAttribute("x"), 10),
                    y: parseInt(d.getAttribute("y"), 10),
                    width: parseInt(d.getAttribute("width"), 10),
                    height: parseInt(d.getAttribute("height"), 10),
                    xoffset: parseInt(d.getAttribute("xoffset"), 10),
                    yoffset: parseInt(d.getAttribute("yoffset"), 10),
                    xadvance: parseInt(d.getAttribute("xadvance"), 10)
                })
            }
            for (let c = 0; c < l.length; c++) e.kerning.push({
                first: parseInt(l[c].getAttribute("first"), 10),
                second: parseInt(l[c].getAttribute("second"), 10),
                amount: parseInt(l[c].getAttribute("amount"), 10)
            });
            for (let c = 0; c < h.length; c++) e.distanceField.push({
                fieldType: h[c].getAttribute("fieldType"),
                distanceRange: parseInt(h[c].getAttribute("distanceRange"), 10)
            });
            return e
        }
    }, Ma = class {
        static test(t) {
            return typeof t == "string" && t.includes("<font>") ? Ra.test(et.ADAPTER.parseXML(t)) : !1
        }
        static parse(t) {
            return Ra.parse(et.ADAPTER.parseXML(t))
        }
    };
    const Ku = [ms, Ra, Ma];
    Xp = function(t) {
        for (let e = 0; e < Ku.length; e++)
            if (Ku[e].test(t)) return Ku[e];
        return null
    };

    function pS(t, e, r, i, n, a) {
        const l = r.fill;
        if (Array.isArray(l)) {
            if (l.length === 1) return l[0]
        } else return l;
        let h;
        const c = r.dropShadow ? r.dropShadowDistance : 0,
            d = r.padding || 0,
            f = t.width / i - c - d * 2,
            g = t.height / i - c - d * 2,
            y = l.slice(),
            x = r.fillGradientStops.slice();
        if (!x.length) {
            const _ = y.length + 1;
            for (let E = 1; E < _; ++E) x.push(E / _)
        }
        if (y.unshift(l[0]), x.unshift(0), y.push(l[l.length - 1]), x.push(1), r.fillGradientType === ps.LINEAR_VERTICAL) {
            h = e.createLinearGradient(f / 2, d, f / 2, g + d);
            let _ = 0;
            const E = (a.fontProperties.fontSize + r.strokeThickness) / g;
            for (let w = 0; w < n.length; w++) {
                const I = a.lineHeight * w;
                for (let S = 0; S < y.length; S++) {
                    let T = 0;
                    typeof x[S] == "number" ? T = x[S] : T = S / y.length;
                    const P = I / g + T * E;
                    let z = Math.max(_, P);
                    z = Math.min(z, 1), h.addColorStop(z, y[S]), _ = z
                }
            }
        } else {
            h = e.createLinearGradient(d, g / 2, f + d, g / 2);
            const _ = y.length + 1;
            let E = 1;
            for (let w = 0; w < y.length; w++) {
                let I;
                typeof x[w] == "number" ? I = x[w] : I = E / _, h.addColorStop(I, y[w]), E++
            }
        }
        return h
    }

    function fS(t, e, r, i, n, a, l) {
        const h = r.text,
            c = r.fontProperties;
        e.translate(i, n), e.scale(a, a);
        const d = l.strokeThickness / 2,
            f = -(l.strokeThickness / 2);
        if (e.font = l.toFontString(), e.lineWidth = l.strokeThickness, e.textBaseline = l.textBaseline, e.lineJoin = l.lineJoin, e.miterLimit = l.miterLimit, e.fillStyle = pS(t, e, l, a, [h], r), e.strokeStyle = l.stroke, l.dropShadow) {
            const g = l.dropShadowColor,
                y = xi(typeof g == "number" ? g : Za(g)),
                x = l.dropShadowBlur * a,
                _ = l.dropShadowDistance * a;
            e.shadowColor = `rgba(${y[0]*255},${y[1]*255},${y[2]*255},${l.dropShadowAlpha})`, e.shadowBlur = x, e.shadowOffsetX = Math.cos(l.dropShadowAngle) * _, e.shadowOffsetY = Math.sin(l.dropShadowAngle) * _
        } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
        l.stroke && l.strokeThickness && e.strokeText(h, d, f + r.lineHeight - c.descent), l.fill && e.fillText(h, d, f + r.lineHeight - c.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)"
    }

    function Co(t) {
        return t.codePointAt ? t.codePointAt(0) : t.charCodeAt(0)
    }

    function vg(t) {
        return Array.from ? Array.from(t) : t.split("")
    }

    function mS(t) {
        typeof t == "string" && (t = [t]);
        const e = [];
        for (let r = 0, i = t.length; r < i; r++) {
            const n = t[r];
            if (Array.isArray(n)) {
                if (n.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
                const a = n[0].charCodeAt(0),
                    l = n[1].charCodeAt(0);
                if (l < a) throw new Error("[BitmapFont]: Invalid character range.");
                for (let h = a, c = l; h <= c; h++) e.push(String.fromCharCode(h))
            } else e.push(...vg(n))
        }
        if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
        return e
    }
    const br = class {
        constructor(t, e, r) {
            var f;
            var i;
            const [n] = t.info, [a] = t.common, [l] = t.page, [h] = t.distanceField, c = ni(l.file), d = {};
            this._ownsTextures = r, this.font = n.face, this.size = n.size, this.lineHeight = a.lineHeight / c, this.chars = {}, this.pageTextures = d;
            for (let g = 0; g < t.page.length; g++) {
                const {
                    id: y,
                    file: x
                } = t.page[g];
                d[y] = e instanceof Array ? e[g] : e[x], h != null && h.fieldType && h.fieldType !== "none" && (d[y].baseTexture.alphaMode = tr.NO_PREMULTIPLIED_ALPHA, d[y].baseTexture.mipmap = fr.OFF)
            }
            for (let g = 0; g < t.char.length; g++) {
                const {
                    id: y,
                    page: x
                } = t.char[g];
                let {
                    x: _,
                    y: E,
                    width: w,
                    height: I,
                    xoffset: S,
                    yoffset: T,
                    xadvance: P
                } = t.char[g];
                _ /= c, E /= c, w /= c, I /= c, S /= c, T /= c, P /= c;
                const z = new bt(_ + d[x].frame.x / c, E + d[x].frame.y / c, w, I);
                this.chars[y] = {
                    xOffset: S,
                    yOffset: T,
                    xAdvance: P,
                    kerning: {},
                    texture: new Q(d[x].baseTexture, z),
                    page: x
                }
            }
            for (let g = 0; g < t.kerning.length; g++) {
                let {
                    first: y,
                    second: x,
                    amount: _
                } = t.kerning[g];
                y /= c, x /= c, _ /= c, this.chars[x] && (this.chars[x].kerning[y] = _)
            }
            this.distanceFieldRange = h == null ? void 0 : h.distanceRange, this.distanceFieldType = (f = (i = h == null ? void 0 : h.fieldType) == null ? void 0 : i.toLowerCase()) != null ? f : "none"
        }
        destroy() {
            for (const t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null;
            for (const t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
            this.chars = null, this.pageTextures = null
        }
        static install(t, e, r) {
            let i;
            if (t instanceof ss) i = t;
            else {
                const a = Xp(t);
                if (!a) throw new Error("Unrecognized data format for font.");
                i = a.parse(t)
            }
            e instanceof Q && (e = [e]);
            const n = new br(i, e, r);
            return br.available[n.font] = n, n
        }
        static uninstall(t) {
            const e = br.available[t];
            if (!e) throw new Error(`No font found named '${t}'`);
            e.destroy(), delete br.available[t]
        }
        static from(t, e, r) {
            if (!t) throw new Error("[BitmapFont] Property `name` is required.");
            const z = Object.assign({}, br.defaultOptions, r),
                {
                    chars: i,
                    padding: n,
                    resolution: a,
                    textureWidth: l,
                    textureHeight: h
                } = z,
                c = Kd(z, ["chars", "padding", "resolution", "textureWidth", "textureHeight"]),
                d = mS(i),
                f = e instanceof gi ? e : new gi(e),
                g = l,
                y = new ss;
            y.info[0] = {
                face: f.fontFamily,
                size: f.fontSize
            }, y.common[0] = {
                lineHeight: f.fontSize
            };
            let x = 0,
                _ = 0,
                E, w, I, S = 0;
            const T = [];
            for (let X = 0; X < d.length; X++) {
                E || (E = et.ADAPTER.createCanvas(), E.width = l, E.height = h, w = E.getContext("2d"), I = new mt(E, Kr({
                    resolution: a
                }, c)), T.push(new Q(I)), y.page.push({
                    id: T.length - 1,
                    file: ""
                }));
                const O = d[X],
                    M = oe.measureText(O, f, !1, E),
                    $ = M.width,
                    nt = Math.ceil(M.height),
                    Y = Math.ceil((f.fontStyle === "italic" ? 2 : 1) * $);
                if (_ >= h - nt * a) {
                    if (_ === 0) throw new Error(`[BitmapFont] textureHeight ${h}px is too small (fontFamily: '${f.fontFamily}', fontSize: ${f.fontSize}px, char: '${O}')`);
                    --X, E = null, w = null, I = null, _ = 0, x = 0, S = 0;
                    continue
                }
                if (S = Math.max(nt + M.fontProperties.descent, S), Y * a + x >= g) {
                    if (x === 0) throw new Error(`[BitmapFont] textureWidth ${l}px is too small (fontFamily: '${f.fontFamily}', fontSize: ${f.fontSize}px, char: '${O}')`);
                    --X, _ += S * a, _ = Math.ceil(_), x = 0, S = 0;
                    continue
                }
                fS(E, w, M, x, _, a, f);
                const q = Co(M.text);
                y.char.push({
                    id: q,
                    page: T.length - 1,
                    x: x / a,
                    y: _ / a,
                    width: Y,
                    height: nt,
                    xoffset: 0,
                    yoffset: 0,
                    xadvance: $ - (f.dropShadow ? f.dropShadowDistance : 0) - (f.stroke ? f.strokeThickness : 0)
                }), x += (Y + 2 * n) * a, x = Math.ceil(x)
            }
            for (let X = 0, O = d.length; X < O; X++) {
                const M = d[X];
                for (let $ = 0; $ < O; $++) {
                    const nt = d[$],
                        Y = w.measureText(M).width,
                        q = w.measureText(nt).width,
                        B = w.measureText(M + nt).width - (Y + q);
                    B && y.kerning.push({
                        first: Co(M),
                        second: Co(nt),
                        amount: B
                    })
                }
            }
            const P = new br(y, T, !0);
            return br.available[t] !== void 0 && br.uninstall(t), br.available[t] = P, P
        }
    };
    Re = br, Re.ALPHA = [
        ["a", "z"],
        ["A", "Z"], " "
    ], Re.NUMERIC = [
        ["0", "9"]
    ], Re.ALPHANUMERIC = [
        ["a", "z"],
        ["A", "Z"],
        ["0", "9"], " "
    ], Re.ASCII = [
        [" ", "~"]
    ], Re.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: br.ALPHANUMERIC
    }, Re.available = {};
    var gS = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`,
        yS = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
    const xg = [],
        _g = [],
        bg = [],
        Eg = class extends Kt {
            constructor(t, e = {}) {
                super(), this._tint = 16777215;
                const {
                    align: r,
                    tint: i,
                    maxWidth: n,
                    letterSpacing: a,
                    fontName: l,
                    fontSize: h
                } = Object.assign({}, Eg.styleDefaults, e);
                if (!Re.available[l]) throw new Error(`Missing BitmapFont "${l}"`);
                this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = r, this._tint = i, this._font = void 0, this._fontName = l, this._fontSize = h, this.text = t, this._maxWidth = n, this._maxLineHeight = 0, this._letterSpacing = a, this._anchor = new Jr(() => {
                    this.dirty = !0
                }, this, 0, 0), this._roundPixels = et.ROUND_PIXELS, this.dirty = !0, this._resolution = et.RESOLUTION, this._autoResolution = !0, this._textureCache = {}
            }
            updateText() {
                var t;
                const e = Re.available[this._fontName],
                    r = this.fontSize,
                    i = r / e.size,
                    n = new gt,
                    a = [],
                    l = [],
                    h = [],
                    c = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ",
                    d = vg(c),
                    f = this._maxWidth * e.size / r,
                    g = e.distanceFieldType === "none" ? xg : _g;
                let y = null,
                    x = 0,
                    _ = 0,
                    E = 0,
                    w = -1,
                    I = 0,
                    S = 0,
                    T = 0,
                    P = 0;
                for (let Y = 0; Y < d.length; Y++) {
                    const q = d[Y],
                        B = Co(q);
                    if (/(?:\s)/.test(q) && (w = Y, I = x, P++), q === "\r" || q === `
`) {
                        l.push(x), h.push(-1), _ = Math.max(_, x), ++E, ++S, n.x = 0, n.y += e.lineHeight, y = null, P = 0;
                        continue
                    }
                    const G = e.chars[B];
                    if (!G) continue;
                    y && G.kerning[y] && (n.x += G.kerning[y]);
                    const pt = bg.pop() || {
                        texture: Q.EMPTY,
                        line: 0,
                        charCode: 0,
                        prevSpaces: 0,
                        position: new gt
                    };
                    pt.texture = G.texture, pt.line = E, pt.charCode = B, pt.position.x = Math.round(n.x + G.xOffset + this._letterSpacing / 2), pt.position.y = Math.round(n.y + G.yOffset), pt.prevSpaces = P, a.push(pt), x = pt.position.x + Math.max(G.xAdvance - G.xOffset, G.texture.orig.width), n.x += G.xAdvance + this._letterSpacing, T = Math.max(T, G.yOffset + G.texture.height), y = B, w !== -1 && f > 0 && n.x > f && (++S, Yi(a, 1 + w - S, 1 + Y - w), Y = w, w = -1, l.push(I), h.push(a.length > 0 ? a[a.length - 1].prevSpaces : 0), _ = Math.max(_, I), E++, n.x = 0, n.y += e.lineHeight, y = null, P = 0)
                }
                const z = d[d.length - 1];
                z !== "\r" && z !== `
` && (/(?:\s)/.test(z) && (x = I), l.push(x), _ = Math.max(_, x), h.push(-1));
                const X = [];
                for (let Y = 0; Y <= E; Y++) {
                    let q = 0;
                    this._align === "right" ? q = _ - l[Y] : this._align === "center" ? q = (_ - l[Y]) / 2 : this._align === "justify" && (q = h[Y] < 0 ? 0 : (_ - l[Y]) / h[Y]), X.push(q)
                }
                const O = a.length,
                    M = {},
                    $ = [],
                    nt = this._activePagesMeshData;
                g.push(...nt);
                for (let Y = 0; Y < O; Y++) {
                    const q = a[Y].texture,
                        B = q.baseTexture.uid;
                    if (!M[B]) {
                        let G = g.pop();
                        if (!G) {
                            const ft = new hs;
                            let J, j;
                            e.distanceFieldType === "none" ? (J = new vn(Q.EMPTY), j = ut.NORMAL) : (J = new vn(Q.EMPTY, {
                                program: Ke.from(yS, gS),
                                uniforms: {
                                    uFWidth: 0
                                }
                            }), j = ut.NORMAL_NPM);
                            const rt = new Fi(ft, J);
                            rt.blendMode = j, G = {
                                index: 0,
                                indexCount: 0,
                                vertexCount: 0,
                                uvsCount: 0,
                                total: 0,
                                mesh: rt,
                                vertices: null,
                                uvs: null,
                                indices: null
                            }
                        }
                        G.index = 0, G.indexCount = 0, G.vertexCount = 0, G.uvsCount = 0, G.total = 0;
                        const {
                            _textureCache: pt
                        } = this;
                        pt[B] = pt[B] || new Q(q.baseTexture), G.mesh.texture = pt[B], G.mesh.tint = this._tint, $.push(G), M[B] = G
                    }
                    M[B].total++
                }
                for (let Y = 0; Y < nt.length; Y++) $.includes(nt[Y]) || this.removeChild(nt[Y].mesh);
                for (let Y = 0; Y < $.length; Y++) $[Y].mesh.parent !== this && this.addChild($[Y].mesh);
                this._activePagesMeshData = $;
                for (const Y in M) {
                    const q = M[Y],
                        B = q.total;
                    if (!(((t = q.indices) == null ? void 0 : t.length) > 6 * B) || q.vertices.length < Fi.BATCHABLE_SIZE * 2) q.vertices = new Float32Array(4 * 2 * B), q.uvs = new Float32Array(4 * 2 * B), q.indices = new Uint16Array(6 * B);
                    else {
                        const G = q.total,
                            pt = q.vertices;
                        for (let ft = G * 4 * 2; ft < pt.length; ft++) pt[ft] = 0
                    }
                    q.mesh.size = 6 * B
                }
                for (let Y = 0; Y < O; Y++) {
                    const q = a[Y];
                    let B = q.position.x + X[q.line] * (this._align === "justify" ? q.prevSpaces : 1);
                    this._roundPixels && (B = Math.round(B));
                    const G = B * i,
                        pt = q.position.y * i,
                        ft = q.texture,
                        J = M[ft.baseTexture.uid],
                        j = ft.frame,
                        rt = ft._uvs,
                        D = J.index++;
                    J.indices[D * 6 + 0] = 0 + D * 4, J.indices[D * 6 + 1] = 1 + D * 4, J.indices[D * 6 + 2] = 2 + D * 4, J.indices[D * 6 + 3] = 0 + D * 4, J.indices[D * 6 + 4] = 2 + D * 4, J.indices[D * 6 + 5] = 3 + D * 4, J.vertices[D * 8 + 0] = G, J.vertices[D * 8 + 1] = pt, J.vertices[D * 8 + 2] = G + j.width * i, J.vertices[D * 8 + 3] = pt, J.vertices[D * 8 + 4] = G + j.width * i, J.vertices[D * 8 + 5] = pt + j.height * i, J.vertices[D * 8 + 6] = G, J.vertices[D * 8 + 7] = pt + j.height * i, J.uvs[D * 8 + 0] = rt.x0, J.uvs[D * 8 + 1] = rt.y0, J.uvs[D * 8 + 2] = rt.x1, J.uvs[D * 8 + 3] = rt.y1, J.uvs[D * 8 + 4] = rt.x2, J.uvs[D * 8 + 5] = rt.y2, J.uvs[D * 8 + 6] = rt.x3, J.uvs[D * 8 + 7] = rt.y3
                }
                this._textWidth = _ * i, this._textHeight = (n.y + e.lineHeight) * i;
                for (const Y in M) {
                    const q = M[Y];
                    if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                        let ft = 0;
                        const J = this._textWidth * this.anchor.x,
                            j = this._textHeight * this.anchor.y;
                        for (let rt = 0; rt < q.total; rt++) q.vertices[ft++] -= J, q.vertices[ft++] -= j, q.vertices[ft++] -= J, q.vertices[ft++] -= j, q.vertices[ft++] -= J, q.vertices[ft++] -= j, q.vertices[ft++] -= J, q.vertices[ft++] -= j
                    }
                    this._maxLineHeight = T * i;
                    const B = q.mesh.geometry.getBuffer("aVertexPosition"),
                        G = q.mesh.geometry.getBuffer("aTextureCoord"),
                        pt = q.mesh.geometry.getIndex();
                    B.data = q.vertices, G.data = q.uvs, pt.data = q.indices, B.update(), G.update(), pt.update()
                }
                for (let Y = 0; Y < a.length; Y++) bg.push(a[Y]);
                this._font = e, this.dirty = !1
            }
            updateTransform() {
                this.validate(), this.containerUpdateTransform()
            }
            _render(t) {
                this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0);
                const {
                    distanceFieldRange: e,
                    distanceFieldType: r,
                    size: i
                } = Re.available[this._fontName];
                if (r !== "none") {
                    const {
                        a: n,
                        b: a,
                        c: l,
                        d: h
                    } = this.worldTransform, c = Math.sqrt(n * n + a * a), d = Math.sqrt(l * l + h * h), f = (Math.abs(c) + Math.abs(d)) / 2, g = this.fontSize / i, y = t._view.resolution;
                    for (const x of this._activePagesMeshData) x.mesh.shader.uniforms.uFWidth = f * e * g * y
                }
                super._render(t)
            }
            getLocalBounds() {
                return this.validate(), super.getLocalBounds()
            }
            validate() {
                const t = Re.available[this._fontName];
                if (!t) throw new Error(`Missing BitmapFont "${this._fontName}"`);
                this._font !== t && (this.dirty = !0), this.dirty && this.updateText()
            }
            get tint() {
                return this._tint
            }
            set tint(t) {
                if (this._tint !== t) {
                    this._tint = t;
                    for (let e = 0; e < this._activePagesMeshData.length; e++) this._activePagesMeshData[e].mesh.tint = t
                }
            }
            get align() {
                return this._align
            }
            set align(t) {
                this._align !== t && (this._align = t, this.dirty = !0)
            }
            get fontName() {
                return this._fontName
            }
            set fontName(t) {
                if (!Re.available[t]) throw new Error(`Missing BitmapFont "${t}"`);
                this._fontName !== t && (this._fontName = t, this.dirty = !0)
            }
            get fontSize() {
                var t;
                return (t = this._fontSize) != null ? t : Re.available[this._fontName].size
            }
            set fontSize(t) {
                this._fontSize !== t && (this._fontSize = t, this.dirty = !0)
            }
            get anchor() {
                return this._anchor
            }
            set anchor(t) {
                typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t)
            }
            get text() {
                return this._text
            }
            set text(t) {
                t = String(t != null ? t : ""), this._text !== t && (this._text = t, this.dirty = !0)
            }
            get maxWidth() {
                return this._maxWidth
            }
            set maxWidth(t) {
                this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
            }
            get maxLineHeight() {
                return this.validate(), this._maxLineHeight
            }
            get textWidth() {
                return this.validate(), this._textWidth
            }
            get letterSpacing() {
                return this._letterSpacing
            }
            set letterSpacing(t) {
                this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
            }
            get roundPixels() {
                return this._roundPixels
            }
            set roundPixels(t) {
                t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0)
            }
            get textHeight() {
                return this.validate(), this._textHeight
            }
            get resolution() {
                return this._resolution
            }
            set resolution(t) {
                this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
            }
            destroy(t) {
                const {
                    _textureCache: e
                } = this, r = Re.available[this._fontName].distanceFieldType === "none" ? xg : _g;
                r.push(...this._activePagesMeshData);
                for (const i of this._activePagesMeshData) this.removeChild(i.mesh);
                this._activePagesMeshData = [], r.filter(i => e[i.mesh.texture.baseTexture.uid]).forEach(i => {
                    i.mesh.texture = Q.EMPTY
                });
                for (const i in e) e[i].destroy(), delete e[i];
                this._font = null, this._textureCache = null, super.destroy(t)
            }
        };
    Th = Eg, Th.styleDefaults = {
        align: "left",
        tint: 16777215,
        maxWidth: 0,
        letterSpacing: 0
    };
    let Tg;
    Tg = [".xml", ".fnt"], Rp = {
        extension: {
            type: Z.LoadParser,
            priority: pr.Normal
        },
        test(t) {
            return Tg.includes(ce.extname(t).toLowerCase())
        },
        async testParse(t) {
            return ms.test(t) || Ma.test(t)
        },
        async parse(t, e, r) {
            const i = ms.test(t) ? ms.parse(t) : Ma.parse(t),
                {
                    src: n
                } = e,
                {
                    page: a
                } = i,
                l = [];
            for (let d = 0; d < a.length; ++d) {
                const f = a[d].file;
                let g = ce.join(ce.dirname(n), f);
                g = Da(g, n), l.push(g)
            }
            const h = await r.load(l),
                c = l.map(d => h[d]);
            return Re.install(i, c, !0)
        },
        async load(t, e) {
            return (await et.ADAPTER.fetch(t)).text()
        },
        unload(t) {
            t.destroy()
        }
    }, lt.add(Rp), Tp = class extends ti {
        constructor(t, e) {
            super(), this.beginFill(0), this.drawRect(0, 0, t, e), this.endFill()
        }
    }, sv = class extends Kt {
        constructor(t, e) {
            super(), ie(this, "content"), this.content = new Kt;
            let r = new Tp(t, e);
            this.content.mask = r, this.addChild(this.content, r)
        }
    };
    class kr {
        constructor(e, r, i) {
            this.value = e, this.time = r, this.next = null, this.isStepped = !1, i ? this.ease = typeof i == "function" ? i : Ag(i) : this.ease = null
        }
        static createList(e) {
            if ("list" in e) {
                const i = e.list;
                let n;
                const {
                    value: a,
                    time: l
                } = i[0], h = n = new kr(typeof a == "string" ? Ro(a) : a, l, e.ease);
                if (i.length > 2 || i.length === 2 && i[1].value !== a)
                    for (let c = 1; c < i.length; ++c) {
                        const {
                            value: d,
                            time: f
                        } = i[c];
                        n.next = new kr(typeof d == "string" ? Ro(d) : d, f), n = n.next
                    }
                return h.isStepped = !!e.isStepped, h
            }
            const r = new kr(typeof e.start == "string" ? Ro(e.start) : e.start, 0);
            return e.end !== e.start && (r.next = new kr(typeof e.end == "string" ? Ro(e.end) : e.end, 1)), r
        }
    }
    let Ws = Q.from;
    const Fr = Math.PI / 180;

    function ai(t, e) {
        if (!t) return;
        const r = Math.sin(t),
            i = Math.cos(t),
            n = e.x * i - e.y * r,
            a = e.x * r + e.y * i;
        e.x = n, e.y = a
    }

    function Io(t, e, r) {
        return t << 16 | e << 8 | r
    }

    function wg(t) {
        return Math.sqrt(t.x * t.x + t.y * t.y)
    }

    function vS(t) {
        const e = 1 / wg(t);
        t.x *= e, t.y *= e
    }

    function Sg(t, e) {
        t.x *= e, t.y *= e
    }

    function Ro(t, e) {
        e || (e = {}), t.charAt(0) === "#" ? t = t.substr(1) : t.indexOf("0x") === 0 && (t = t.substr(2));
        let r;
        return t.length === 8 && (r = t.substr(0, 2), t = t.substr(2)), e.r = parseInt(t.substr(0, 2), 16), e.g = parseInt(t.substr(2, 2), 16), e.b = parseInt(t.substr(4, 2), 16), r && (e.a = parseInt(r, 16)), e
    }

    function Ag(t) {
        const e = t.length,
            r = 1 / e;
        return function(i) {
            const n = e * i | 0,
                a = (i - n * r) * e,
                l = t[n] || t[e - 1];
            return l.s + a * (2 * (1 - a) * (l.cp - l.s) + a * (l.e - l.s))
        }
    }

    function xS(t) {
        return t ? (t = t.toUpperCase().replace(/ /g, "_"), ut[t] || ut.NORMAL) : ut.NORMAL
    }
    class Zu extends Dr {
        constructor(e) {
            super(), this.prevChild = this.nextChild = null, this.emitter = e, this.config = {}, this.anchor.x = this.anchor.y = .5, this.maxLife = 0, this.age = 0, this.agePercent = 0, this.oneOverLife = 0, this.next = null, this.prev = null, this.init = this.init, this.kill = this.kill
        }
        init(e) {
            this.maxLife = e, this.age = this.agePercent = 0, this.rotation = 0, this.position.x = this.position.y = 0, this.scale.x = this.scale.y = 1, this.tint = 16777215, this.alpha = 1, this.oneOverLife = 1 / this.maxLife, this.visible = !0
        }
        kill() {
            this.emitter.recycle(this)
        }
        destroy() {
            this.parent && this.parent.removeChild(this), this.emitter = this.next = this.prev = null, super.destroy()
        }
    }
    var Dt;
    (function(t) {
        t[t.Spawn = 0] = "Spawn", t[t.Normal = 2] = "Normal", t[t.Late = 5] = "Late"
    })(Dt || (Dt = {}));
    const Ju = Vt.shared,
        rn = Symbol("Position particle per emitter position");
    class It {
        constructor(e, r) {
            this.initBehaviors = [], this.updateBehaviors = [], this.recycleBehaviors = [], this.minLifetime = 0, this.maxLifetime = 0, this.customEase = null, this._frequency = 1, this.spawnChance = 1, this.maxParticles = 1e3, this.emitterLifetime = -1, this.spawnPos = new gt, this.particlesPerWave = 1, this.rotation = 0, this.ownerPos = new gt, this._prevEmitterPos = new gt, this._prevPosIsValid = !1, this._posChanged = !1, this._parent = null, this.addAtBack = !1, this.particleCount = 0, this._emit = !1, this._spawnTimer = 0, this._emitterLife = -1, this._activeParticlesFirst = null, this._activeParticlesLast = null, this._poolFirst = null, this._origConfig = null, this._autoUpdate = !1, this._destroyWhenComplete = !1, this._completeCallback = null, this.parent = e, r && this.init(r), this.recycle = this.recycle, this.update = this.update, this.rotate = this.rotate, this.updateSpawnPos = this.updateSpawnPos, this.updateOwnerPos = this.updateOwnerPos
        }
        static registerBehavior(e) {
            It.knownBehaviors[e.type] = e
        }
        get frequency() {
            return this._frequency
        }
        set frequency(e) {
            typeof e == "number" && e > 0 ? this._frequency = e : this._frequency = 1
        }
        get parent() {
            return this._parent
        }
        set parent(e) {
            this.cleanup(), this._parent = e
        }
        init(e) {
            if (!e) return;
            this.cleanup(), this._origConfig = e, this.minLifetime = e.lifetime.min, this.maxLifetime = e.lifetime.max, e.ease ? this.customEase = typeof e.ease == "function" ? e.ease : Ag(e.ease) : this.customEase = null, this.particlesPerWave = 1, e.particlesPerWave && e.particlesPerWave > 1 && (this.particlesPerWave = e.particlesPerWave), this.frequency = e.frequency, this.spawnChance = typeof e.spawnChance == "number" && e.spawnChance > 0 ? e.spawnChance : 1, this.emitterLifetime = e.emitterLifetime || -1, this.maxParticles = e.maxParticles > 0 ? e.maxParticles : 1e3, this.addAtBack = !!e.addAtBack, this.rotation = 0, this.ownerPos.set(0), e.pos ? this.spawnPos.copyFrom(e.pos) : this.spawnPos.set(0), this._prevEmitterPos.copyFrom(this.spawnPos), this._prevPosIsValid = !1, this._spawnTimer = 0, this.emit = e.emit === void 0 ? !0 : !!e.emit, this.autoUpdate = !!e.autoUpdate;
            const r = e.behaviors.map(i => {
                const n = It.knownBehaviors[i.type];
                return n ? new n(i.config) : null
            }).filter(i => !!i);
            r.push(rn), r.sort((i, n) => i === rn ? n.order === Dt.Spawn ? 1 : -1 : n === rn ? i.order === Dt.Spawn ? -1 : 1 : i.order - n.order), this.initBehaviors = r.slice(), this.updateBehaviors = r.filter(i => i !== rn && i.updateParticle), this.recycleBehaviors = r.filter(i => i !== rn && i.recycleParticle)
        }
        getBehavior(e) {
            return It.knownBehaviors[e] && this.initBehaviors.find(r => r instanceof It.knownBehaviors[e]) || null
        }
        fillPool(e) {
            for (; e > 0; --e) {
                const r = new Zu(this);
                r.next = this._poolFirst, this._poolFirst = r
            }
        }
        recycle(e, r = !1) {
            for (let i = 0; i < this.recycleBehaviors.length; ++i) this.recycleBehaviors[i].recycleParticle(e, !r);
            e.next && (e.next.prev = e.prev), e.prev && (e.prev.next = e.next), e === this._activeParticlesLast && (this._activeParticlesLast = e.prev), e === this._activeParticlesFirst && (this._activeParticlesFirst = e.next), e.prev = null, e.next = this._poolFirst, this._poolFirst = e, e.parent && e.parent.removeChild(e), --this.particleCount
        }
        rotate(e) {
            if (this.rotation === e) return;
            const r = e - this.rotation;
            this.rotation = e, ai(r, this.spawnPos), this._posChanged = !0
        }
        updateSpawnPos(e, r) {
            this._posChanged = !0, this.spawnPos.x = e, this.spawnPos.y = r
        }
        updateOwnerPos(e, r) {
            this._posChanged = !0, this.ownerPos.x = e, this.ownerPos.y = r
        }
        resetPositionTracking() {
            this._prevPosIsValid = !1
        }
        get emit() {
            return this._emit
        }
        set emit(e) {
            this._emit = !!e, this._emitterLife = this.emitterLifetime
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            this._autoUpdate && !e ? Ju.remove(this.update, this) : !this._autoUpdate && e && Ju.add(this.update, this), this._autoUpdate = !!e
        }
        playOnceAndDestroy(e) {
            this.autoUpdate = !0, this.emit = !0, this._destroyWhenComplete = !0, this._completeCallback = e
        }
        playOnce(e) {
            this.emit = !0, this._completeCallback = e
        }
        update(e) {
            if (this._autoUpdate && (e = Ju.elapsedMS * .001), !this._parent) return;
            for (let l = this._activeParticlesFirst, h; l; l = h)
                if (h = l.next, l.age += e, l.age > l.maxLife || l.age < 0) this.recycle(l);
                else {
                    let c = l.age * l.oneOverLife;
                    this.customEase && (this.customEase.length === 4 ? c = this.customEase(c, 0, 1, 1) : c = this.customEase(c)), l.agePercent = c;
                    for (let d = 0; d < this.updateBehaviors.length; ++d)
                        if (this.updateBehaviors[d].updateParticle(l, e)) {
                            this.recycle(l);
                            break
                        }
                }
            let r, i;
            this._prevPosIsValid && (r = this._prevEmitterPos.x, i = this._prevEmitterPos.y);
            const n = this.ownerPos.x + this.spawnPos.x,
                a = this.ownerPos.y + this.spawnPos.y;
            if (this._emit)
                for (this._spawnTimer -= e < 0 ? 0 : e; this._spawnTimer <= 0;) {
                    if (this._emitterLife >= 0 && (this._emitterLife -= this._frequency, this._emitterLife <= 0)) {
                        this._spawnTimer = 0, this._emitterLife = 0, this.emit = !1;
                        break
                    }
                    if (this.particleCount >= this.maxParticles) {
                        this._spawnTimer += this._frequency;
                        continue
                    }
                    let l, h;
                    if (this._prevPosIsValid && this._posChanged) {
                        const f = 1 + this._spawnTimer / e;
                        l = (n - r) * f + r, h = (a - i) * f + i
                    } else l = n, h = a;
                    let c = null,
                        d = null;
                    for (let f = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), g = 0; g < f; ++g) {
                        if (this.spawnChance < 1 && Math.random() >= this.spawnChance) continue;
                        let y;
                        if (this.minLifetime === this.maxLifetime ? y = this.minLifetime : y = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime, -this._spawnTimer >= y) continue;
                        let x;
                        this._poolFirst ? (x = this._poolFirst, this._poolFirst = this._poolFirst.next, x.next = null) : x = new Zu(this), x.init(y), this.addAtBack ? this._parent.addChildAt(x, 0) : this._parent.addChild(x), c ? (d.next = x, x.prev = d, d = x) : d = c = x, ++this.particleCount
                    }
                    if (c) {
                        this._activeParticlesLast ? (this._activeParticlesLast.next = c, c.prev = this._activeParticlesLast, this._activeParticlesLast = d) : (this._activeParticlesFirst = c, this._activeParticlesLast = d);
                        for (let f = 0; f < this.initBehaviors.length; ++f) {
                            const g = this.initBehaviors[f];
                            if (g === rn)
                                for (let y = c, x; y; y = x) {
                                    x = y.next, this.rotation !== 0 && (ai(this.rotation, y.position), y.rotation += this.rotation), y.position.x += l, y.position.y += h, y.age += -this._spawnTimer;
                                    let _ = y.age * y.oneOverLife;
                                    this.customEase && (this.customEase.length === 4 ? _ = this.customEase(_, 0, 1, 1) : _ = this.customEase(_)), y.agePercent = _
                                } else g.initParticles(c)
                        }
                        for (let f = c, g; f; f = g) {
                            g = f.next;
                            for (let y = 0; y < this.updateBehaviors.length; ++y)
                                if (this.updateBehaviors[y].updateParticle(f, -this._spawnTimer)) {
                                    this.recycle(f);
                                    break
                                }
                        }
                    }
                    this._spawnTimer += this._frequency
                }
            if (this._posChanged && (this._prevEmitterPos.x = n, this._prevEmitterPos.y = a, this._prevPosIsValid = !0, this._posChanged = !1), !this._emit && !this._activeParticlesFirst) {
                if (this._completeCallback) {
                    const l = this._completeCallback;
                    this._completeCallback = null, l()
                }
                this._destroyWhenComplete && this.destroy()
            }
        }
        emitNow() {
            const e = this.ownerPos.x + this.spawnPos.x,
                r = this.ownerPos.y + this.spawnPos.y;
            let i = null,
                n = null;
            for (let a = Math.min(this.particlesPerWave, this.maxParticles - this.particleCount), l = 0; l < a; ++l) {
                if (this.spawnChance < 1 && Math.random() >= this.spawnChance) continue;
                let h;
                this._poolFirst ? (h = this._poolFirst, this._poolFirst = this._poolFirst.next, h.next = null) : h = new Zu(this);
                let c;
                this.minLifetime === this.maxLifetime ? c = this.minLifetime : c = Math.random() * (this.maxLifetime - this.minLifetime) + this.minLifetime, h.init(c), this.addAtBack ? this._parent.addChildAt(h, 0) : this._parent.addChild(h), i ? (n.next = h, h.prev = n, n = h) : n = i = h, ++this.particleCount
            }
            if (i) {
                this._activeParticlesLast ? (this._activeParticlesLast.next = i, i.prev = this._activeParticlesLast, this._activeParticlesLast = n) : (this._activeParticlesFirst = i, this._activeParticlesLast = n);
                for (let a = 0; a < this.initBehaviors.length; ++a) {
                    const l = this.initBehaviors[a];
                    if (l === rn)
                        for (let h = i, c; h; h = c) c = h.next, this.rotation !== 0 && (ai(this.rotation, h.position), h.rotation += this.rotation), h.position.x += e, h.position.y += r;
                    else l.initParticles(i)
                }
            }
        }
        cleanup() {
            let e, r;
            for (e = this._activeParticlesFirst; e; e = r) r = e.next, this.recycle(e, !0);
            this._activeParticlesFirst = this._activeParticlesLast = null, this.particleCount = 0
        }
        get destroyed() {
            return !(this._parent && this.initBehaviors.length)
        }
        destroy() {
            this.autoUpdate = !1, this.cleanup();
            let e;
            for (let r = this._poolFirst; r; r = e) e = r.next, r.destroy();
            this._poolFirst = this._parent = this.spawnPos = this.ownerPos = this.customEase = this._completeCallback = null, this.initBehaviors.length = this.updateBehaviors.length = this.recycleBehaviors.length = 0
        }
    }
    It.knownBehaviors = {};
    class tc {
        constructor(e) {
            this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h
        }
        getRandPos(e) {
            e.x = Math.random() * this.w + this.x, e.y = Math.random() * this.h + this.y
        }
    }
    tc.type = "rect", tc.editorConfig = null;
    class Mo {
        constructor(e) {
            this.x = e.x || 0, this.y = e.y || 0, this.radius = e.radius, this.innerRadius = e.innerRadius || 0, this.rotation = !!e.affectRotation
        }
        getRandPos(e) {
            this.innerRadius !== this.radius ? e.x = Math.random() * (this.radius - this.innerRadius) + this.innerRadius : e.x = this.radius, e.y = 0;
            const r = Math.random() * Math.PI * 2;
            this.rotation && (e.rotation += r), ai(r, e.position), e.position.x += this.x, e.position.y += this.y
        }
    }
    Mo.type = "torus", Mo.editorConfig = null;
    class ec {
        constructor(e) {
            this.segments = [], this.countingLengths = [], this.totalLength = 0, this.init(e)
        }
        init(e) {
            if (!e || !e.length) this.segments.push({
                p1: {
                    x: 0,
                    y: 0
                },
                p2: {
                    x: 0,
                    y: 0
                },
                l: 0
            });
            else if (Array.isArray(e[0]))
                for (let r = 0; r < e.length; ++r) {
                    const i = e[r];
                    let n = i[0];
                    for (let a = 1; a < i.length; ++a) {
                        const l = i[a];
                        this.segments.push({
                            p1: n,
                            p2: l,
                            l: 0
                        }), n = l
                    }
                } else {
                    let r = e[0];
                    for (let i = 1; i < e.length; ++i) {
                        const n = e[i];
                        this.segments.push({
                            p1: r,
                            p2: n,
                            l: 0
                        }), r = n
                    }
                }
            for (let r = 0; r < this.segments.length; ++r) {
                const {
                    p1: i,
                    p2: n
                } = this.segments[r], a = Math.sqrt((n.x - i.x) * (n.x - i.x) + (n.y - i.y) * (n.y - i.y));
                this.segments[r].l = a, this.totalLength += a, this.countingLengths.push(this.totalLength)
            }
        }
        getRandPos(e) {
            const r = Math.random() * this.totalLength;
            let i, n;
            if (this.segments.length === 1) i = this.segments[0], n = r;
            else
                for (let h = 0; h < this.countingLengths.length; ++h)
                    if (r < this.countingLengths[h]) {
                        i = this.segments[h], n = h === 0 ? r : r - this.countingLengths[h - 1];
                        break
                    }
            n /= i.l || 1;
            const {
                p1: a,
                p2: l
            } = i;
            e.x = a.x + n * (l.x - a.x), e.y = a.y + n * (l.y - a.y)
        }
    }
    ec.type = "polygonalChain", ec.editorConfig = null;
    class rc {
        constructor(e) {
            var r;
            this.order = Dt.Late, this.minStart = e.minStart, this.maxStart = e.maxStart, this.accel = e.accel, this.rotate = !!e.rotate, this.maxSpeed = (r = e.maxSpeed) !== null && r !== void 0 ? r : 0
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.random() * (this.maxStart - this.minStart) + this.minStart;
                r.config.velocity ? r.config.velocity.set(i, 0) : r.config.velocity = new gt(i, 0), ai(r.rotation, r.config.velocity), r = r.next
            }
        }
        updateParticle(e, r) {
            const i = e.config.velocity,
                n = i.x,
                a = i.y;
            if (i.x += this.accel.x * r, i.y += this.accel.y * r, this.maxSpeed) {
                const l = wg(i);
                l > this.maxSpeed && Sg(i, this.maxSpeed / l)
            }
            e.x += (n + i.x) / 2 * r, e.y += (a + i.y) / 2 * r, this.rotate && (e.rotation = Math.atan2(i.y, i.x))
        }
    }
    rc.type = "moveAcceleration", rc.editorConfig = null;

    function _S(t) {
        return this.ease && (t = this.ease(t)), (this.first.next.value - this.first.value) * t + this.first.value
    }

    function bS(t) {
        this.ease && (t = this.ease(t));
        const e = this.first.value,
            r = this.first.next.value,
            i = (r.r - e.r) * t + e.r,
            n = (r.g - e.g) * t + e.g,
            a = (r.b - e.b) * t + e.b;
        return Io(i, n, a)
    }

    function ES(t) {
        this.ease && (t = this.ease(t));
        let e = this.first,
            r = e.next;
        for (; t > r.time;) e = r, r = r.next;
        return t = (t - e.time) / (r.time - e.time), (r.value - e.value) * t + e.value
    }

    function TS(t) {
        this.ease && (t = this.ease(t));
        let e = this.first,
            r = e.next;
        for (; t > r.time;) e = r, r = r.next;
        t = (t - e.time) / (r.time - e.time);
        const i = e.value,
            n = r.value,
            a = (n.r - i.r) * t + i.r,
            l = (n.g - i.g) * t + i.g,
            h = (n.b - i.b) * t + i.b;
        return Io(a, l, h)
    }

    function wS(t) {
        this.ease && (t = this.ease(t));
        let e = this.first;
        for (; e.next && t > e.next.time;) e = e.next;
        return e.value
    }

    function SS(t) {
        this.ease && (t = this.ease(t));
        let e = this.first;
        for (; e.next && t > e.next.time;) e = e.next;
        const r = e.value;
        return Io(r.r, r.g, r.b)
    }
    class Xs {
        constructor(e = !1) {
            this.first = null, this.isColor = !!e, this.interpolate = null, this.ease = null
        }
        reset(e) {
            this.first = e, e.next && e.next.time >= 1 ? this.interpolate = this.isColor ? bS : _S : e.isStepped ? this.interpolate = this.isColor ? SS : wS : this.interpolate = this.isColor ? TS : ES, this.ease = this.first.ease
        }
    }
    class ic {
        constructor(e) {
            this.order = Dt.Normal, this.list = new Xs(!1), this.list.reset(kr.createList(e.alpha))
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.alpha = this.list.first.value, r = r.next
        }
        updateParticle(e) {
            e.alpha = this.list.interpolate(e.agePercent)
        }
    }
    ic.type = "alpha", ic.editorConfig = null;
    class nc {
        constructor(e) {
            this.order = Dt.Normal, this.value = e.alpha
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.alpha = this.value, r = r.next
        }
    }
    nc.type = "alphaStatic", nc.editorConfig = null;

    function Pg(t) {
        const e = [];
        for (let r = 0; r < t.length; ++r) {
            let i = t[r];
            if (typeof i == "string") e.push(Ws(i));
            else if (i instanceof Q) e.push(i);
            else {
                let n = i.count || 1;
                for (typeof i.texture == "string" ? i = Ws(i.texture) : i = i.texture; n > 0; --n) e.push(i)
            }
        }
        return e
    }
    class sc {
        constructor(e) {
            this.order = Dt.Normal, this.anims = [];
            for (let r = 0; r < e.anims.length; ++r) {
                const i = e.anims[r],
                    n = Pg(i.textures),
                    a = i.framerate < 0 ? -1 : i.framerate > 0 ? i.framerate : 60,
                    l = {
                        textures: n,
                        duration: a > 0 ? n.length / a : 0,
                        framerate: a,
                        loop: a > 0 ? !!i.loop : !1
                    };
                this.anims.push(l)
            }
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.floor(Math.random() * this.anims.length),
                    n = r.config.anim = this.anims[i];
                r.texture = n.textures[0], r.config.animElapsed = 0, n.framerate === -1 ? (r.config.animDuration = r.maxLife, r.config.animFramerate = n.textures.length / r.maxLife) : (r.config.animDuration = n.duration, r.config.animFramerate = n.framerate), r = r.next
            }
        }
        updateParticle(e, r) {
            const i = e.config,
                n = i.anim;
            i.animElapsed += r, i.animElapsed >= i.animDuration && (i.anim.loop ? i.animElapsed = i.animElapsed % i.animDuration : i.animElapsed = i.animDuration - 1e-6);
            const a = i.animElapsed * i.animFramerate + 1e-7 | 0;
            e.texture = n.textures[a] || n.textures[n.textures.length - 1] || Q.EMPTY
        }
    }
    sc.type = "animatedRandom", sc.editorConfig = null;
    class ac {
        constructor(e) {
            this.order = Dt.Normal;
            const r = e.anim,
                i = Pg(r.textures),
                n = r.framerate < 0 ? -1 : r.framerate > 0 ? r.framerate : 60;
            this.anim = {
                textures: i,
                duration: n > 0 ? i.length / n : 0,
                framerate: n,
                loop: n > 0 ? !!r.loop : !1
            }
        }
        initParticles(e) {
            let r = e;
            const i = this.anim;
            for (; r;) r.texture = i.textures[0], r.config.animElapsed = 0, i.framerate === -1 ? (r.config.animDuration = r.maxLife, r.config.animFramerate = i.textures.length / r.maxLife) : (r.config.animDuration = i.duration, r.config.animFramerate = i.framerate), r = r.next
        }
        updateParticle(e, r) {
            const i = this.anim,
                n = e.config;
            n.animElapsed += r, n.animElapsed >= n.animDuration && (i.loop ? n.animElapsed = n.animElapsed % n.animDuration : n.animElapsed = n.animDuration - 1e-6);
            const a = n.animElapsed * n.animFramerate + 1e-7 | 0;
            e.texture = i.textures[a] || i.textures[i.textures.length - 1] || Q.EMPTY
        }
    }
    ac.type = "animatedSingle", ac.editorConfig = null;
    class oc {
        constructor(e) {
            this.order = Dt.Normal, this.value = e.blendMode
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.blendMode = xS(this.value), r = r.next
        }
    }
    oc.type = "blendMode", oc.editorConfig = null;
    class lc {
        constructor(e) {
            this.order = Dt.Spawn, this.spacing = e.spacing * Fr, this.start = e.start * Fr, this.distance = e.distance
        }
        initParticles(e) {
            let r = 0,
                i = e;
            for (; i;) {
                let n;
                this.spacing ? n = this.start + this.spacing * r : n = Math.random() * Math.PI * 2, i.rotation = n, this.distance && (i.position.x = this.distance, ai(n, i.position)), i = i.next, ++r
            }
        }
    }
    lc.type = "spawnBurst", lc.editorConfig = null;
    class hc {
        constructor(e) {
            this.order = Dt.Normal, this.list = new Xs(!0), this.list.reset(kr.createList(e.color))
        }
        initParticles(e) {
            let r = e;
            const i = this.list.first.value,
                n = Io(i.r, i.g, i.b);
            for (; r;) r.tint = n, r = r.next
        }
        updateParticle(e) {
            e.tint = this.list.interpolate(e.agePercent)
        }
    }
    hc.type = "color", hc.editorConfig = null;
    class uc {
        constructor(e) {
            this.order = Dt.Normal;
            let r = e.color;
            r.charAt(0) === "#" ? r = r.substr(1) : r.indexOf("0x") === 0 && (r = r.substr(2)), this.value = parseInt(r, 16)
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.tint = this.value, r = r.next
        }
    }
    uc.type = "colorStatic", uc.editorConfig = null;
    class cc {
        constructor(e) {
            this.order = Dt.Normal, this.index = 0, this.textures = e.textures.map(r => typeof r == "string" ? Ws(r) : r)
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.texture = this.textures[this.index], ++this.index >= this.textures.length && (this.index = 0), r = r.next
        }
    }
    cc.type = "textureOrdered", cc.editorConfig = null;
    const Gn = new gt,
        Cg = ["E", "LN2", "LN10", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "cbrt", "ceil", "cos", "cosh", "exp", "expm1", "floor", "fround", "hypot", "log", "log1p", "log10", "log2", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh"],
        AS = new RegExp(["[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]"].concat(Cg).join("|"), "g");

    function PS(t) {
        const e = t.match(AS);
        for (let r = e.length - 1; r >= 0; --r) Cg.indexOf(e[r]) >= 0 && (e[r] = `Math.${e[r]}`);
        return t = e.join(""), new Function("x", `return ${t};`)
    }
    class dc {
        constructor(e) {
            var r;
            if (this.order = Dt.Late, e.path)
                if (typeof e.path == "function") this.path = e.path;
                else try {
                    this.path = PS(e.path)
                } catch (i) {
                    this.path = null
                } else this.path = i => i;
            this.list = new Xs(!1), this.list.reset(kr.createList(e.speed)), this.minMult = (r = e.minMult) !== null && r !== void 0 ? r : 1
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                r.config.initRotation = r.rotation, r.config.initPosition ? r.config.initPosition.copyFrom(r.position) : r.config.initPosition = new gt(r.x, r.y), r.config.movement = 0;
                const i = Math.random() * (1 - this.minMult) + this.minMult;
                r.config.speedMult = i, r = r.next
            }
        }
        updateParticle(e, r) {
            const i = this.list.interpolate(e.agePercent) * e.config.speedMult;
            e.config.movement += i * r, Gn.x = e.config.movement, Gn.y = this.path(Gn.x), ai(e.config.initRotation, Gn), e.position.x = e.config.initPosition.x + Gn.x, e.position.y = e.config.initPosition.y + Gn.y
        }
    }
    dc.type = "movePath", dc.editorConfig = null;
    class pc {
        constructor() {
            this.order = Dt.Spawn
        }
        initParticles(e) {}
    }
    pc.type = "spawnPoint", pc.editorConfig = null;
    class fc {
        constructor(e) {
            this.order = Dt.Normal, this.textures = e.textures.map(r => typeof r == "string" ? Ws(r) : r)
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.floor(Math.random() * this.textures.length);
                r.texture = this.textures[i], r = r.next
            }
        }
    }
    fc.type = "textureRandom", fc.editorConfig = null;
    class mc {
        constructor(e) {
            this.order = Dt.Normal, this.minStart = e.minStart * Fr, this.maxStart = e.maxStart * Fr, this.minSpeed = e.minSpeed * Fr, this.maxSpeed = e.maxSpeed * Fr, this.accel = e.accel * Fr
        }
        initParticles(e) {
            let r = e;
            for (; r;) this.minStart === this.maxStart ? r.rotation += this.maxStart : r.rotation += Math.random() * (this.maxStart - this.minStart) + this.minStart, r.config.rotSpeed = Math.random() * (this.maxSpeed - this.minSpeed) + this.minSpeed, r = r.next
        }
        updateParticle(e, r) {
            if (this.accel) {
                const i = e.config.rotSpeed;
                e.config.rotSpeed += this.accel * r, e.rotation += (e.config.rotSpeed + i) / 2 * r
            } else e.rotation += e.config.rotSpeed * r
        }
    }
    mc.type = "rotation", mc.editorConfig = null;
    class gc {
        constructor(e) {
            this.order = Dt.Normal, this.min = e.min * Fr, this.max = e.max * Fr
        }
        initParticles(e) {
            let r = e;
            for (; r;) this.min === this.max ? r.rotation += this.max : r.rotation += Math.random() * (this.max - this.min) + this.min, r = r.next
        }
    }
    gc.type = "rotationStatic", gc.editorConfig = null;
    class yc {
        constructor(e) {
            this.order = Dt.Late + 1, this.rotation = (e.rotation || 0) * Fr
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.rotation = this.rotation, r = r.next
        }
    }
    yc.type = "noRotation", yc.editorConfig = null;
    class vc {
        constructor(e) {
            var r;
            this.order = Dt.Normal, this.list = new Xs(!1), this.list.reset(kr.createList(e.scale)), this.minMult = (r = e.minMult) !== null && r !== void 0 ? r : 1
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.random() * (1 - this.minMult) + this.minMult;
                r.config.scaleMult = i, r.scale.x = r.scale.y = this.list.first.value * i, r = r.next
            }
        }
        updateParticle(e) {
            e.scale.x = e.scale.y = this.list.interpolate(e.agePercent) * e.config.scaleMult
        }
    }
    vc.type = "scale", vc.editorConfig = null;
    class xc {
        constructor(e) {
            this.order = Dt.Normal, this.min = e.min, this.max = e.max
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.random() * (this.max - this.min) + this.min;
                r.scale.x = r.scale.y = i, r = r.next
            }
        }
    }
    xc.type = "scaleStatic", xc.editorConfig = null;
    class Er {
        constructor(e) {
            this.order = Dt.Spawn;
            const r = Er.shapes[e.type];
            if (!r) throw new Error(`No shape found with type '${e.type}'`);
            this.shape = new r(e.data)
        }
        static registerShape(e, r) {
            Er.shapes[r || e.type] = e
        }
        initParticles(e) {
            let r = e;
            for (; r;) this.shape.getRandPos(r), r = r.next
        }
    }
    Er.type = "spawnShape", Er.editorConfig = null, Er.shapes = {}, Er.registerShape(ec), Er.registerShape(tc), Er.registerShape(Mo), Er.registerShape(Mo, "circle");
    class _c {
        constructor(e) {
            this.order = Dt.Normal, this.texture = typeof e.texture == "string" ? Ws(e.texture) : e.texture
        }
        initParticles(e) {
            let r = e;
            for (; r;) r.texture = this.texture, r = r.next
        }
    }
    _c.type = "textureSingle", _c.editorConfig = null;
    class bc {
        constructor(e) {
            var r;
            this.order = Dt.Late, this.list = new Xs(!1), this.list.reset(kr.createList(e.speed)), this.minMult = (r = e.minMult) !== null && r !== void 0 ? r : 1
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.random() * (1 - this.minMult) + this.minMult;
                r.config.speedMult = i, r.config.velocity ? r.config.velocity.set(this.list.first.value * i, 0) : r.config.velocity = new gt(this.list.first.value * i, 0), ai(r.rotation, r.config.velocity), r = r.next
            }
        }
        updateParticle(e, r) {
            const i = this.list.interpolate(e.agePercent) * e.config.speedMult,
                n = e.config.velocity;
            vS(n), Sg(n, i), e.x += n.x * r, e.y += n.y * r
        }
    }
    bc.type = "moveSpeed", bc.editorConfig = null;
    class Ec {
        constructor(e) {
            this.order = Dt.Late, this.min = e.min, this.max = e.max
        }
        initParticles(e) {
            let r = e;
            for (; r;) {
                const i = Math.random() * (this.max - this.min) + this.min;
                r.config.velocity ? r.config.velocity.set(i, 0) : r.config.velocity = new gt(i, 0), ai(r.rotation, r.config.velocity), r = r.next
            }
        }
        updateParticle(e, r) {
            const i = e.config.velocity;
            e.x += i.x * r, e.y += i.y * r
        }
    }
    Ec.type = "moveSpeedStatic", Ec.editorConfig = null;

    function Ig(t, e) {
        var r, i, n, a, l, h, c, d, f, g, y, x, _, E, w, I, S, T, P, z, X;
        if ("behaviors" in t) return t;
        const O = {
            lifetime: t.lifetime,
            ease: t.ease,
            particlesPerWave: t.particlesPerWave,
            frequency: t.frequency,
            spawnChance: t.spawnChance,
            emitterLifetime: t.emitterLifetime,
            maxParticles: t.maxParticles,
            addAtBack: t.addAtBack,
            pos: t.pos,
            emit: t.emit,
            autoUpdate: t.autoUpdate,
            behaviors: []
        };
        if (t.alpha)
            if ("start" in t.alpha)
                if (t.alpha.start === t.alpha.end) t.alpha.start !== 1 && O.behaviors.push({
                    type: "alphaStatic",
                    config: {
                        alpha: t.alpha.start
                    }
                });
                else {
                    const M = {
                        list: [{
                            time: 0,
                            value: t.alpha.start
                        }, {
                            time: 1,
                            value: t.alpha.end
                        }]
                    };
                    O.behaviors.push({
                        type: "alpha",
                        config: {
                            alpha: M
                        }
                    })
                }
        else t.alpha.list.length === 1 ? t.alpha.list[0].value !== 1 && O.behaviors.push({
            type: "alphaStatic",
            config: {
                alpha: t.alpha.list[0].value
            }
        }) : O.behaviors.push({
            type: "alpha",
            config: {
                alpha: t.alpha
            }
        });
        if (t.acceleration && (t.acceleration.x || t.acceleration.y)) {
            let M, $;
            "start" in t.speed ? (M = t.speed.start * ((r = t.speed.minimumSpeedMultiplier) !== null && r !== void 0 ? r : 1), $ = t.speed.start) : (M = t.speed.list[0].value * ((i = t.minimumSpeedMultiplier) !== null && i !== void 0 ? i : 1), $ = t.speed.list[0].value), O.behaviors.push({
                type: "moveAcceleration",
                config: {
                    accel: t.acceleration,
                    minStart: M,
                    maxStart: $,
                    rotate: !t.noRotation,
                    maxSpeed: t.maxSpeed
                }
            })
        } else if (!((n = t.extraData) === null || n === void 0) && n.path) {
            let M, $;
            "start" in t.speed ? ($ = (a = t.speed.minimumSpeedMultiplier) !== null && a !== void 0 ? a : 1, t.speed.start === t.speed.end ? M = {
                list: [{
                    time: 0,
                    value: t.speed.start
                }]
            } : M = {
                list: [{
                    time: 0,
                    value: t.speed.start
                }, {
                    time: 1,
                    value: t.speed.end
                }]
            }) : (M = t.speed, $ = (l = t.minimumSpeedMultiplier) !== null && l !== void 0 ? l : 1), O.behaviors.push({
                type: "movePath",
                config: {
                    path: t.extraData.path,
                    speed: M,
                    minMult: $
                }
            })
        } else if (t.speed)
            if ("start" in t.speed)
                if (t.speed.start === t.speed.end) O.behaviors.push({
                    type: "moveSpeedStatic",
                    config: {
                        min: t.speed.start * ((h = t.speed.minimumSpeedMultiplier) !== null && h !== void 0 ? h : 1),
                        max: t.speed.start
                    }
                });
                else {
                    const M = {
                        list: [{
                            time: 0,
                            value: t.speed.start
                        }, {
                            time: 1,
                            value: t.speed.end
                        }]
                    };
                    O.behaviors.push({
                        type: "moveSpeed",
                        config: {
                            speed: M,
                            minMult: t.speed.minimumSpeedMultiplier
                        }
                    })
                }
        else t.speed.list.length === 1 ? O.behaviors.push({
            type: "moveSpeedStatic",
            config: {
                min: t.speed.list[0].value * ((c = t.minimumSpeedMultiplier) !== null && c !== void 0 ? c : 1),
                max: t.speed.list[0].value
            }
        }) : O.behaviors.push({
            type: "moveSpeed",
            config: {
                speed: t.speed,
                minMult: (d = t.minimumSpeedMultiplier) !== null && d !== void 0 ? d : 1
            }
        });
        if (t.scale)
            if ("start" in t.scale) {
                const M = (f = t.scale.minimumScaleMultiplier) !== null && f !== void 0 ? f : 1;
                if (t.scale.start === t.scale.end) O.behaviors.push({
                    type: "scaleStatic",
                    config: {
                        min: t.scale.start * M,
                        max: t.scale.start
                    }
                });
                else {
                    const $ = {
                        list: [{
                            time: 0,
                            value: t.scale.start
                        }, {
                            time: 1,
                            value: t.scale.end
                        }]
                    };
                    O.behaviors.push({
                        type: "scale",
                        config: {
                            scale: $,
                            minMult: M
                        }
                    })
                }
            } else if (t.scale.list.length === 1) {
            const M = (g = t.minimumScaleMultiplier) !== null && g !== void 0 ? g : 1,
                $ = t.scale.list[0].value;
            O.behaviors.push({
                type: "scaleStatic",
                config: {
                    min: $ * M,
                    max: $
                }
            })
        } else O.behaviors.push({
            type: "scale",
            config: {
                scale: t.scale,
                minMult: (y = t.minimumScaleMultiplier) !== null && y !== void 0 ? y : 1
            }
        });
        if (t.color)
            if ("start" in t.color)
                if (t.color.start === t.color.end) t.color.start !== "ffffff" && O.behaviors.push({
                    type: "colorStatic",
                    config: {
                        color: t.color.start
                    }
                });
                else {
                    const M = {
                        list: [{
                            time: 0,
                            value: t.color.start
                        }, {
                            time: 1,
                            value: t.color.end
                        }]
                    };
                    O.behaviors.push({
                        type: "color",
                        config: {
                            color: M
                        }
                    })
                }
        else t.color.list.length === 1 ? t.color.list[0].value !== "ffffff" && O.behaviors.push({
            type: "colorStatic",
            config: {
                color: t.color.list[0].value
            }
        }) : O.behaviors.push({
            type: "color",
            config: {
                color: t.color
            }
        });
        if (t.rotationAcceleration || !((x = t.rotationSpeed) === null || x === void 0) && x.min || !((_ = t.rotationSpeed) === null || _ === void 0) && _.max ? O.behaviors.push({
                type: "rotation",
                config: {
                    accel: t.rotationAcceleration || 0,
                    minSpeed: ((E = t.rotationSpeed) === null || E === void 0 ? void 0 : E.min) || 0,
                    maxSpeed: ((w = t.rotationSpeed) === null || w === void 0 ? void 0 : w.max) || 0,
                    minStart: ((I = t.startRotation) === null || I === void 0 ? void 0 : I.min) || 0,
                    maxStart: ((S = t.startRotation) === null || S === void 0 ? void 0 : S.max) || 0
                }
            }) : (!((T = t.startRotation) === null || T === void 0) && T.min || !((P = t.startRotation) === null || P === void 0) && P.max) && O.behaviors.push({
                type: "rotationStatic",
                config: {
                    min: ((z = t.startRotation) === null || z === void 0 ? void 0 : z.min) || 0,
                    max: ((X = t.startRotation) === null || X === void 0 ? void 0 : X.max) || 0
                }
            }), t.noRotation && O.behaviors.push({
                type: "noRotation",
                config: {}
            }), t.blendMode && t.blendMode !== "normal" && O.behaviors.push({
                type: "blendMode",
                config: {
                    blendMode: t.blendMode
                }
            }), Array.isArray(e) && typeof e[0] != "string" && "framerate" in e[0]) {
            for (let M = 0; M < e.length; ++M) e[M].framerate === "matchLife" && (e[M].framerate = -1);
            O.behaviors.push({
                type: "animatedRandom",
                config: {
                    anims: e
                }
            })
        } else typeof e != "string" && "framerate" in e ? (e.framerate === "matchLife" && (e.framerate = -1), O.behaviors.push({
            type: "animatedSingle",
            config: {
                anim: e
            }
        })) : t.orderedArt && Array.isArray(e) ? O.behaviors.push({
            type: "textureOrdered",
            config: {
                textures: e
            }
        }) : Array.isArray(e) ? O.behaviors.push({
            type: "textureRandom",
            config: {
                textures: e
            }
        }) : O.behaviors.push({
            type: "textureSingle",
            config: {
                texture: e
            }
        });
        if (t.spawnType === "burst") O.behaviors.push({
            type: "spawnBurst",
            config: {
                start: t.angleStart || 0,
                spacing: t.particleSpacing,
                distance: 0
            }
        });
        else if (t.spawnType === "point") O.behaviors.push({
            type: "spawnPoint",
            config: {}
        });
        else {
            let M;
            t.spawnType === "ring" ? M = {
                type: "torus",
                data: {
                    x: t.spawnCircle.x,
                    y: t.spawnCircle.y,
                    radius: t.spawnCircle.r,
                    innerRadius: t.spawnCircle.minR,
                    affectRotation: !0
                }
            } : t.spawnType === "circle" ? M = {
                type: "torus",
                data: {
                    x: t.spawnCircle.x,
                    y: t.spawnCircle.y,
                    radius: t.spawnCircle.r,
                    innerRadius: 0,
                    affectRotation: !1
                }
            } : t.spawnType === "rect" ? M = {
                type: "rect",
                data: t.spawnRect
            } : t.spawnType === "polygonalChain" && (M = {
                type: "polygonalChain",
                data: t.spawnPolygon
            }), M && O.behaviors.push({
                type: "spawnShape",
                config: M
            })
        }
        return O
    }
    It.registerBehavior(rc), It.registerBehavior(ic), It.registerBehavior(nc), It.registerBehavior(sc), It.registerBehavior(ac), It.registerBehavior(oc), It.registerBehavior(lc), It.registerBehavior(hc), It.registerBehavior(uc), It.registerBehavior(cc), It.registerBehavior(dc), It.registerBehavior(pc), It.registerBehavior(fc), It.registerBehavior(mc), It.registerBehavior(gc), It.registerBehavior(yc), It.registerBehavior(vc), It.registerBehavior(xc), It.registerBehavior(Er), It.registerBehavior(_c), It.registerBehavior(bc), It.registerBehavior(Ec);
    var Rg = {
            exports: {}
        },
        Mg = {
            exports: {}
        },
        CS = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
        IS = CS,
        RS = IS;

    function Dg() {}

    function Ng() {}
    Ng.resetWarningCache = Dg;
    var MS = function() {
        function t(i, n, a, l, h, c) {
            if (c !== RS) {
                var d = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw d.name = "Invariant Violation", d
            }
        }
        t.isRequired = t;

        function e() {
            return t
        }
        var r = {
            array: t,
            bigint: t,
            bool: t,
            func: t,
            number: t,
            object: t,
            string: t,
            symbol: t,
            any: t,
            arrayOf: e,
            element: t,
            elementType: t,
            instanceOf: e,
            node: t,
            objectOf: e,
            oneOf: e,
            oneOfType: e,
            shape: e,
            exact: e,
            checkPropTypes: Ng,
            resetWarningCache: Dg
        };
        return r.PropTypes = r, r
    };
    Mg.exports = MS();
    var DS = Mg.exports;
    const Bt = ka(DS);

    function je(t) {
        return je = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
            return typeof e
        } : function(e) {
            return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, je(t)
    }

    function Og(t) {
        var e = function(r, i) {
            if (je(r) !== "object" || r === null) return r;
            var n = r[Symbol.toPrimitive];
            if (n !== void 0) {
                var a = n.call(r, i || "default");
                if (je(a) !== "object") return a;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return (i === "string" ? String : Number)(r)
        }(t, "string");
        return je(e) === "symbol" ? e : String(e)
    }

    function Jt(t, e, r) {
        return (e = Og(e)) in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = r, t
    }

    function Tc(t, e) {
        (e == null || e > t.length) && (e = t.length);
        for (var r = 0, i = new Array(e); r < e; r++) i[r] = t[r];
        return i
    }

    function oi(t) {
        return function(e) {
            if (Array.isArray(e)) return Tc(e)
        }(t) || function(e) {
            if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e)
        }(t) || function(e, r) {
            if (e) {
                if (typeof e == "string") return Tc(e, r);
                var i = Object.prototype.toString.call(e).slice(8, -1);
                return i === "Object" && e.constructor && (i = e.constructor.name), i === "Map" || i === "Set" ? Array.from(e) : i === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Tc(e, r) : void 0
            }
        }(t) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
        }()
    }

    function Yt(t, e) {
        for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), n = 2; n < r; n++) i[n - 2] = arguments[n]
    }
    var NS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

    function OS(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }
    var LS = function(t) {
        return t == null
    };

    function $s(t) {
        var e = [];
        if (t === void 0) return e;
        if (typeof t == "string") e = t.split(",");
        else if (typeof t == "number") e = [t];
        else if (Array.isArray(t)) e = oi(t);
        else {
            if (t === null || je(t) !== "object") return e;
            e = [t && (t == null ? void 0 : t.x) || 0, t && (t == null ? void 0 : t.y) || 0]
        }
        return e.filter(function(r) {
            return !LS(r) && !isNaN(r)
        }).map(Number)
    }

    function Lg(t, e) {
        if (t.length !== e.length) return !1;
        for (var r = 0; r < t.length; r++)
            if (t[r] !== e[r]) return !1;
        return !0
    }

    function wc(t) {
        return t instanceof gt || t instanceof Jr
    }
    var Do = ["click", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "mouseupoutside", "tap", "touchstart", "touchmove", "touchend", "touchendoutside", "pointercancel", "pointerout", "pointerover", "pointertap", "pointerdown", "pointerup", "pointerupoutside", "pointermove", "rightclick", "rightdown", "rightup", "rightupoutside", "touchcancel", "touchendoutside", "touchmove", "touchstart"];

    function Sc(t, e, r) {
        if (wc(t[e]) && wc(r)) t[e].copyFrom(r);
        else if (wc(t[e])) {
            var i = $s(r);
            Yt(i !== void 0 && i.length > 0 && i.length < 3, "The property `%s` is a `PIXI.Point` or `PIXI.ObservablePoint` and must be set to a comma-separated string of either 1 or 2 coordinates, a 1 or 2 element array containing coordinates, or a PIXI Point/ObservablePoint. If only one coordinate is given then X and Y will be set to the provided value. Received: `%s` of type `%s`.", e, JSON.stringify(r), je(r)), t[e].set(i.shift(), i.shift())
        } else t[e] = r
    }
    var zn, Bg = function(t) {
            var e, r = t;
            if (!Array.isArray(r)) {
                if (e = t, Object.prototype.toString.call(e) !== "[object Object]") throw new Error("collection needs to be an Array or Object");
                r = Object.keys(t)
            }
            var i = {};
            return r.forEach(function(n) {
                    i[n] = !0
                }),
                function(n) {
                    return i[n] !== void 0
                }
        },
        kg = function(t) {
            return function() {
                return !t.apply(void 0, arguments)
            }
        },
        Ac = "children",
        BS = (Jt(zn = {}, Ac, !0), Jt(zn, "parent", !0), Jt(zn, "worldAlpha", !0), Jt(zn, "worldTransform", !0), Jt(zn, "worldVisible", !0), zn),
        Pc = {
            alpha: 1,
            buttonMode: !1,
            cacheAsBitmap: !1,
            cursor: null,
            filterArea: null,
            filters: null,
            hitArea: null,
            interactive: !1,
            mask: null,
            pivot: 0,
            position: 0,
            renderable: !0,
            rotation: 0,
            scale: 1,
            skew: 0,
            transform: null,
            visible: !0,
            x: 0,
            y: 0
        },
        Ur = function(t, e) {
            var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
                i = function(h) {
                    return requestAnimationFrame(function() {
                        var c, d;
                        h == null || (c = h.__reactpixi) === null || c === void 0 || (d = c.root) === null || d === void 0 || d.emit("__REACT_PIXI_REQUEST_RENDER__")
                    })
                },
                n = function(h, c) {
                    if (r.hasOwnProperty(h)) return Yt(c.typeofs.some(function(d) {
                        return je(r[h]) === d
                    }) || c.instanceofs.some(function(d) {
                        return r[h] instanceof d
                    }), "".concat(t, " ").concat(h, " prop is invalid")), r[h]
                };
            if (r.texture) return Yt(r.texture instanceof Q, "".concat(t, " texture needs to be typeof `Texture`")), r.texture;
            var a = n("image", {
                typeofs: ["string"],
                instanceofs: [HTMLImageElement]
            }) || n("video", {
                typeofs: ["string"],
                instanceofs: [HTMLVideoElement]
            }) || n("source", {
                typeofs: ["string", "number"],
                instanceofs: [HTMLImageElement, HTMLVideoElement, HTMLCanvasElement, Q]
            });
            Yt(!!a, "".concat(t, " could not get texture from props"));
            var l = Q.from(a);
            return l.__reactpixi = {
                root: e
            }, l.once("update", i), l.once("loaded", i), l.valid && i(l), l
        },
        kS = kg(Bg([].concat(oi(Object.keys(BS)), oi(Do))));

    function Gr(t, e, r) {
        var i = !1;
        if (Yt(Ft.prototype.isPrototypeOf(t), "instance needs to be typeof `DisplayObject`, got `%s`", je(t)), !r.ignoreEvents)
            for (var n = typeof t.removeListener == "function", a = typeof t.on == "function", l = 0; l < Do.length; l++) {
                var h = Do[l];
                e[h] !== r[h] && (i = !0, typeof e[h] == "function" && n && t.removeListener(h, e[h]), typeof r[h] == "function" && a && t.on(h, r[h]))
            }
        var c = Object.keys(r || {});
        if (r.overwriteProps) {
            for (var d = 0; d < c.length; d++) {
                var f = c[d];
                e[f] !== r[f] && (i = !0, Sc(t, f, r[f]))
            }
            return i
        }
        for (var g = c.filter(kS), y = 0; y < g.length; y++) {
            var x = g[y],
                _ = r[x];
            r[x] !== e[x] && (i = !0), _ !== void 0 ? Sc(t, x, _) : x in Pc && (i = !0, Sc(t, x, Pc[x]))
        }
        return i
    }
    var FS = function(t, e) {
            var r = e.text,
                i = e.style;
            return new Th(r, i)
        },
        US = function() {
            return new Kt
        };

    function Si(t, e) {
        if (t == null) return {};
        var r, i, n = function(l, h) {
            if (l == null) return {};
            var c, d, f = {},
                g = Object.keys(l);
            for (d = 0; d < g.length; d++) c = g[d], h.indexOf(c) >= 0 || (f[c] = l[c]);
            return f
        }(t, e);
        if (Object.getOwnPropertySymbols) {
            var a = Object.getOwnPropertySymbols(t);
            for (i = 0; i < a.length; i++) r = a[i], e.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
        }
        return n
    }
    var GS = ["draw", "geometry"],
        zS = function(t, e) {
            var r = e.geometry;
            Yt(!r || r instanceof ti, "Graphics geometry needs to be a `PIXI.Graphics`");
            var i = r ? new ti(r.geometry) : new ti;
            return i.applyProps = function(n, a, l) {
                var h = l.draw;
                l.geometry;
                var c = Gr(n, a, Si(l, GS));
                return a.draw !== h && typeof h == "function" && (c = !0, h.call(i, i)), c
            }, i
        },
        HS = ["image", "texture"],
        jS = function(t, e) {
            var r = e.leftWidth,
                i = r === void 0 ? 10 : r,
                n = e.topHeight,
                a = n === void 0 ? 10 : n,
                l = e.rightWidth,
                h = l === void 0 ? 10 : l,
                c = e.bottomHeight,
                d = c === void 0 ? 10 : c,
                f = Ur("NineSlicePlane", t, e),
                g = new up(f, i, a, h, d);
            return g.applyProps = function(y, x, _) {
                var E = _.image,
                    w = _.texture,
                    I = Gr(y, x, Si(_, HS));
                return (E || w) && (w !== x.texture && (I = !0), y.texture = Ur("NineSlicePlane", t, _)), I
            }, g
        };

    function Fg(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(t, n).enumerable
            })), r.push.apply(r, i)
        }
        return r
    }

    function No(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e] != null ? arguments[e] : {};
            e % 2 ? Fg(Object(r), !0).forEach(function(i) {
                Jt(t, i, r[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Fg(Object(r)).forEach(function(i) {
                Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i))
            })
        }
        return t
    }
    var WS = function(t, e) {
            var r = e.maxSize,
                i = r === void 0 ? 1500 : r,
                n = e.batchSize,
                a = n === void 0 ? 16384 : n,
                l = e.autoResize,
                h = l !== void 0 && l,
                c = No(No({}, {
                    vertices: !1,
                    scale: !0,
                    position: !0,
                    rotation: !0,
                    uvs: !0,
                    tint: !0
                }), e.properties || {}),
                d = No(No({}, {
                    children: !1,
                    texture: !1,
                    baseTexture: !1
                }), e.destroyOptions || {}),
                f = new dp(i, c, a, h);
            return f.willUnmount = function(g, y, x) {
                g.destroy(d)
            }, f
        },
        XS = ["image", "texture"],
        $S = function(t, e) {
            var r = new Dr(Ur("Sprite", t, e));
            return r.applyProps = function(i, n, a) {
                var l = a.image,
                    h = a.texture,
                    c = Gr(i, n, Si(a, XS));
                return (h && n.texture !== a.texture || l && n.image !== a.image) && (n.texture !== a.texture && (c = !0), i.texture = Ur("Sprite", t, a)), c
            }, r
        },
        VS = ["textures", "isPlaying", "initialFrame", "images"],
        YS = function(t, e) {
            var r = e.textures,
                i = e.images,
                n = e.isPlaying,
                a = n === void 0 || n,
                l = e.initialFrame,
                h = function(d) {
                    return d.map(function(f) {
                        return Yt(f instanceof Q || (f == null ? void 0 : f.texture), "AnimationSprite texture needs to be an array of `PIXI.Texture` or `{ texture: PIXI.Texture, time:\n                number }`"), f
                    })
                },
                c = i ? Es.fromImages(i) : new Es(h(r));
            return c[a ? "gotoAndPlay" : "gotoAndStop"](l || 0), c.applyProps = function(d, f, g) {
                var y = g.textures,
                    x = g.isPlaying,
                    _ = g.initialFrame,
                    E = g.images,
                    w = Gr(d, f, Si(g, VS));
                if (E && f.images !== E) {
                    for (var I = [], S = 0; S < E.length; ++S) I.push(Q.from(E[S]));
                    d.textures = I, w = !0
                }
                if (y && f.textures !== y && (d.textures = h(y), w = !0), x !== f.isPlaying || _ !== f.initialFrame) {
                    var T = typeof _ == "number" ? _ : c.currentFrame || 0;
                    c[x ? "gotoAndPlay" : "gotoAndStop"](T), w = !0
                }
                return w
            }, c
        },
        qS = function(t, e) {
            var r = e.text,
                i = r === void 0 ? "" : r,
                n = e.style,
                a = n === void 0 ? {} : n,
                l = e.isSprite,
                h = new fs(i, a);
            return l ? (h.updateText(), new Dr(h.texture)) : h
        },
        QS = ["tileScale", "tilePosition", "image", "texture"],
        KS = function(t, e) {
            var r = e.width,
                i = r === void 0 ? 100 : r,
                n = e.height,
                a = n === void 0 ? 100 : n,
                l = Ur("TilingSprite", t, e),
                h = new lh(l, i, a);
            return h.applyProps = function(c, d, f) {
                var g = f.tileScale,
                    y = f.tilePosition,
                    x = f.image,
                    _ = f.texture,
                    E = Gr(c, d, Si(f, QS));
                if (y) {
                    var w, I = $s(y);
                    (w = c.tilePosition).set.apply(w, oi(I)), E = !Lg($s(d.tilePosition), I) || E
                }
                if (g) {
                    var S, T = $s(g);
                    (S = c.tileScale).set.apply(S, oi(T)), E = !Lg($s(d.tileScale), T) || E
                }
                return (x || _) && (_ !== d.texture && (E = !0), c.texture = Ur("Sprite", t, f)), E
            }, h
        },
        ZS = ["image", "texture"],
        JS = function(t, e) {
            var r = Ur("Mesh", t, e),
                i = e.vertices,
                n = e.uvs,
                a = e.indices,
                l = e.drawMode,
                h = l === void 0 ? Ye.TRIANGLES : l,
                c = new Sp(r, i, n, a, h);
            return c.applyProps = function(d, f, g) {
                var y = g.image,
                    x = g.texture,
                    _ = Gr(d, f, Si(g, ZS));
                return (y || x) && (x !== f.texture && (_ = !0), d.texture = Ur("Mesh", t, g)), _
            }, c
        },
        tA = ["image", "texture"],
        eA = function(t, e) {
            var r = Ur("SimpleRope", t, e),
                i = e.points,
                n = new Pp(r, i);
            return n.applyProps = function(a, l, h) {
                var c = h.image,
                    d = h.texture,
                    f = Si(h, tA);
                Yt(Array.isArray(h.points), "SimpleRope points needs to be %s", "Array<PIXI.Point>");
                var g = Gr(a, l, f);
                return (c || d) && (d !== l.texture && (g = !0), a.texture = Ur("SimpleRope", t, h)), g
            }, n
        },
        rA = Object.freeze({
            __proto__: null,
            BitmapText: FS,
            Container: US,
            Graphics: zS,
            NineSlicePlane: jS,
            ParticleContainer: WS,
            Sprite: $S,
            Text: qS,
            TilingSprite: KS,
            SimpleMesh: JS,
            SimpleRope: eA,
            AnimatedSprite: YS
        });

    function Ug(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(t, n).enumerable
            })), r.push.apply(r, i)
        }
        return r
    }

    function Gg(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e] != null ? arguments[e] : {};
            e % 2 ? Ug(Object(r), !0).forEach(function(i) {
                Jt(t, i, r[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Ug(Object(r)).forEach(function(i) {
                Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i))
            })
        }
        return t
    }
    var Le = {
            BitmapText: "BitmapText",
            Container: "Container",
            Graphics: "Graphics",
            NineSlicePlane: "NineSlicePlane",
            ParticleContainer: "ParticleContainer",
            Sprite: "Sprite",
            AnimatedSprite: "AnimatedSprite",
            Text: "Text",
            TilingSprite: "TilingSprite",
            SimpleMesh: "SimpleMesh",
            SimpleRope: "SimpleRope"
        },
        iA = Object.keys(Le).reduce(function(t, e) {
            return Gg(Gg({}, t), {}, Jt({}, e, rA[e]))
        }, {}),
        zg = {};

    function nA(t, e) {
        return Yt(!!t, "Expect type to be defined, got `%s`", t), Yt(!Le[t], "Component `%s` could not be created, already exists in default components.", t), zg[t] = e, t
    }
    var Hg, jg, Wg, Xg, Cc = {},
        Ic = {},
        sA = {
            get exports() {
                return Ic
            },
            set exports(t) {
                Ic = t
            }
        },
        $g = {};

    function aA() {
        return jg || (jg = 1, sA.exports = (Hg || (Hg = 1, function(t) {
            function e(j, rt) {
                var D = j.length;
                j.push(rt);
                t: for (; 0 < D;) {
                    var tt = D - 1 >>> 1,
                        ht = j[tt];
                    if (!(0 < n(ht, rt))) break t;
                    j[tt] = rt, j[D] = ht, D = tt
                }
            }

            function r(j) {
                return j.length === 0 ? null : j[0]
            }

            function i(j) {
                if (j.length === 0) return null;
                var rt = j[0],
                    D = j.pop();
                if (D !== rt) {
                    j[0] = D;
                    t: for (var tt = 0, ht = j.length, _t = ht >>> 1; tt < _t;) {
                        var vt = 2 * (tt + 1) - 1,
                            Nt = j[vt],
                            Ct = vt + 1,
                            Ot = j[Ct];
                        if (0 > n(Nt, D)) Ct < ht && 0 > n(Ot, Nt) ? (j[tt] = Ot, j[Ct] = D, tt = Ct) : (j[tt] = Nt, j[vt] = D, tt = vt);
                        else {
                            if (!(Ct < ht && 0 > n(Ot, D))) break t;
                            j[tt] = Ot, j[Ct] = D, tt = Ct
                        }
                    }
                }
                return rt
            }

            function n(j, rt) {
                var D = j.sortIndex - rt.sortIndex;
                return D !== 0 ? D : j.id - rt.id
            }
            if (typeof performance == "object" && typeof performance.now == "function") {
                var a = performance;
                t.unstable_now = function() {
                    return a.now()
                }
            } else {
                var l = Date,
                    h = l.now();
                t.unstable_now = function() {
                    return l.now() - h
                }
            }
            var c = [],
                d = [],
                f = 1,
                g = null,
                y = 3,
                x = !1,
                _ = !1,
                E = !1,
                w = typeof setTimeout == "function" ? setTimeout : null,
                I = typeof clearTimeout == "function" ? clearTimeout : null,
                S = typeof setImmediate < "u" ? setImmediate : null;

            function T(j) {
                for (var rt = r(d); rt !== null;) {
                    if (rt.callback === null) i(d);
                    else {
                        if (!(rt.startTime <= j)) break;
                        i(d), rt.sortIndex = rt.expirationTime, e(c, rt)
                    }
                    rt = r(d)
                }
            }

            function P(j) {
                if (E = !1, T(j), !_)
                    if (r(c) !== null) _ = !0, ft(z);
                    else {
                        var rt = r(d);
                        rt !== null && J(P, rt.startTime - j)
                    }
            }

            function z(j, rt) {
                _ = !1, E && (E = !1, I($), $ = -1), x = !0;
                var D = y;
                try {
                    for (T(rt), g = r(c); g !== null && (!(g.expirationTime > rt) || j && !q());) {
                        var tt = g.callback;
                        if (typeof tt == "function") {
                            g.callback = null, y = g.priorityLevel;
                            var ht = tt(g.expirationTime <= rt);
                            rt = t.unstable_now(), typeof ht == "function" ? g.callback = ht : g === r(c) && i(c), T(rt)
                        } else i(c);
                        g = r(c)
                    }
                    if (g !== null) var _t = !0;
                    else {
                        var vt = r(d);
                        vt !== null && J(P, vt.startTime - rt), _t = !1
                    }
                    return _t
                } finally {
                    g = null, y = D, x = !1
                }
            }
            typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            var X, O = !1,
                M = null,
                $ = -1,
                nt = 5,
                Y = -1;

            function q() {
                return !(t.unstable_now() - Y < nt)
            }

            function B() {
                if (M !== null) {
                    var j = t.unstable_now();
                    Y = j;
                    var rt = !0;
                    try {
                        rt = M(!0, j)
                    } finally {
                        rt ? X() : (O = !1, M = null)
                    }
                } else O = !1
            }
            if (typeof S == "function") X = function() {
                S(B)
            };
            else if (typeof MessageChannel < "u") {
                var G = new MessageChannel,
                    pt = G.port2;
                G.port1.onmessage = B, X = function() {
                    pt.postMessage(null)
                }
            } else X = function() {
                w(B, 0)
            };

            function ft(j) {
                M = j, O || (O = !0, X())
            }

            function J(j, rt) {
                $ = w(function() {
                    j(t.unstable_now())
                }, rt)
            }
            t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(j) {
                j.callback = null
            }, t.unstable_continueExecution = function() {
                _ || x || (_ = !0, ft(z))
            }, t.unstable_forceFrameRate = function(j) {
                0 > j || 125 < j || (nt = 0 < j ? Math.floor(1e3 / j) : 5)
            }, t.unstable_getCurrentPriorityLevel = function() {
                return y
            }, t.unstable_getFirstCallbackNode = function() {
                return r(c)
            }, t.unstable_next = function(j) {
                switch (y) {
                    case 1:
                    case 2:
                    case 3:
                        var rt = 3;
                        break;
                    default:
                        rt = y
                }
                var D = y;
                y = rt;
                try {
                    return j()
                } finally {
                    y = D
                }
            }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(j, rt) {
                switch (j) {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        j = 3
                }
                var D = y;
                y = j;
                try {
                    return rt()
                } finally {
                    y = D
                }
            }, t.unstable_scheduleCallback = function(j, rt, D) {
                var tt = t.unstable_now();
                switch (D = typeof D == "object" && D !== null && typeof(D = D.delay) == "number" && 0 < D ? tt + D : tt, j) {
                    case 1:
                        var ht = -1;
                        break;
                    case 2:
                        ht = 250;
                        break;
                    case 5:
                        ht = 1073741823;
                        break;
                    case 4:
                        ht = 1e4;
                        break;
                    default:
                        ht = 5e3
                }
                return j = {
                    id: f++,
                    callback: rt,
                    priorityLevel: j,
                    startTime: D,
                    expirationTime: ht = D + ht,
                    sortIndex: -1
                }, D > tt ? (j.sortIndex = D, e(d, j), r(c) === null && j === r(d) && (E ? (I($), $ = -1) : E = !0, J(P, D - tt))) : (j.sortIndex = ht, e(c, j), _ || x || (_ = !0, ft(z))), j
            }, t.unstable_shouldYield = q, t.unstable_wrapCallback = function(j) {
                var rt = y;
                return function() {
                    var D = y;
                    y = rt;
                    try {
                        return j.apply(this, arguments)
                    } finally {
                        y = D
                    }
                }
            }
        }($g)), $g)), Ic
    }

    function oA() {
        return Xg || (Xg = 1, Wg = function(t) {
            var e = {},
                r = Ir,
                i = aA(),
                n = Object.assign;

            function a(s) {
                for (var o = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, u = 1; u < arguments.length; u++) o += "&args[]=" + encodeURIComponent(arguments[u]);
                return "Minified React error #" + s + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
            }
            var l = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                h = Symbol.for("react.element"),
                c = Symbol.for("react.portal"),
                d = Symbol.for("react.fragment"),
                f = Symbol.for("react.strict_mode"),
                g = Symbol.for("react.profiler"),
                y = Symbol.for("react.provider"),
                x = Symbol.for("react.context"),
                _ = Symbol.for("react.forward_ref"),
                E = Symbol.for("react.suspense"),
                w = Symbol.for("react.suspense_list"),
                I = Symbol.for("react.memo"),
                S = Symbol.for("react.lazy"),
                T = Symbol.for("react.offscreen"),
                P = Symbol.iterator;

            function z(s) {
                return s === null || typeof s != "object" ? null : typeof(s = P && s[P] || s["@@iterator"]) == "function" ? s : null
            }

            function X(s) {
                if (s == null) return null;
                if (typeof s == "function") return s.displayName || s.name || null;
                if (typeof s == "string") return s;
                switch (s) {
                    case d:
                        return "Fragment";
                    case c:
                        return "Portal";
                    case g:
                        return "Profiler";
                    case f:
                        return "StrictMode";
                    case E:
                        return "Suspense";
                    case w:
                        return "SuspenseList"
                }
                if (typeof s == "object") switch (s.$$typeof) {
                    case x:
                        return (s.displayName || "Context") + ".Consumer";
                    case y:
                        return (s._context.displayName || "Context") + ".Provider";
                    case _:
                        var o = s.render;
                        return (s = s.displayName) || (s = (s = o.displayName || o.name || "") !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
                    case I:
                        return (o = s.displayName || null) !== null ? o : X(s.type) || "Memo";
                    case S:
                        o = s._payload, s = s._init;
                        try {
                            return X(s(o))
                        } catch (u) {}
                }
                return null
            }

            function O(s) {
                var o = s.type;
                switch (s.tag) {
                    case 24:
                        return "Cache";
                    case 9:
                        return (o.displayName || "Context") + ".Consumer";
                    case 10:
                        return (o._context.displayName || "Context") + ".Provider";
                    case 18:
                        return "DehydratedFragment";
                    case 11:
                        return s = (s = o.render).displayName || s.name || "", o.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
                    case 7:
                        return "Fragment";
                    case 5:
                        return o;
                    case 4:
                        return "Portal";
                    case 3:
                        return "Root";
                    case 6:
                        return "Text";
                    case 16:
                        return X(o);
                    case 8:
                        return o === f ? "StrictMode" : "Mode";
                    case 22:
                        return "Offscreen";
                    case 12:
                        return "Profiler";
                    case 21:
                        return "Scope";
                    case 13:
                        return "Suspense";
                    case 19:
                        return "SuspenseList";
                    case 25:
                        return "TracingMarker";
                    case 1:
                    case 0:
                    case 17:
                    case 2:
                    case 14:
                    case 15:
                        if (typeof o == "function") return o.displayName || o.name || null;
                        if (typeof o == "string") return o
                }
                return null
            }

            function M(s) {
                var o = s,
                    u = s;
                if (s.alternate)
                    for (; o.return;) o = o.return;
                else {
                    s = o;
                    do 4098 & (o = s).flags && (u = o.return), s = o.return; while (s)
                }
                return o.tag === 3 ? u : null
            }

            function $(s) {
                if (M(s) !== s) throw Error(a(188))
            }

            function nt(s) {
                var o = s.alternate;
                if (!o) {
                    if ((o = M(s)) === null) throw Error(a(188));
                    return o !== s ? null : s
                }
                for (var u = s, p = o;;) {
                    var m = u.return;
                    if (m === null) break;
                    var v = m.alternate;
                    if (v === null) {
                        if ((p = m.return) !== null) {
                            u = p;
                            continue
                        }
                        break
                    }
                    if (m.child === v.child) {
                        for (v = m.child; v;) {
                            if (v === u) return $(m), s;
                            if (v === p) return $(m), o;
                            v = v.sibling
                        }
                        throw Error(a(188))
                    }
                    if (u.return !== p.return) u = m, p = v;
                    else {
                        for (var b = !1, A = m.child; A;) {
                            if (A === u) {
                                b = !0, u = m, p = v;
                                break
                            }
                            if (A === p) {
                                b = !0, p = m, u = v;
                                break
                            }
                            A = A.sibling
                        }
                        if (!b) {
                            for (A = v.child; A;) {
                                if (A === u) {
                                    b = !0, u = v, p = m;
                                    break
                                }
                                if (A === p) {
                                    b = !0, p = v, u = m;
                                    break
                                }
                                A = A.sibling
                            }
                            if (!b) throw Error(a(189))
                        }
                    }
                    if (u.alternate !== p) throw Error(a(190))
                }
                if (u.tag !== 3) throw Error(a(188));
                return u.stateNode.current === u ? s : o
            }

            function Y(s) {
                return (s = nt(s)) !== null ? q(s) : null
            }

            function q(s) {
                if (s.tag === 5 || s.tag === 6) return s;
                for (s = s.child; s !== null;) {
                    var o = q(s);
                    if (o !== null) return o;
                    s = s.sibling
                }
                return null
            }

            function B(s) {
                if (s.tag === 5 || s.tag === 6) return s;
                for (s = s.child; s !== null;) {
                    if (s.tag !== 4) {
                        var o = B(s);
                        if (o !== null) return o
                    }
                    s = s.sibling
                }
                return null
            }
            var G, pt = Array.isArray,
                ft = t.getPublicInstance,
                J = t.getRootHostContext,
                j = t.getChildHostContext,
                rt = t.prepareForCommit,
                D = t.resetAfterCommit,
                tt = t.createInstance,
                ht = t.appendInitialChild,
                _t = t.finalizeInitialChildren,
                vt = t.prepareUpdate,
                Nt = t.shouldSetTextContent,
                Ct = t.createTextInstance,
                Ot = t.scheduleTimeout,
                de = t.cancelTimeout,
                xe = t.noTimeout,
                qt = t.isPrimaryRenderer,
                xt = t.supportsMutation,
                kt = t.supportsPersistence,
                St = t.supportsHydration,
                rr = t.getInstanceFromNode,
                ir = t.preparePortalMount,
                sn = t.getCurrentEventPriority,
                Lc = t.detachDeletedInstance,
                jn = t.supportsMicrotasks,
                GA = t.scheduleMicrotask,
                Ys = t.supportsTestSelectors,
                zA = t.findFiberRoot,
                HA = t.getBoundingRect,
                jA = t.getTextContent,
                qs = t.isHiddenSubtree,
                WA = t.matchAccessibilityRole,
                XA = t.setFocusIfFocusable,
                $A = t.setupIntersectionObserver,
                VA = t.appendChild,
                YA = t.appendChildToContainer,
                qA = t.commitTextUpdate,
                QA = t.commitMount,
                KA = t.commitUpdate,
                ZA = t.insertBefore,
                JA = t.insertInContainerBefore,
                tP = t.removeChild,
                eP = t.removeChildFromContainer,
                uy = t.resetTextContent,
                rP = t.hideInstance,
                iP = t.hideTextInstance,
                nP = t.unhideInstance,
                sP = t.unhideTextInstance,
                aP = t.clearContainer,
                oP = t.cloneInstance,
                cy = t.createContainerChildSet,
                dy = t.appendChildToContainerChildSet,
                lP = t.finalizeContainerChildren,
                Bc = t.replaceContainerChildren,
                py = t.cloneHiddenInstance,
                fy = t.cloneHiddenTextInstance,
                hP = t.canHydrateInstance,
                uP = t.canHydrateTextInstance,
                cP = t.canHydrateSuspenseInstance,
                my = t.isSuspenseInstancePending,
                kc = t.isSuspenseInstanceFallback,
                dP = t.getSuspenseInstanceFallbackErrorDetails,
                pP = t.registerSuspenseInstanceRetry,
                Go = t.getNextHydratableSibling,
                fP = t.getFirstHydratableChild,
                mP = t.getFirstHydratableChildWithinContainer,
                gP = t.getFirstHydratableChildWithinSuspenseInstance,
                yP = t.hydrateInstance,
                vP = t.hydrateTextInstance,
                xP = t.hydrateSuspenseInstance,
                _P = t.getNextHydratableInstanceAfterSuspenseInstance,
                bP = t.commitHydratedContainer,
                EP = t.commitHydratedSuspenseInstance,
                TP = t.clearSuspenseBoundary,
                wP = t.clearSuspenseBoundaryFromContainer,
                SP = t.shouldDeleteUnhydratedTailInstances,
                AP = t.didNotMatchHydratedContainerTextInstance,
                PP = t.didNotMatchHydratedTextInstance;

            function Qs(s) {
                if (G === void 0) try {
                    throw Error()
                } catch (u) {
                    var o = u.stack.trim().match(/\n( *(at )?)/);
                    G = o && o[1] || ""
                }
                return `
` + G + s
            }
            var Fc = !1;

            function Uc(s, o) {
                if (!s || Fc) return "";
                Fc = !0;
                var u = Error.prepareStackTrace;
                Error.prepareStackTrace = void 0;
                try {
                    if (o)
                        if (o = function() {
                                throw Error()
                            }, Object.defineProperty(o.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }), typeof Reflect == "object" && Reflect.construct) {
                            try {
                                Reflect.construct(o, [])
                            } catch (L) {
                                var p = L
                            }
                            Reflect.construct(s, [], o)
                        } else {
                            try {
                                o.call()
                            } catch (L) {
                                p = L
                            }
                            s.call(o.prototype)
                        }
                    else {
                        try {
                            throw Error()
                        } catch (L) {
                            p = L
                        }
                        s()
                    }
                } catch (L) {
                    if (L && p && typeof L.stack == "string") {
                        for (var m = L.stack.split(`
`), v = p.stack.split(`
`), b = m.length - 1, A = v.length - 1; 1 <= b && 0 <= A && m[b] !== v[A];) A--;
                        for (; 1 <= b && 0 <= A; b--, A--)
                            if (m[b] !== v[A]) {
                                if (b !== 1 || A !== 1)
                                    do
                                        if (b--, 0 > --A || m[b] !== v[A]) {
                                            var R = `
` + m[b].replace(" at new ", " at ");
                                            return s.displayName && R.includes("<anonymous>") && (R = R.replace("<anonymous>", s.displayName)), R
                                        }
                                while (1 <= b && 0 <= A);
                                break
                            }
                    }
                } finally {
                    Fc = !1, Error.prepareStackTrace = u
                }
                return (s = s ? s.displayName || s.name : "") ? Qs(s) : ""
            }
            var CP = Object.prototype.hasOwnProperty,
                Gc = [],
                Wn = -1;

            function Pi(s) {
                return {
                    current: s
                }
            }

            function zt(s) {
                0 > Wn || (s.current = Gc[Wn], Gc[Wn] = null, Wn--)
            }

            function Lt(s, o) {
                Wn++, Gc[Wn] = s.current, s.current = o
            }
            var Ci = {},
                Ae = Pi(Ci),
                Be = Pi(!1),
                an = Ci;

            function Xn(s, o) {
                var u = s.type.contextTypes;
                if (!u) return Ci;
                var p = s.stateNode;
                if (p && p.__reactInternalMemoizedUnmaskedChildContext === o) return p.__reactInternalMemoizedMaskedChildContext;
                var m, v = {};
                for (m in u) v[m] = o[m];
                return p && ((s = s.stateNode).__reactInternalMemoizedUnmaskedChildContext = o, s.__reactInternalMemoizedMaskedChildContext = v), v
            }

            function We(s) {
                return (s = s.childContextTypes) != null
            }

            function zc() {
                zt(Be), zt(Ae)
            }

            function gy(s, o, u) {
                if (Ae.current !== Ci) throw Error(a(168));
                Lt(Ae, o), Lt(Be, u)
            }

            function yy(s, o, u) {
                var p = s.stateNode;
                if (o = o.childContextTypes, typeof p.getChildContext != "function") return u;
                for (var m in p = p.getChildContext())
                    if (!(m in o)) throw Error(a(108, O(s) || "Unknown", m));
                return n({}, u, p)
            }

            function zo(s) {
                return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || Ci, an = Ae.current, Lt(Ae, s), Lt(Be, Be.current), !0
            }

            function vy(s, o, u) {
                var p = s.stateNode;
                if (!p) throw Error(a(169));
                u ? (s = yy(s, o, an), p.__reactInternalMemoizedMergedChildContext = s, zt(Be), zt(Ae), Lt(Ae, s)) : zt(Be), Lt(Be, u)
            }
            var wr = Math.clz32 ? Math.clz32 : function(s) {
                    return (s >>>= 0) === 0 ? 32 : 31 - (IP(s) / RP | 0) | 0
                },
                IP = Math.log,
                RP = Math.LN2,
                Hc = 64,
                jc = 4194304;

            function Ks(s) {
                switch (s & -s) {
                    case 1:
                        return 1;
                    case 2:
                        return 2;
                    case 4:
                        return 4;
                    case 8:
                        return 8;
                    case 16:
                        return 16;
                    case 32:
                        return 32;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return 4194240 & s;
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                        return 130023424 & s;
                    case 134217728:
                        return 134217728;
                    case 268435456:
                        return 268435456;
                    case 536870912:
                        return 536870912;
                    case 1073741824:
                        return 1073741824;
                    default:
                        return s
                }
            }

            function Ho(s, o) {
                var u = s.pendingLanes;
                if (u === 0) return 0;
                var p = 0,
                    m = s.suspendedLanes,
                    v = s.pingedLanes,
                    b = 268435455 & u;
                if (b !== 0) {
                    var A = b & ~m;
                    A !== 0 ? p = Ks(A) : (v &= b) !== 0 && (p = Ks(v))
                } else(b = u & ~m) !== 0 ? p = Ks(b) : v !== 0 && (p = Ks(v));
                if (p === 0) return 0;
                if (o !== 0 && o !== p && !(o & m) && ((m = p & -p) >= (v = o & -o) || m === 16 && 4194240 & v)) return o;
                if (4 & p && (p |= 16 & u), (o = s.entangledLanes) !== 0)
                    for (s = s.entanglements, o &= p; 0 < o;) m = 1 << (u = 31 - wr(o)), p |= s[u], o &= ~m;
                return p
            }

            function MP(s, o) {
                switch (s) {
                    case 1:
                    case 2:
                    case 4:
                        return o + 250;
                    case 8:
                    case 16:
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                        return o + 5e3;
                    default:
                        return -1
                }
            }

            function Wc(s) {
                return (s = -1073741825 & s.pendingLanes) !== 0 ? s : 1073741824 & s ? 1073741824 : 0
            }

            function xy() {
                var s = Hc;
                return !(4194240 & (Hc <<= 1)) && (Hc = 64), s
            }

            function Xc(s) {
                for (var o = [], u = 0; 31 > u; u++) o.push(s);
                return o
            }

            function Zs(s, o, u) {
                s.pendingLanes |= o, o !== 536870912 && (s.suspendedLanes = 0, s.pingedLanes = 0), (s = s.eventTimes)[o = 31 - wr(o)] = u
            }

            function $c(s, o) {
                var u = s.entangledLanes |= o;
                for (s = s.entanglements; u;) {
                    var p = 31 - wr(u),
                        m = 1 << p;
                    m & o | s[p] & o && (s[p] |= o), u &= ~m
                }
            }
            var At = 0;

            function _y(s) {
                return 1 < (s &= -s) ? 4 < s ? 268435455 & s ? 16 : 536870912 : 4 : 1
            }
            var Vc = i.unstable_scheduleCallback,
                by = i.unstable_cancelCallback,
                DP = i.unstable_shouldYield,
                NP = i.unstable_requestPaint,
                pe = i.unstable_now,
                Yc = i.unstable_ImmediatePriority,
                OP = i.unstable_UserBlockingPriority,
                Ey = i.unstable_NormalPriority,
                LP = i.unstable_IdlePriority,
                jo = null,
                zr = null,
                Sr = typeof Object.is == "function" ? Object.is : function(s, o) {
                    return s === o && (s !== 0 || 1 / s == 1 / o) || s != s && o != o
                },
                hi = null,
                Wo = !1,
                qc = !1;

            function Ty(s) {
                hi === null ? hi = [s] : hi.push(s)
            }

            function Hr() {
                if (!qc && hi !== null) {
                    qc = !0;
                    var s = 0,
                        o = At;
                    try {
                        var u = hi;
                        for (At = 1; s < u.length; s++) {
                            var p = u[s];
                            do p = p(!0); while (p !== null)
                        }
                        hi = null, Wo = !1
                    } catch (m) {
                        throw hi !== null && (hi = hi.slice(s + 1)), Vc(Yc, Hr), m
                    } finally {
                        At = o, qc = !1
                    }
                }
                return null
            }
            var $n = [],
                Vn = 0,
                Xo = null,
                $o = 0,
                nr = [],
                sr = 0,
                on = null,
                jr = 1,
                ui = "";

            function ln(s, o) {
                $n[Vn++] = $o, $n[Vn++] = Xo, Xo = s, $o = o
            }

            function wy(s, o, u) {
                nr[sr++] = jr, nr[sr++] = ui, nr[sr++] = on, on = s;
                var p = jr;
                s = ui;
                var m = 32 - wr(p) - 1;
                p &= ~(1 << m), u += 1;
                var v = 32 - wr(o) + m;
                if (30 < v) {
                    var b = m - m % 5;
                    v = (p & (1 << b) - 1).toString(32), p >>= b, m -= b, jr = 1 << 32 - wr(o) + m | u << m | p, ui = v + s
                } else jr = 1 << v | u << m | p, ui = s
            }

            function Qc(s) {
                s.return !== null && (ln(s, 1), wy(s, 1, 0))
            }

            function Kc(s) {
                for (; s === Xo;) Xo = $n[--Vn], $n[Vn] = null, $o = $n[--Vn], $n[Vn] = null;
                for (; s === on;) on = nr[--sr], nr[sr] = null, ui = nr[--sr], nr[sr] = null, jr = nr[--sr], nr[sr] = null
            }
            var Xe = null,
                ar = null,
                Ht = !1,
                Js = !1,
                Ar = null;

            function Sy(s, o) {
                var u = cr(5, null, null, 0);
                u.elementType = "DELETED", u.stateNode = o, u.return = s, (o = s.deletions) === null ? (s.deletions = [u], s.flags |= 16) : o.push(u)
            }

            function Ay(s, o) {
                switch (s.tag) {
                    case 5:
                        return (o = hP(o, s.type, s.pendingProps)) !== null && (s.stateNode = o, Xe = s, ar = fP(o), !0);
                    case 6:
                        return (o = uP(o, s.pendingProps)) !== null && (s.stateNode = o, Xe = s, ar = null, !0);
                    case 13:
                        if ((o = cP(o)) !== null) {
                            var u = on !== null ? {
                                id: jr,
                                overflow: ui
                            } : null;
                            return s.memoizedState = {
                                dehydrated: o,
                                treeContext: u,
                                retryLane: 1073741824
                            }, (u = cr(18, null, null, 0)).stateNode = o, u.return = s, s.child = u, Xe = s, ar = null, !0
                        }
                        return !1;
                    default:
                        return !1
                }
            }

            function Zc(s) {
                return (1 & s.mode) != 0 && (128 & s.flags) == 0
            }

            function Jc(s) {
                if (Ht) {
                    var o = ar;
                    if (o) {
                        var u = o;
                        if (!Ay(s, o)) {
                            if (Zc(s)) throw Error(a(418));
                            o = Go(u);
                            var p = Xe;
                            o && Ay(s, o) ? Sy(p, u) : (s.flags = -4097 & s.flags | 2, Ht = !1, Xe = s)
                        }
                    } else {
                        if (Zc(s)) throw Error(a(418));
                        s.flags = -4097 & s.flags | 2, Ht = !1, Xe = s
                    }
                }
            }

            function Py(s) {
                for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13;) s = s.return;
                Xe = s
            }

            function Vo(s) {
                if (!St || s !== Xe) return !1;
                if (!Ht) return Py(s), Ht = !0, !1;
                if (s.tag !== 3 && (s.tag !== 5 || SP(s.type) && !Nt(s.type, s.memoizedProps))) {
                    var o = ar;
                    if (o) {
                        if (Zc(s)) throw Cy(), Error(a(418));
                        for (; o;) Sy(s, o), o = Go(o)
                    }
                }
                if (Py(s), s.tag === 13) {
                    if (!St) throw Error(a(316));
                    if (!(s = (s = s.memoizedState) !== null ? s.dehydrated : null)) throw Error(a(317));
                    ar = _P(s)
                } else ar = Xe ? Go(s.stateNode) : null;
                return !0
            }

            function Cy() {
                for (var s = ar; s;) s = Go(s)
            }

            function Yn() {
                St && (ar = Xe = null, Js = Ht = !1)
            }

            function td(s) {
                Ar === null ? Ar = [s] : Ar.push(s)
            }
            var BP = l.ReactCurrentBatchConfig;

            function Yo(s, o) {
                if (Sr(s, o)) return !0;
                if (typeof s != "object" || s === null || typeof o != "object" || o === null) return !1;
                var u = Object.keys(s),
                    p = Object.keys(o);
                if (u.length !== p.length) return !1;
                for (p = 0; p < u.length; p++) {
                    var m = u[p];
                    if (!CP.call(o, m) || !Sr(s[m], o[m])) return !1
                }
                return !0
            }

            function kP(s) {
                switch (s.tag) {
                    case 5:
                        return Qs(s.type);
                    case 16:
                        return Qs("Lazy");
                    case 13:
                        return Qs("Suspense");
                    case 19:
                        return Qs("SuspenseList");
                    case 0:
                    case 2:
                    case 15:
                        return s = Uc(s.type, !1);
                    case 11:
                        return s = Uc(s.type.render, !1);
                    case 1:
                        return s = Uc(s.type, !0);
                    default:
                        return ""
                }
            }

            function Pr(s, o) {
                if (s && s.defaultProps) {
                    for (var u in o = n({}, o), s = s.defaultProps) o[u] === void 0 && (o[u] = s[u]);
                    return o
                }
                return o
            }
            var qo = Pi(null),
                Qo = null,
                qn = null,
                ed = null;

            function rd() {
                ed = qn = Qo = null
            }

            function Iy(s, o, u) {
                qt ? (Lt(qo, o._currentValue), o._currentValue = u) : (Lt(qo, o._currentValue2), o._currentValue2 = u)
            }

            function id(s) {
                var o = qo.current;
                zt(qo), qt ? s._currentValue = o : s._currentValue2 = o
            }

            function nd(s, o, u) {
                for (; s !== null;) {
                    var p = s.alternate;
                    if ((s.childLanes & o) !== o ? (s.childLanes |= o, p !== null && (p.childLanes |= o)) : p !== null && (p.childLanes & o) !== o && (p.childLanes |= o), s === u) break;
                    s = s.return
                }
            }

            function Qn(s, o) {
                Qo = s, ed = qn = null, (s = s.dependencies) !== null && s.firstContext !== null && (s.lanes & o && (ke = !0), s.firstContext = null)
            }

            function or(s) {
                var o = qt ? s._currentValue : s._currentValue2;
                if (ed !== s)
                    if (s = {
                            context: s,
                            memoizedValue: o,
                            next: null
                        }, qn === null) {
                        if (Qo === null) throw Error(a(308));
                        qn = s, Qo.dependencies = {
                            lanes: 0,
                            firstContext: s
                        }
                    } else qn = qn.next = s;
                return o
            }
            var hn = null;

            function sd(s) {
                hn === null ? hn = [s] : hn.push(s)
            }

            function Ry(s, o, u, p) {
                var m = o.interleaved;
                return m === null ? (u.next = u, sd(o)) : (u.next = m.next, m.next = u), o.interleaved = u, Wr(s, p)
            }

            function Wr(s, o) {
                s.lanes |= o;
                var u = s.alternate;
                for (u !== null && (u.lanes |= o), u = s, s = s.return; s !== null;) s.childLanes |= o, (u = s.alternate) !== null && (u.childLanes |= o), u = s, s = s.return;
                return u.tag === 3 ? u.stateNode : null
            }
            var Ii = !1;

            function ad(s) {
                s.updateQueue = {
                    baseState: s.memoizedState,
                    firstBaseUpdate: null,
                    lastBaseUpdate: null,
                    shared: {
                        pending: null,
                        interleaved: null,
                        lanes: 0
                    },
                    effects: null
                }
            }

            function My(s, o) {
                s = s.updateQueue, o.updateQueue === s && (o.updateQueue = {
                    baseState: s.baseState,
                    firstBaseUpdate: s.firstBaseUpdate,
                    lastBaseUpdate: s.lastBaseUpdate,
                    shared: s.shared,
                    effects: s.effects
                })
            }

            function ci(s, o) {
                return {
                    eventTime: s,
                    lane: o,
                    tag: 0,
                    payload: null,
                    callback: null,
                    next: null
                }
            }

            function Ri(s, o, u) {
                var p = s.updateQueue;
                if (p === null) return null;
                if (p = p.shared, (2 & wt) != 0) {
                    var m = p.pending;
                    return m === null ? o.next = o : (o.next = m.next, m.next = o), p.pending = o, Wr(s, u)
                }
                return (m = p.interleaved) === null ? (o.next = o, sd(p)) : (o.next = m.next, m.next = o), p.interleaved = o, Wr(s, u)
            }

            function Ko(s, o, u) {
                if ((o = o.updateQueue) !== null && (o = o.shared, (4194240 & u) != 0)) {
                    var p = o.lanes;
                    u |= p &= s.pendingLanes, o.lanes = u, $c(s, u)
                }
            }

            function Dy(s, o) {
                var u = s.updateQueue,
                    p = s.alternate;
                if (p !== null && u === (p = p.updateQueue)) {
                    var m = null,
                        v = null;
                    if ((u = u.firstBaseUpdate) !== null) {
                        do {
                            var b = {
                                eventTime: u.eventTime,
                                lane: u.lane,
                                tag: u.tag,
                                payload: u.payload,
                                callback: u.callback,
                                next: null
                            };
                            v === null ? m = v = b : v = v.next = b, u = u.next
                        } while (u !== null);
                        v === null ? m = v = o : v = v.next = o
                    } else m = v = o;
                    return u = {
                        baseState: p.baseState,
                        firstBaseUpdate: m,
                        lastBaseUpdate: v,
                        shared: p.shared,
                        effects: p.effects
                    }, void(s.updateQueue = u)
                }(s = u.lastBaseUpdate) === null ? u.firstBaseUpdate = o : s.next = o, u.lastBaseUpdate = o
            }

            function Zo(s, o, u, p) {
                var m = s.updateQueue;
                Ii = !1;
                var v = m.firstBaseUpdate,
                    b = m.lastBaseUpdate,
                    A = m.shared.pending;
                if (A !== null) {
                    m.shared.pending = null;
                    var R = A,
                        L = R.next;
                    R.next = null, b === null ? v = L : b.next = L, b = R;
                    var F = s.alternate;
                    F !== null && (A = (F = F.updateQueue).lastBaseUpdate) !== b && (A === null ? F.firstBaseUpdate = L : A.next = L, F.lastBaseUpdate = R)
                }
                if (v !== null) {
                    var K = m.baseState;
                    for (b = 0, F = L = R = null, A = v;;) {
                        var k = A.lane,
                            W = A.eventTime;
                        if ((p & k) === k) {
                            F !== null && (F = F.next = {
                                eventTime: W,
                                lane: 0,
                                tag: A.tag,
                                payload: A.payload,
                                callback: A.callback,
                                next: null
                            });
                            t: {
                                var st = s,
                                    yt = A;
                                switch (k = o, W = u, yt.tag) {
                                    case 1:
                                        if (typeof(st = yt.payload) == "function") {
                                            K = st.call(W, K, k);
                                            break t
                                        }
                                        K = st;
                                        break t;
                                    case 3:
                                        st.flags = -65537 & st.flags | 128;
                                    case 0:
                                        if ((k = typeof(st = yt.payload) == "function" ? st.call(W, K, k) : st) == null) break t;
                                        K = n({}, K, k);
                                        break t;
                                    case 2:
                                        Ii = !0
                                }
                            }
                            A.callback !== null && A.lane !== 0 && (s.flags |= 64, (k = m.effects) === null ? m.effects = [A] : k.push(A))
                        } else W = {
                            eventTime: W,
                            lane: k,
                            tag: A.tag,
                            payload: A.payload,
                            callback: A.callback,
                            next: null
                        }, F === null ? (L = F = W, R = K) : F = F.next = W, b |= k;
                        if ((A = A.next) === null) {
                            if ((A = m.shared.pending) === null) break;
                            A = (k = A).next, k.next = null, m.lastBaseUpdate = k, m.shared.pending = null
                        }
                    }
                    if (F === null && (R = K), m.baseState = R, m.firstBaseUpdate = L, m.lastBaseUpdate = F, (o = m.shared.interleaved) !== null) {
                        m = o;
                        do b |= m.lane, m = m.next; while (m !== o)
                    } else v === null && (m.shared.lanes = 0);
                    cn |= b, s.lanes = b, s.memoizedState = K
                }
            }

            function Ny(s, o, u) {
                if (s = o.effects, o.effects = null, s !== null)
                    for (o = 0; o < s.length; o++) {
                        var p = s[o],
                            m = p.callback;
                        if (m !== null) {
                            if (p.callback = null, p = u, typeof m != "function") throw Error(a(191, m));
                            m.call(p)
                        }
                    }
            }
            var Oy = new r.Component().refs;

            function od(s, o, u, p) {
                u = (u = u(p, o = s.memoizedState)) == null ? o : n({}, o, u), s.memoizedState = u, s.lanes === 0 && (s.updateQueue.baseState = u)
            }
            var Jo = {
                isMounted: function(s) {
                    return !!(s = s._reactInternals) && M(s) === s
                },
                enqueueSetState: function(s, o, u) {
                    s = s._reactInternals;
                    var p = Ie(),
                        m = Oi(s),
                        v = ci(p, m);
                    v.payload = o, u != null && (v.callback = u), (o = Ri(s, v, m)) !== null && (ur(o, s, m, p), Ko(o, s, m))
                },
                enqueueReplaceState: function(s, o, u) {
                    s = s._reactInternals;
                    var p = Ie(),
                        m = Oi(s),
                        v = ci(p, m);
                    v.tag = 1, v.payload = o, u != null && (v.callback = u), (o = Ri(s, v, m)) !== null && (ur(o, s, m, p), Ko(o, s, m))
                },
                enqueueForceUpdate: function(s, o) {
                    s = s._reactInternals;
                    var u = Ie(),
                        p = Oi(s),
                        m = ci(u, p);
                    m.tag = 2, o != null && (m.callback = o), (o = Ri(s, m, p)) !== null && (ur(o, s, p, u), Ko(o, s, p))
                }
            };

            function Ly(s, o, u, p, m, v, b) {
                return typeof(s = s.stateNode).shouldComponentUpdate == "function" ? s.shouldComponentUpdate(p, v, b) : !o.prototype || !o.prototype.isPureReactComponent || !Yo(u, p) || !Yo(m, v)
            }

            function By(s, o, u) {
                var p = !1,
                    m = Ci,
                    v = o.contextType;
                return typeof v == "object" && v !== null ? v = or(v) : (m = We(o) ? an : Ae.current, v = (p = (p = o.contextTypes) != null) ? Xn(s, m) : Ci), o = new o(u, v), s.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, o.updater = Jo, s.stateNode = o, o._reactInternals = s, p && ((s = s.stateNode).__reactInternalMemoizedUnmaskedChildContext = m, s.__reactInternalMemoizedMaskedChildContext = v), o
            }

            function ky(s, o, u, p) {
                s = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(u, p), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(u, p), o.state !== s && Jo.enqueueReplaceState(o, o.state, null)
            }

            function ld(s, o, u, p) {
                var m = s.stateNode;
                m.props = u, m.state = s.memoizedState, m.refs = Oy, ad(s);
                var v = o.contextType;
                typeof v == "object" && v !== null ? m.context = or(v) : (v = We(o) ? an : Ae.current, m.context = Xn(s, v)), m.state = s.memoizedState, typeof(v = o.getDerivedStateFromProps) == "function" && (od(s, o, v, u), m.state = s.memoizedState), typeof o.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (o = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), o !== m.state && Jo.enqueueReplaceState(m, m.state, null), Zo(s, u, m, p), m.state = s.memoizedState), typeof m.componentDidMount == "function" && (s.flags |= 4194308)
            }

            function ta(s, o, u) {
                if ((s = u.ref) !== null && typeof s != "function" && typeof s != "object") {
                    if (u._owner) {
                        if (u = u._owner) {
                            if (u.tag !== 1) throw Error(a(309));
                            var p = u.stateNode
                        }
                        if (!p) throw Error(a(147, s));
                        var m = p,
                            v = "" + s;
                        return o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === v ? o.ref : (o = function(b) {
                            var A = m.refs;
                            A === Oy && (A = m.refs = {}), b === null ? delete A[v] : A[v] = b
                        }, o._stringRef = v, o)
                    }
                    if (typeof s != "string") throw Error(a(284));
                    if (!u._owner) throw Error(a(290, s))
                }
                return s
            }

            function tl(s, o) {
                throw s = Object.prototype.toString.call(o), Error(a(31, s === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : s))
            }

            function Fy(s) {
                return (0, s._init)(s._payload)
            }

            function Uy(s) {
                function o(U, C) {
                    if (s) {
                        var N = U.deletions;
                        N === null ? (U.deletions = [C], U.flags |= 16) : N.push(C)
                    }
                }

                function u(U, C) {
                    if (!s) return null;
                    for (; C !== null;) o(U, C), C = C.sibling;
                    return null
                }

                function p(U, C) {
                    for (U = new Map; C !== null;) C.key !== null ? U.set(C.key, C) : U.set(C.index, C), C = C.sibling;
                    return U
                }

                function m(U, C) {
                    return (U = Bi(U, C)).index = 0, U.sibling = null, U
                }

                function v(U, C, N) {
                    return U.index = N, s ? (N = U.alternate) !== null ? (N = N.index) < C ? (U.flags |= 2, C) : N : (U.flags |= 2, C) : (U.flags |= 1048576, C)
                }

                function b(U) {
                    return s && U.alternate === null && (U.flags |= 2), U
                }

                function A(U, C, N, H) {
                    return C === null || C.tag !== 6 ? ((C = Yd(N, U.mode, H)).return = U, C) : ((C = m(C, N)).return = U, C)
                }

                function R(U, C, N, H) {
                    var ct = N.type;
                    return ct === d ? F(U, C, N.props.children, H, N.key) : C !== null && (C.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === S && Fy(ct) === C.type) ? ((H = m(C, N.props)).ref = ta(U, C, N), H.return = U, H) : ((H = Al(N.type, N.key, N.props, null, U.mode, H)).ref = ta(U, C, N), H.return = U, H)
                }

                function L(U, C, N, H) {
                    return C === null || C.tag !== 4 || C.stateNode.containerInfo !== N.containerInfo || C.stateNode.implementation !== N.implementation ? ((C = qd(N, U.mode, H)).return = U, C) : ((C = m(C, N.children || [])).return = U, C)
                }

                function F(U, C, N, H, ct) {
                    return C === null || C.tag !== 7 ? ((C = fn(N, U.mode, H, ct)).return = U, C) : ((C = m(C, N)).return = U, C)
                }

                function K(U, C, N) {
                    if (typeof C == "string" && C !== "" || typeof C == "number") return (C = Yd("" + C, U.mode, N)).return = U, C;
                    if (typeof C == "object" && C !== null) {
                        switch (C.$$typeof) {
                            case h:
                                return (N = Al(C.type, C.key, C.props, null, U.mode, N)).ref = ta(U, null, C), N.return = U, N;
                            case c:
                                return (C = qd(C, U.mode, N)).return = U, C;
                            case S:
                                return K(U, (0, C._init)(C._payload), N)
                        }
                        if (pt(C) || z(C)) return (C = fn(C, U.mode, N, null)).return = U, C;
                        tl(U, C)
                    }
                    return null
                }

                function k(U, C, N, H) {
                    var ct = C !== null ? C.key : null;
                    if (typeof N == "string" && N !== "" || typeof N == "number") return ct !== null ? null : A(U, C, "" + N, H);
                    if (typeof N == "object" && N !== null) {
                        switch (N.$$typeof) {
                            case h:
                                return N.key === ct ? R(U, C, N, H) : null;
                            case c:
                                return N.key === ct ? L(U, C, N, H) : null;
                            case S:
                                return k(U, C, (ct = N._init)(N._payload), H)
                        }
                        if (pt(N) || z(N)) return ct !== null ? null : F(U, C, N, H, null);
                        tl(U, N)
                    }
                    return null
                }

                function W(U, C, N, H, ct) {
                    if (typeof H == "string" && H !== "" || typeof H == "number") return A(C, U = U.get(N) || null, "" + H, ct);
                    if (typeof H == "object" && H !== null) {
                        switch (H.$$typeof) {
                            case h:
                                return R(C, U = U.get(H.key === null ? N : H.key) || null, H, ct);
                            case c:
                                return L(C, U = U.get(H.key === null ? N : H.key) || null, H, ct);
                            case S:
                                return W(U, C, N, (0, H._init)(H._payload), ct)
                        }
                        if (pt(H) || z(H)) return F(C, U = U.get(N) || null, H, ct, null);
                        tl(C, H)
                    }
                    return null
                }

                function st(U, C, N, H) {
                    for (var ct = null, Rt = null, ot = C, Pt = C = 0, be = null; ot !== null && Pt < N.length; Pt++) {
                        ot.index > Pt ? (be = ot, ot = null) : be = ot.sibling;
                        var Mt = k(U, ot, N[Pt], H);
                        if (Mt === null) {
                            ot === null && (ot = be);
                            break
                        }
                        s && ot && Mt.alternate === null && o(U, ot), C = v(Mt, C, Pt), Rt === null ? ct = Mt : Rt.sibling = Mt, Rt = Mt, ot = be
                    }
                    if (Pt === N.length) return u(U, ot), Ht && ln(U, Pt), ct;
                    if (ot === null) {
                        for (; Pt < N.length; Pt++)(ot = K(U, N[Pt], H)) !== null && (C = v(ot, C, Pt), Rt === null ? ct = ot : Rt.sibling = ot, Rt = ot);
                        return Ht && ln(U, Pt), ct
                    }
                    for (ot = p(U, ot); Pt < N.length; Pt++)(be = W(ot, U, Pt, N[Pt], H)) !== null && (s && be.alternate !== null && ot.delete(be.key === null ? Pt : be.key), C = v(be, C, Pt), Rt === null ? ct = be : Rt.sibling = be, Rt = be);
                    return s && ot.forEach(function(ki) {
                        return o(U, ki)
                    }), Ht && ln(U, Pt), ct
                }

                function yt(U, C, N, H) {
                    var ct = z(N);
                    if (typeof ct != "function") throw Error(a(150));
                    if ((N = ct.call(N)) == null) throw Error(a(151));
                    for (var Rt = ct = null, ot = C, Pt = C = 0, be = null, Mt = N.next(); ot !== null && !Mt.done; Pt++, Mt = N.next()) {
                        ot.index > Pt ? (be = ot, ot = null) : be = ot.sibling;
                        var ki = k(U, ot, Mt.value, H);
                        if (ki === null) {
                            ot === null && (ot = be);
                            break
                        }
                        s && ot && ki.alternate === null && o(U, ot), C = v(ki, C, Pt), Rt === null ? ct = ki : Rt.sibling = ki, Rt = ki, ot = be
                    }
                    if (Mt.done) return u(U, ot), Ht && ln(U, Pt), ct;
                    if (ot === null) {
                        for (; !Mt.done; Pt++, Mt = N.next())(Mt = K(U, Mt.value, H)) !== null && (C = v(Mt, C, Pt), Rt === null ? ct = Mt : Rt.sibling = Mt, Rt = Mt);
                        return Ht && ln(U, Pt), ct
                    }
                    for (ot = p(U, ot); !Mt.done; Pt++, Mt = N.next())(Mt = W(ot, U, Pt, Mt.value, H)) !== null && (s && Mt.alternate !== null && ot.delete(Mt.key === null ? Pt : Mt.key), C = v(Mt, C, Pt), Rt === null ? ct = Mt : Rt.sibling = Mt, Rt = Mt);
                    return s && ot.forEach(function(oC) {
                        return o(U, oC)
                    }), Ht && ln(U, Pt), ct
                }
                return function U(C, N, H, ct) {
                    if (typeof H == "object" && H !== null && H.type === d && H.key === null && (H = H.props.children), typeof H == "object" && H !== null) {
                        switch (H.$$typeof) {
                            case h:
                                t: {
                                    for (var Rt = H.key, ot = N; ot !== null;) {
                                        if (ot.key === Rt) {
                                            if ((Rt = H.type) === d) {
                                                if (ot.tag === 7) {
                                                    u(C, ot.sibling), (N = m(ot, H.props.children)).return = C, C = N;
                                                    break t
                                                }
                                            } else if (ot.elementType === Rt || typeof Rt == "object" && Rt !== null && Rt.$$typeof === S && Fy(Rt) === ot.type) {
                                                u(C, ot.sibling), (N = m(ot, H.props)).ref = ta(C, ot, H), N.return = C, C = N;
                                                break t
                                            }
                                            u(C, ot);
                                            break
                                        }
                                        o(C, ot), ot = ot.sibling
                                    }
                                    H.type === d ? ((N = fn(H.props.children, C.mode, ct, H.key)).return = C, C = N) : ((ct = Al(H.type, H.key, H.props, null, C.mode, ct)).ref = ta(C, N, H), ct.return = C, C = ct)
                                }
                                return b(C);
                            case c:
                                t: {
                                    for (ot = H.key; N !== null;) {
                                        if (N.key === ot) {
                                            if (N.tag === 4 && N.stateNode.containerInfo === H.containerInfo && N.stateNode.implementation === H.implementation) {
                                                u(C, N.sibling), (N = m(N, H.children || [])).return = C, C = N;
                                                break t
                                            }
                                            u(C, N);
                                            break
                                        }
                                        o(C, N), N = N.sibling
                                    }(N = qd(H, C.mode, ct)).return = C,
                                    C = N
                                }
                                return b(C);
                            case S:
                                return U(C, N, (ot = H._init)(H._payload), ct)
                        }
                        if (pt(H)) return st(C, N, H, ct);
                        if (z(H)) return yt(C, N, H, ct);
                        tl(C, H)
                    }
                    return typeof H == "string" && H !== "" || typeof H == "number" ? (H = "" + H, N !== null && N.tag === 6 ? (u(C, N.sibling), (N = m(N, H)).return = C, C = N) : (u(C, N), (N = Yd(H, C.mode, ct)).return = C, C = N), b(C)) : u(C, N)
                }
            }
            var Kn = Uy(!0),
                Gy = Uy(!1),
                ea = {},
                lr = Pi(ea),
                ra = Pi(ea),
                Zn = Pi(ea);

            function Xr(s) {
                if (s === ea) throw Error(a(174));
                return s
            }

            function hd(s, o) {
                Lt(Zn, o), Lt(ra, s), Lt(lr, ea), s = J(o), zt(lr), Lt(lr, s)
            }

            function Jn() {
                zt(lr), zt(ra), zt(Zn)
            }

            function zy(s) {
                var o = Xr(Zn.current),
                    u = Xr(lr.current);
                u !== (o = j(u, s.type, o)) && (Lt(ra, s), Lt(lr, o))
            }

            function ud(s) {
                ra.current === s && (zt(lr), zt(ra))
            }
            var Qt = Pi(0);

            function el(s) {
                for (var o = s; o !== null;) {
                    if (o.tag === 13) {
                        var u = o.memoizedState;
                        if (u !== null && ((u = u.dehydrated) === null || my(u) || kc(u))) return o
                    } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
                        if (128 & o.flags) return o
                    } else if (o.child !== null) {
                        o.child.return = o, o = o.child;
                        continue
                    }
                    if (o === s) break;
                    for (; o.sibling === null;) {
                        if (o.return === null || o.return === s) return null;
                        o = o.return
                    }
                    o.sibling.return = o.return, o = o.sibling
                }
                return null
            }
            var cd = [];

            function dd() {
                for (var s = 0; s < cd.length; s++) {
                    var o = cd[s];
                    qt ? o._workInProgressVersionPrimary = null : o._workInProgressVersionSecondary = null
                }
                cd.length = 0
            }
            var rl = l.ReactCurrentDispatcher,
                pd = l.ReactCurrentBatchConfig,
                un = 0,
                $t = null,
                fe = null,
                me = null,
                il = !1,
                ia = !1,
                na = 0,
                FP = 0;

            function Pe() {
                throw Error(a(321))
            }

            function fd(s, o) {
                if (o === null) return !1;
                for (var u = 0; u < o.length && u < s.length; u++)
                    if (!Sr(s[u], o[u])) return !1;
                return !0
            }

            function md(s, o, u, p, m, v) {
                if (un = v, $t = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, rl.current = s === null || s.memoizedState === null ? HP : jP, s = u(p, m), ia) {
                    v = 0;
                    do {
                        if (ia = !1, na = 0, 25 <= v) throw Error(a(301));
                        v += 1, me = fe = null, o.updateQueue = null, rl.current = WP, s = u(p, m)
                    } while (ia)
                }
                if (rl.current = al, o = fe !== null && fe.next !== null, un = 0, me = fe = $t = null, il = !1, o) throw Error(a(300));
                return s
            }

            function gd() {
                var s = na !== 0;
                return na = 0, s
            }

            function $r() {
                var s = {
                    memoizedState: null,
                    baseState: null,
                    baseQueue: null,
                    queue: null,
                    next: null
                };
                return me === null ? $t.memoizedState = me = s : me = me.next = s, me
            }

            function hr() {
                if (fe === null) {
                    var s = $t.alternate;
                    s = s !== null ? s.memoizedState : null
                } else s = fe.next;
                var o = me === null ? $t.memoizedState : me.next;
                if (o !== null) me = o, fe = s;
                else {
                    if (s === null) throw Error(a(310));
                    s = {
                        memoizedState: (fe = s).memoizedState,
                        baseState: fe.baseState,
                        baseQueue: fe.baseQueue,
                        queue: fe.queue,
                        next: null
                    }, me === null ? $t.memoizedState = me = s : me = me.next = s
                }
                return me
            }

            function sa(s, o) {
                return typeof o == "function" ? o(s) : o
            }

            function yd(s) {
                var o = hr(),
                    u = o.queue;
                if (u === null) throw Error(a(311));
                u.lastRenderedReducer = s;
                var p = fe,
                    m = p.baseQueue,
                    v = u.pending;
                if (v !== null) {
                    if (m !== null) {
                        var b = m.next;
                        m.next = v.next, v.next = b
                    }
                    p.baseQueue = m = v, u.pending = null
                }
                if (m !== null) {
                    v = m.next, p = p.baseState;
                    var A = b = null,
                        R = null,
                        L = v;
                    do {
                        var F = L.lane;
                        if ((un & F) === F) R !== null && (R = R.next = {
                            lane: 0,
                            action: L.action,
                            hasEagerState: L.hasEagerState,
                            eagerState: L.eagerState,
                            next: null
                        }), p = L.hasEagerState ? L.eagerState : s(p, L.action);
                        else {
                            var K = {
                                lane: F,
                                action: L.action,
                                hasEagerState: L.hasEagerState,
                                eagerState: L.eagerState,
                                next: null
                            };
                            R === null ? (A = R = K, b = p) : R = R.next = K, $t.lanes |= F, cn |= F
                        }
                        L = L.next
                    } while (L !== null && L !== v);
                    R === null ? b = p : R.next = A, Sr(p, o.memoizedState) || (ke = !0), o.memoizedState = p, o.baseState = b, o.baseQueue = R, u.lastRenderedState = p
                }
                if ((s = u.interleaved) !== null) {
                    m = s;
                    do v = m.lane, $t.lanes |= v, cn |= v, m = m.next; while (m !== s)
                } else m === null && (u.lanes = 0);
                return [o.memoizedState, u.dispatch]
            }

            function vd(s) {
                var o = hr(),
                    u = o.queue;
                if (u === null) throw Error(a(311));
                u.lastRenderedReducer = s;
                var p = u.dispatch,
                    m = u.pending,
                    v = o.memoizedState;
                if (m !== null) {
                    u.pending = null;
                    var b = m = m.next;
                    do v = s(v, b.action), b = b.next; while (b !== m);
                    Sr(v, o.memoizedState) || (ke = !0), o.memoizedState = v, o.baseQueue === null && (o.baseState = v), u.lastRenderedState = v
                }
                return [v, p]
            }

            function Hy() {}

            function jy(s, o) {
                var u = $t,
                    p = hr(),
                    m = o(),
                    v = !Sr(p.memoizedState, m);
                if (v && (p.memoizedState = m, ke = !0), p = p.queue, xd($y.bind(null, u, p, s), [s]), p.getSnapshot !== o || v || me !== null && 1 & me.memoizedState.tag) {
                    if (u.flags |= 2048, aa(9, Xy.bind(null, u, p, m, o), void 0, null), ge === null) throw Error(a(349));
                    30 & un || Wy(u, o, m)
                }
                return m
            }

            function Wy(s, o, u) {
                s.flags |= 16384, s = {
                    getSnapshot: o,
                    value: u
                }, (o = $t.updateQueue) === null ? (o = {
                    lastEffect: null,
                    stores: null
                }, $t.updateQueue = o, o.stores = [s]) : (u = o.stores) === null ? o.stores = [s] : u.push(s)
            }

            function Xy(s, o, u, p) {
                o.value = u, o.getSnapshot = p, Vy(o) && Yy(s)
            }

            function $y(s, o, u) {
                return u(function() {
                    Vy(o) && Yy(s)
                })
            }

            function Vy(s) {
                var o = s.getSnapshot;
                s = s.value;
                try {
                    var u = o();
                    return !Sr(s, u)
                } catch (p) {
                    return !0
                }
            }

            function Yy(s) {
                var o = Wr(s, 1);
                o !== null && ur(o, s, 1, -1)
            }

            function qy(s) {
                var o = $r();
                return typeof s == "function" && (s = s()), o.memoizedState = o.baseState = s, s = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: sa,
                    lastRenderedState: s
                }, o.queue = s, s = s.dispatch = zP.bind(null, $t, s), [o.memoizedState, s]
            }

            function aa(s, o, u, p) {
                return s = {
                    tag: s,
                    create: o,
                    destroy: u,
                    deps: p,
                    next: null
                }, (o = $t.updateQueue) === null ? (o = {
                    lastEffect: null,
                    stores: null
                }, $t.updateQueue = o, o.lastEffect = s.next = s) : (u = o.lastEffect) === null ? o.lastEffect = s.next = s : (p = u.next, u.next = s, s.next = p, o.lastEffect = s), s
            }

            function Qy() {
                return hr().memoizedState
            }

            function nl(s, o, u, p) {
                var m = $r();
                $t.flags |= s, m.memoizedState = aa(1 | o, u, void 0, p === void 0 ? null : p)
            }

            function sl(s, o, u, p) {
                var m = hr();
                p = p === void 0 ? null : p;
                var v = void 0;
                if (fe !== null) {
                    var b = fe.memoizedState;
                    if (v = b.destroy, p !== null && fd(p, b.deps)) return void(m.memoizedState = aa(o, u, v, p))
                }
                $t.flags |= s, m.memoizedState = aa(1 | o, u, v, p)
            }

            function Ky(s, o) {
                return nl(8390656, 8, s, o)
            }

            function xd(s, o) {
                return sl(2048, 8, s, o)
            }

            function Zy(s, o) {
                return sl(4, 2, s, o)
            }

            function Jy(s, o) {
                return sl(4, 4, s, o)
            }

            function t0(s, o) {
                return typeof o == "function" ? (s = s(), o(s), function() {
                    o(null)
                }) : o != null ? (s = s(), o.current = s, function() {
                    o.current = null
                }) : void 0
            }

            function e0(s, o, u) {
                return u = u != null ? u.concat([s]) : null, sl(4, 4, t0.bind(null, o, s), u)
            }

            function _d() {}

            function r0(s, o) {
                var u = hr();
                o = o === void 0 ? null : o;
                var p = u.memoizedState;
                return p !== null && o !== null && fd(o, p[1]) ? p[0] : (u.memoizedState = [s, o], s)
            }

            function i0(s, o) {
                var u = hr();
                o = o === void 0 ? null : o;
                var p = u.memoizedState;
                return p !== null && o !== null && fd(o, p[1]) ? p[0] : (s = s(), u.memoizedState = [s, o], s)
            }

            function n0(s, o, u) {
                return 21 & un ? (Sr(u, o) || (u = xy(), $t.lanes |= u, cn |= u, s.baseState = !0), o) : (s.baseState && (s.baseState = !1, ke = !0), s.memoizedState = u)
            }

            function UP(s, o) {
                var u = At;
                At = u !== 0 && 4 > u ? u : 4, s(!0);
                var p = pd.transition;
                pd.transition = {};
                try {
                    s(!1), o()
                } finally {
                    At = u, pd.transition = p
                }
            }

            function s0() {
                return hr().memoizedState
            }

            function GP(s, o, u) {
                var p = Oi(s);
                u = {
                    lane: p,
                    action: u,
                    hasEagerState: !1,
                    eagerState: null,
                    next: null
                }, a0(s) ? o0(o, u) : (u = Ry(s, o, u, p)) !== null && (ur(u, s, p, Ie()), l0(u, o, p))
            }

            function zP(s, o, u) {
                var p = Oi(s),
                    m = {
                        lane: p,
                        action: u,
                        hasEagerState: !1,
                        eagerState: null,
                        next: null
                    };
                if (a0(s)) o0(o, m);
                else {
                    var v = s.alternate;
                    if (s.lanes === 0 && (v === null || v.lanes === 0) && (v = o.lastRenderedReducer) !== null) try {
                        var b = o.lastRenderedState,
                            A = v(b, u);
                        if (m.hasEagerState = !0, m.eagerState = A, Sr(A, b)) {
                            var R = o.interleaved;
                            return R === null ? (m.next = m, sd(o)) : (m.next = R.next, R.next = m), void(o.interleaved = m)
                        }
                    } catch (L) {}(u = Ry(s, o, m, p)) !== null && (ur(u, s, p, m = Ie()), l0(u, o, p))
                }
            }

            function a0(s) {
                var o = s.alternate;
                return s === $t || o !== null && o === $t
            }

            function o0(s, o) {
                ia = il = !0;
                var u = s.pending;
                u === null ? o.next = o : (o.next = u.next, u.next = o), s.pending = o
            }

            function l0(s, o, u) {
                if (4194240 & u) {
                    var p = o.lanes;
                    u |= p &= s.pendingLanes, o.lanes = u, $c(s, u)
                }
            }
            var al = {
                    readContext: or,
                    useCallback: Pe,
                    useContext: Pe,
                    useEffect: Pe,
                    useImperativeHandle: Pe,
                    useInsertionEffect: Pe,
                    useLayoutEffect: Pe,
                    useMemo: Pe,
                    useReducer: Pe,
                    useRef: Pe,
                    useState: Pe,
                    useDebugValue: Pe,
                    useDeferredValue: Pe,
                    useTransition: Pe,
                    useMutableSource: Pe,
                    useSyncExternalStore: Pe,
                    useId: Pe,
                    unstable_isNewReconciler: !1
                },
                HP = {
                    readContext: or,
                    useCallback: function(s, o) {
                        return $r().memoizedState = [s, o === void 0 ? null : o], s
                    },
                    useContext: or,
                    useEffect: Ky,
                    useImperativeHandle: function(s, o, u) {
                        return u = u != null ? u.concat([s]) : null, nl(4194308, 4, t0.bind(null, o, s), u)
                    },
                    useLayoutEffect: function(s, o) {
                        return nl(4194308, 4, s, o)
                    },
                    useInsertionEffect: function(s, o) {
                        return nl(4, 2, s, o)
                    },
                    useMemo: function(s, o) {
                        var u = $r();
                        return o = o === void 0 ? null : o, s = s(), u.memoizedState = [s, o], s
                    },
                    useReducer: function(s, o, u) {
                        var p = $r();
                        return o = u !== void 0 ? u(o) : o, p.memoizedState = p.baseState = o, s = {
                            pending: null,
                            interleaved: null,
                            lanes: 0,
                            dispatch: null,
                            lastRenderedReducer: s,
                            lastRenderedState: o
                        }, p.queue = s, s = s.dispatch = GP.bind(null, $t, s), [p.memoizedState, s]
                    },
                    useRef: function(s) {
                        return s = {
                            current: s
                        }, $r().memoizedState = s
                    },
                    useState: qy,
                    useDebugValue: _d,
                    useDeferredValue: function(s) {
                        return $r().memoizedState = s
                    },
                    useTransition: function() {
                        var s = qy(!1),
                            o = s[0];
                        return s = UP.bind(null, s[1]), $r().memoizedState = s, [o, s]
                    },
                    useMutableSource: function() {},
                    useSyncExternalStore: function(s, o, u) {
                        var p = $t,
                            m = $r();
                        if (Ht) {
                            if (u === void 0) throw Error(a(407));
                            u = u()
                        } else {
                            if (u = o(), ge === null) throw Error(a(349));
                            30 & un || Wy(p, o, u)
                        }
                        m.memoizedState = u;
                        var v = {
                            value: u,
                            getSnapshot: o
                        };
                        return m.queue = v, Ky($y.bind(null, p, v, s), [s]), p.flags |= 2048, aa(9, Xy.bind(null, p, v, u, o), void 0, null), u
                    },
                    useId: function() {
                        var s = $r(),
                            o = ge.identifierPrefix;
                        if (Ht) {
                            var u = ui;
                            o = ":" + o + "R" + (u = (jr & ~(1 << 32 - wr(jr) - 1)).toString(32) + u), 0 < (u = na++) && (o += "H" + u.toString(32)), o += ":"
                        } else o = ":" + o + "r" + (u = FP++).toString(32) + ":";
                        return s.memoizedState = o
                    },
                    unstable_isNewReconciler: !1
                },
                jP = {
                    readContext: or,
                    useCallback: r0,
                    useContext: or,
                    useEffect: xd,
                    useImperativeHandle: e0,
                    useInsertionEffect: Zy,
                    useLayoutEffect: Jy,
                    useMemo: i0,
                    useReducer: yd,
                    useRef: Qy,
                    useState: function() {
                        return yd(sa)
                    },
                    useDebugValue: _d,
                    useDeferredValue: function(s) {
                        return n0(hr(), fe.memoizedState, s)
                    },
                    useTransition: function() {
                        return [yd(sa)[0], hr().memoizedState]
                    },
                    useMutableSource: Hy,
                    useSyncExternalStore: jy,
                    useId: s0,
                    unstable_isNewReconciler: !1
                },
                WP = {
                    readContext: or,
                    useCallback: r0,
                    useContext: or,
                    useEffect: xd,
                    useImperativeHandle: e0,
                    useInsertionEffect: Zy,
                    useLayoutEffect: Jy,
                    useMemo: i0,
                    useReducer: vd,
                    useRef: Qy,
                    useState: function() {
                        return vd(sa)
                    },
                    useDebugValue: _d,
                    useDeferredValue: function(s) {
                        var o = hr();
                        return fe === null ? o.memoizedState = s : n0(o, fe.memoizedState, s)
                    },
                    useTransition: function() {
                        return [vd(sa)[0], hr().memoizedState]
                    },
                    useMutableSource: Hy,
                    useSyncExternalStore: jy,
                    useId: s0,
                    unstable_isNewReconciler: !1
                };

            function ts(s, o) {
                try {
                    var u = "",
                        p = o;
                    do u += kP(p), p = p.return; while (p);
                    var m = u
                } catch (v) {
                    m = `
Error generating stack: ` + v.message + `
` + v.stack
                }
                return {
                    value: s,
                    source: o,
                    stack: m,
                    digest: null
                }
            }

            function bd(s, o, u) {
                return {
                    value: s,
                    source: null,
                    stack: u != null ? u : null,
                    digest: o != null ? o : null
                }
            }

            function Ed(s, o) {
                try {} catch (u) {
                    setTimeout(function() {
                        throw u
                    })
                }
            }
            var XP = typeof WeakMap == "function" ? WeakMap : Map;

            function h0(s, o, u) {
                (u = ci(-1, u)).tag = 3, u.payload = {
                    element: null
                };
                var p = o.value;
                return u.callback = function() {
                    _l || (_l = !0, zd = p), Ed(0, o)
                }, u
            }

            function u0(s, o, u) {
                (u = ci(-1, u)).tag = 3;
                var p = s.type.getDerivedStateFromError;
                if (typeof p == "function") {
                    var m = o.value;
                    u.payload = function() {
                        return p(m)
                    }, u.callback = function() {
                        Ed(0, o)
                    }
                }
                var v = s.stateNode;
                return v !== null && typeof v.componentDidCatch == "function" && (u.callback = function() {
                    Ed(0, o), typeof p != "function" && (Di === null ? Di = new Set([this]) : Di.add(this));
                    var b = o.stack;
                    this.componentDidCatch(o.value, {
                        componentStack: b !== null ? b : ""
                    })
                }), u
            }

            function c0(s, o, u) {
                var p = s.pingCache;
                if (p === null) {
                    p = s.pingCache = new XP;
                    var m = new Set;
                    p.set(o, m)
                } else(m = p.get(o)) === void 0 && (m = new Set, p.set(o, m));
                m.has(u) || (m.add(u), s = tC.bind(null, s, o, u), o.then(s, s))
            }

            function d0(s) {
                do {
                    var o;
                    if ((o = s.tag === 13) && (o = (o = s.memoizedState) === null || o.dehydrated !== null), o) return s;
                    s = s.return
                } while (s !== null);
                return null
            }

            function p0(s, o, u, p, m) {
                return 1 & s.mode ? (s.flags |= 65536, s.lanes = m, s) : (s === o ? s.flags |= 65536 : (s.flags |= 128, u.flags |= 131072, u.flags &= -52805, u.tag === 1 && (u.alternate === null ? u.tag = 17 : ((o = ci(-1, 1)).tag = 2, Ri(u, o, 1))), u.lanes |= 1), s)
            }
            var $P = l.ReactCurrentOwner,
                ke = !1;

            function Fe(s, o, u, p) {
                o.child = s === null ? Gy(o, null, u, p) : Kn(o, s.child, u, p)
            }

            function f0(s, o, u, p, m) {
                u = u.render;
                var v = o.ref;
                return Qn(o, m), p = md(s, o, u, p, v, m), u = gd(), s === null || ke ? (Ht && u && Qc(o), o.flags |= 1, Fe(s, o, p, m), o.child) : (o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~m, di(s, o, m))
            }

            function m0(s, o, u, p, m) {
                if (s === null) {
                    var v = u.type;
                    return typeof v != "function" || Vd(v) || v.defaultProps !== void 0 || u.compare !== null || u.defaultProps !== void 0 ? ((s = Al(u.type, null, p, o, o.mode, m)).ref = o.ref, s.return = o, o.child = s) : (o.tag = 15, o.type = v, g0(s, o, v, p, m))
                }
                if (v = s.child, (s.lanes & m) == 0) {
                    var b = v.memoizedProps;
                    if ((u = (u = u.compare) !== null ? u : Yo)(b, p) && s.ref === o.ref) return di(s, o, m)
                }
                return o.flags |= 1, (s = Bi(v, p)).ref = o.ref, s.return = o, o.child = s
            }

            function g0(s, o, u, p, m) {
                if (s !== null) {
                    var v = s.memoizedProps;
                    if (Yo(v, p) && s.ref === o.ref) {
                        if (ke = !1, o.pendingProps = p = v, (s.lanes & m) == 0) return o.lanes = s.lanes, di(s, o, m);
                        131072 & s.flags && (ke = !0)
                    }
                }
                return Td(s, o, u, p, m)
            }

            function y0(s, o, u) {
                var p = o.pendingProps,
                    m = p.children,
                    v = s !== null ? s.memoizedState : null;
                if (p.mode === "hidden")
                    if (!(1 & o.mode)) o.memoizedState = {
                        baseLanes: 0,
                        cachePool: null,
                        transitions: null
                    }, Lt(rs, $e), $e |= u;
                    else {
                        if (!(1073741824 & u)) return s = v !== null ? v.baseLanes | u : u, o.lanes = o.childLanes = 1073741824, o.memoizedState = {
                            baseLanes: s,
                            cachePool: null,
                            transitions: null
                        }, o.updateQueue = null, Lt(rs, $e), $e |= s, null;
                        o.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        }, p = v !== null ? v.baseLanes : u, Lt(rs, $e), $e |= p
                    }
                else v !== null ? (p = v.baseLanes | u, o.memoizedState = null) : p = u, Lt(rs, $e), $e |= p;
                return Fe(s, o, m, u), o.child
            }

            function v0(s, o) {
                var u = o.ref;
                (s === null && u !== null || s !== null && s.ref !== u) && (o.flags |= 512, o.flags |= 2097152)
            }

            function Td(s, o, u, p, m) {
                var v = We(u) ? an : Ae.current;
                return v = Xn(o, v), Qn(o, m), u = md(s, o, u, p, v, m), p = gd(), s === null || ke ? (Ht && p && Qc(o), o.flags |= 1, Fe(s, o, u, m), o.child) : (o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~m, di(s, o, m))
            }

            function x0(s, o, u, p, m) {
                if (We(u)) {
                    var v = !0;
                    zo(o)
                } else v = !1;
                if (Qn(o, m), o.stateNode === null) ul(s, o), By(o, u, p), ld(o, u, p, m), p = !0;
                else if (s === null) {
                    var b = o.stateNode,
                        A = o.memoizedProps;
                    b.props = A;
                    var R = b.context,
                        L = u.contextType;
                    typeof L == "object" && L !== null ? L = or(L) : L = Xn(o, L = We(u) ? an : Ae.current);
                    var F = u.getDerivedStateFromProps,
                        K = typeof F == "function" || typeof b.getSnapshotBeforeUpdate == "function";
                    K || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (A !== p || R !== L) && ky(o, b, p, L), Ii = !1;
                    var k = o.memoizedState;
                    b.state = k, Zo(o, p, b, m), R = o.memoizedState, A !== p || k !== R || Be.current || Ii ? (typeof F == "function" && (od(o, u, F, p), R = o.memoizedState), (A = Ii || Ly(o, u, A, p, k, R, L)) ? (K || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()), typeof b.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof b.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = p, o.memoizedState = R), b.props = p, b.state = R, b.context = L, p = A) : (typeof b.componentDidMount == "function" && (o.flags |= 4194308), p = !1)
                } else {
                    b = o.stateNode, My(s, o), A = o.memoizedProps, L = o.type === o.elementType ? A : Pr(o.type, A), b.props = L, K = o.pendingProps, k = b.context, typeof(R = u.contextType) == "object" && R !== null ? R = or(R) : R = Xn(o, R = We(u) ? an : Ae.current);
                    var W = u.getDerivedStateFromProps;
                    (F = typeof W == "function" || typeof b.getSnapshotBeforeUpdate == "function") || typeof b.UNSAFE_componentWillReceiveProps != "function" && typeof b.componentWillReceiveProps != "function" || (A !== K || k !== R) && ky(o, b, p, R), Ii = !1, k = o.memoizedState, b.state = k, Zo(o, p, b, m);
                    var st = o.memoizedState;
                    A !== K || k !== st || Be.current || Ii ? (typeof W == "function" && (od(o, u, W, p), st = o.memoizedState), (L = Ii || Ly(o, u, L, p, k, st, R) || !1) ? (F || typeof b.UNSAFE_componentWillUpdate != "function" && typeof b.componentWillUpdate != "function" || (typeof b.componentWillUpdate == "function" && b.componentWillUpdate(p, st, R), typeof b.UNSAFE_componentWillUpdate == "function" && b.UNSAFE_componentWillUpdate(p, st, R)), typeof b.componentDidUpdate == "function" && (o.flags |= 4), typeof b.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof b.componentDidUpdate != "function" || A === s.memoizedProps && k === s.memoizedState || (o.flags |= 4), typeof b.getSnapshotBeforeUpdate != "function" || A === s.memoizedProps && k === s.memoizedState || (o.flags |= 1024), o.memoizedProps = p, o.memoizedState = st), b.props = p, b.state = st, b.context = R, p = L) : (typeof b.componentDidUpdate != "function" || A === s.memoizedProps && k === s.memoizedState || (o.flags |= 4), typeof b.getSnapshotBeforeUpdate != "function" || A === s.memoizedProps && k === s.memoizedState || (o.flags |= 1024), p = !1)
                }
                return wd(s, o, u, p, v, m)
            }

            function wd(s, o, u, p, m, v) {
                v0(s, o);
                var b = (128 & o.flags) != 0;
                if (!p && !b) return m && vy(o, u, !1), di(s, o, v);
                p = o.stateNode, $P.current = o;
                var A = b && typeof u.getDerivedStateFromError != "function" ? null : p.render();
                return o.flags |= 1, s !== null && b ? (o.child = Kn(o, s.child, null, v), o.child = Kn(o, null, A, v)) : Fe(s, o, A, v), o.memoizedState = p.state, m && vy(o, u, !0), o.child
            }

            function _0(s) {
                var o = s.stateNode;
                o.pendingContext ? gy(0, o.pendingContext, o.pendingContext !== o.context) : o.context && gy(0, o.context, !1), hd(s, o.containerInfo)
            }

            function b0(s, o, u, p, m) {
                return Yn(), td(m), o.flags |= 256, Fe(s, o, u, p), o.child
            }
            var oa, la, ol, ll, Sd = {
                dehydrated: null,
                treeContext: null,
                retryLane: 0
            };

            function Ad(s) {
                return {
                    baseLanes: s,
                    cachePool: null,
                    transitions: null
                }
            }

            function E0(s, o, u) {
                var p, m = o.pendingProps,
                    v = Qt.current,
                    b = !1,
                    A = (128 & o.flags) != 0;
                if ((p = A) || (p = (s === null || s.memoizedState !== null) && (2 & v) != 0), p ? (b = !0, o.flags &= -129) : s !== null && s.memoizedState === null || (v |= 1), Lt(Qt, 1 & v), s === null) return Jc(o), (s = o.memoizedState) !== null && (s = s.dehydrated) !== null ? (1 & o.mode ? kc(s) ? o.lanes = 8 : o.lanes = 1073741824 : o.lanes = 1, null) : (A = m.children, s = m.fallback, b ? (m = o.mode, b = o.child, A = {
                    mode: "hidden",
                    children: A
                }, !(1 & m) && b !== null ? (b.childLanes = 0, b.pendingProps = A) : b = Pl(A, m, 0, null), s = fn(s, m, u, null), b.return = o, s.return = o, b.sibling = s, o.child = b, o.child.memoizedState = Ad(u), o.memoizedState = Sd, s) : Pd(o, A));
                if ((v = s.memoizedState) !== null && (p = v.dehydrated) !== null) return function(L, F, K, k, W, st, yt) {
                    if (K) return 256 & F.flags ? (F.flags &= -257, hl(L, F, yt, k = bd(Error(a(422))))) : F.memoizedState !== null ? (F.child = L.child, F.flags |= 128, null) : (st = k.fallback, W = F.mode, k = Pl({
                        mode: "visible",
                        children: k.children
                    }, W, 0, null), (st = fn(st, W, yt, null)).flags |= 2, k.return = F, st.return = F, k.sibling = st, F.child = k, 1 & F.mode && Kn(F, L.child, null, yt), F.child.memoizedState = Ad(yt), F.memoizedState = Sd, st);
                    if (!(1 & F.mode)) return hl(L, F, yt, null);
                    if (kc(W)) return k = dP(W).digest, st = Error(a(419)), k = bd(st, k, void 0), hl(L, F, yt, k);
                    if (K = (yt & L.childLanes) != 0, ke || K) {
                        if ((k = ge) !== null) {
                            switch (yt & -yt) {
                                case 4:
                                    W = 2;
                                    break;
                                case 16:
                                    W = 8;
                                    break;
                                case 64:
                                case 128:
                                case 256:
                                case 512:
                                case 1024:
                                case 2048:
                                case 4096:
                                case 8192:
                                case 16384:
                                case 32768:
                                case 65536:
                                case 131072:
                                case 262144:
                                case 524288:
                                case 1048576:
                                case 2097152:
                                case 4194304:
                                case 8388608:
                                case 16777216:
                                case 33554432:
                                case 67108864:
                                    W = 32;
                                    break;
                                case 536870912:
                                    W = 268435456;
                                    break;
                                default:
                                    W = 0
                            }(W = W & (k.suspendedLanes | yt) ? 0 : W) !== 0 && W !== st.retryLane && (st.retryLane = W, Wr(L, W), ur(k, L, W, -1))
                        }
                        return $d(), hl(L, F, yt, k = bd(Error(a(421))))
                    }
                    return my(W) ? (F.flags |= 128, F.child = L.child, F = eC.bind(null, L), pP(W, F), null) : (L = st.treeContext, St && (ar = gP(W), Xe = F, Ht = !0, Ar = null, Js = !1, L !== null && (nr[sr++] = jr, nr[sr++] = ui, nr[sr++] = on, jr = L.id, ui = L.overflow, on = F)), F = Pd(F, k.children), F.flags |= 4096, F)
                }(s, o, A, m, p, v, u);
                if (b) {
                    b = m.fallback, A = o.mode, p = (v = s.child).sibling;
                    var R = {
                        mode: "hidden",
                        children: m.children
                    };
                    return !(1 & A) && o.child !== v ? ((m = o.child).childLanes = 0, m.pendingProps = R, o.deletions = null) : (m = Bi(v, R)).subtreeFlags = 14680064 & v.subtreeFlags, p !== null ? b = Bi(p, b) : (b = fn(b, A, u, null)).flags |= 2, b.return = o, m.return = o, m.sibling = b, o.child = m, m = b, b = o.child, A = (A = s.child.memoizedState) === null ? Ad(u) : {
                        baseLanes: A.baseLanes | u,
                        cachePool: null,
                        transitions: A.transitions
                    }, b.memoizedState = A, b.childLanes = s.childLanes & ~u, o.memoizedState = Sd, m
                }
                return s = (b = s.child).sibling, m = Bi(b, {
                    mode: "visible",
                    children: m.children
                }), !(1 & o.mode) && (m.lanes = u), m.return = o, m.sibling = null, s !== null && ((u = o.deletions) === null ? (o.deletions = [s], o.flags |= 16) : u.push(s)), o.child = m, o.memoizedState = null, m
            }

            function Pd(s, o) {
                return (o = Pl({
                    mode: "visible",
                    children: o
                }, s.mode, 0, null)).return = s, s.child = o
            }

            function hl(s, o, u, p) {
                return p !== null && td(p), Kn(o, s.child, null, u), (s = Pd(o, o.pendingProps.children)).flags |= 2, o.memoizedState = null, s
            }

            function T0(s, o, u) {
                s.lanes |= o;
                var p = s.alternate;
                p !== null && (p.lanes |= o), nd(s.return, o, u)
            }

            function Cd(s, o, u, p, m) {
                var v = s.memoizedState;
                v === null ? s.memoizedState = {
                    isBackwards: o,
                    rendering: null,
                    renderingStartTime: 0,
                    last: p,
                    tail: u,
                    tailMode: m
                } : (v.isBackwards = o, v.rendering = null, v.renderingStartTime = 0, v.last = p, v.tail = u, v.tailMode = m)
            }

            function w0(s, o, u) {
                var p = o.pendingProps,
                    m = p.revealOrder,
                    v = p.tail;
                if (Fe(s, o, p.children, u), (2 & (p = Qt.current)) != 0) p = 1 & p | 2, o.flags |= 128;
                else {
                    if (s !== null && 128 & s.flags) t: for (s = o.child; s !== null;) {
                        if (s.tag === 13) s.memoizedState !== null && T0(s, u, o);
                        else if (s.tag === 19) T0(s, u, o);
                        else if (s.child !== null) {
                            s.child.return = s, s = s.child;
                            continue
                        }
                        if (s === o) break t;
                        for (; s.sibling === null;) {
                            if (s.return === null || s.return === o) break t;
                            s = s.return
                        }
                        s.sibling.return = s.return, s = s.sibling
                    }
                    p &= 1
                }
                if (Lt(Qt, p), (1 & o.mode) == 0) o.memoizedState = null;
                else switch (m) {
                    case "forwards":
                        for (u = o.child, m = null; u !== null;)(s = u.alternate) !== null && el(s) === null && (m = u), u = u.sibling;
                        (u = m) === null ? (m = o.child, o.child = null) : (m = u.sibling, u.sibling = null), Cd(o, !1, m, u, v);
                        break;
                    case "backwards":
                        for (u = null, m = o.child, o.child = null; m !== null;) {
                            if ((s = m.alternate) !== null && el(s) === null) {
                                o.child = m;
                                break
                            }
                            s = m.sibling, m.sibling = u, u = m, m = s
                        }
                        Cd(o, !0, u, null, v);
                        break;
                    case "together":
                        Cd(o, !1, null, null, void 0);
                        break;
                    default:
                        o.memoizedState = null
                }
                return o.child
            }

            function ul(s, o) {
                !(1 & o.mode) && s !== null && (s.alternate = null, o.alternate = null, o.flags |= 2)
            }

            function di(s, o, u) {
                if (s !== null && (o.dependencies = s.dependencies), cn |= o.lanes, (u & o.childLanes) == 0) return null;
                if (s !== null && o.child !== s.child) throw Error(a(153));
                if (o.child !== null) {
                    for (u = Bi(s = o.child, s.pendingProps), o.child = u, u.return = o; s.sibling !== null;) s = s.sibling, (u = u.sibling = Bi(s, s.pendingProps)).return = o;
                    u.sibling = null
                }
                return o.child
            }

            function Vr(s) {
                s.flags |= 4
            }

            function S0(s, o) {
                if (s !== null && s.child === o.child) return !0;
                if (16 & o.flags) return !1;
                for (s = o.child; s !== null;) {
                    if (12854 & s.flags || 12854 & s.subtreeFlags) return !1;
                    s = s.sibling
                }
                return !0
            }
            if (xt) oa = function(s, o) {
                for (var u = o.child; u !== null;) {
                    if (u.tag === 5 || u.tag === 6) ht(s, u.stateNode);
                    else if (u.tag !== 4 && u.child !== null) {
                        u.child.return = u, u = u.child;
                        continue
                    }
                    if (u === o) break;
                    for (; u.sibling === null;) {
                        if (u.return === null || u.return === o) return;
                        u = u.return
                    }
                    u.sibling.return = u.return, u = u.sibling
                }
            }, la = function() {}, ol = function(s, o, u, p, m) {
                if ((s = s.memoizedProps) !== p) {
                    var v = o.stateNode,
                        b = Xr(lr.current);
                    u = vt(v, u, s, p, m, b), (o.updateQueue = u) && Vr(o)
                }
            }, ll = function(s, o, u, p) {
                u !== p && Vr(o)
            };
            else if (kt) {
                oa = function(s, o, u, p) {
                    for (var m = o.child; m !== null;) {
                        if (m.tag === 5) {
                            var v = m.stateNode;
                            u && p && (v = py(v, m.type, m.memoizedProps, m)), ht(s, v)
                        } else if (m.tag === 6) v = m.stateNode, u && p && (v = fy(v, m.memoizedProps, m)), ht(s, v);
                        else if (m.tag !== 4) {
                            if (m.tag === 22 && m.memoizedState !== null)(v = m.child) !== null && (v.return = m), oa(s, m, !0, !0);
                            else if (m.child !== null) {
                                m.child.return = m, m = m.child;
                                continue
                            }
                        }
                        if (m === o) break;
                        for (; m.sibling === null;) {
                            if (m.return === null || m.return === o) return;
                            m = m.return
                        }
                        m.sibling.return = m.return, m = m.sibling
                    }
                };
                var A0 = function(s, o, u, p) {
                    for (var m = o.child; m !== null;) {
                        if (m.tag === 5) {
                            var v = m.stateNode;
                            u && p && (v = py(v, m.type, m.memoizedProps, m)), dy(s, v)
                        } else if (m.tag === 6) v = m.stateNode, u && p && (v = fy(v, m.memoizedProps, m)), dy(s, v);
                        else if (m.tag !== 4) {
                            if (m.tag === 22 && m.memoizedState !== null)(v = m.child) !== null && (v.return = m), A0(s, m, !0, !0);
                            else if (m.child !== null) {
                                m.child.return = m, m = m.child;
                                continue
                            }
                        }
                        if (m === o) break;
                        for (; m.sibling === null;) {
                            if (m.return === null || m.return === o) return;
                            m = m.return
                        }
                        m.sibling.return = m.return, m = m.sibling
                    }
                };
                la = function(s, o) {
                    var u = o.stateNode;
                    if (!S0(s, o)) {
                        s = u.containerInfo;
                        var p = cy(s);
                        A0(p, o, !1, !1), u.pendingChildren = p, Vr(o), lP(s, p)
                    }
                }, ol = function(s, o, u, p, m) {
                    var v = s.stateNode,
                        b = s.memoizedProps;
                    if ((s = S0(s, o)) && b === p) o.stateNode = v;
                    else {
                        var A = o.stateNode,
                            R = Xr(lr.current),
                            L = null;
                        b !== p && (L = vt(A, u, b, p, m, R)), s && L === null ? o.stateNode = v : (v = oP(v, L, u, b, p, o, s, A), _t(v, u, p, m, R) && Vr(o), o.stateNode = v, s ? Vr(o) : oa(v, o, !1, !1))
                    }
                }, ll = function(s, o, u, p) {
                    u !== p ? (s = Xr(Zn.current), u = Xr(lr.current), o.stateNode = Ct(p, s, u, o), Vr(o)) : o.stateNode = s.stateNode
                }
            } else la = function() {}, ol = function() {}, ll = function() {};

            function ha(s, o) {
                if (!Ht) switch (s.tailMode) {
                    case "hidden":
                        o = s.tail;
                        for (var u = null; o !== null;) o.alternate !== null && (u = o), o = o.sibling;
                        u === null ? s.tail = null : u.sibling = null;
                        break;
                    case "collapsed":
                        u = s.tail;
                        for (var p = null; u !== null;) u.alternate !== null && (p = u), u = u.sibling;
                        p === null ? o || s.tail === null ? s.tail = null : s.tail.sibling = null : p.sibling = null
                }
            }

            function De(s) {
                var o = s.alternate !== null && s.alternate.child === s.child,
                    u = 0,
                    p = 0;
                if (o)
                    for (var m = s.child; m !== null;) u |= m.lanes | m.childLanes, p |= 14680064 & m.subtreeFlags, p |= 14680064 & m.flags, m.return = s, m = m.sibling;
                else
                    for (m = s.child; m !== null;) u |= m.lanes | m.childLanes, p |= m.subtreeFlags, p |= m.flags, m.return = s, m = m.sibling;
                return s.subtreeFlags |= p, s.childLanes = u, o
            }

            function VP(s, o, u) {
                var p = o.pendingProps;
                switch (Kc(o), o.tag) {
                    case 2:
                    case 16:
                    case 15:
                    case 0:
                    case 11:
                    case 7:
                    case 8:
                    case 12:
                    case 9:
                    case 14:
                        return De(o), null;
                    case 1:
                    case 17:
                        return We(o.type) && zc(), De(o), null;
                    case 3:
                        return u = o.stateNode, Jn(), zt(Be), zt(Ae), dd(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), s !== null && s.child !== null || (Vo(o) ? Vr(o) : s === null || s.memoizedState.isDehydrated && !(256 & o.flags) || (o.flags |= 1024, Ar !== null && (Wd(Ar), Ar = null))), la(s, o), De(o), null;
                    case 5:
                        ud(o), u = Xr(Zn.current);
                        var m = o.type;
                        if (s !== null && o.stateNode != null) ol(s, o, m, p, u), s.ref !== o.ref && (o.flags |= 512, o.flags |= 2097152);
                        else {
                            if (!p) {
                                if (o.stateNode === null) throw Error(a(166));
                                return De(o), null
                            }
                            if (s = Xr(lr.current), Vo(o)) {
                                if (!St) throw Error(a(175));
                                s = yP(o.stateNode, o.type, o.memoizedProps, u, s, o, !Js), o.updateQueue = s, s !== null && Vr(o)
                            } else {
                                var v = tt(m, p, u, s, o);
                                oa(v, o, !1, !1), o.stateNode = v, _t(v, m, p, u, s) && Vr(o)
                            }
                            o.ref !== null && (o.flags |= 512, o.flags |= 2097152)
                        }
                        return De(o), null;
                    case 6:
                        if (s && o.stateNode != null) ll(s, o, s.memoizedProps, p);
                        else {
                            if (typeof p != "string" && o.stateNode === null) throw Error(a(166));
                            if (s = Xr(Zn.current), u = Xr(lr.current), Vo(o)) {
                                if (!St) throw Error(a(176));
                                if (s = o.stateNode, u = o.memoizedProps, (p = vP(s, u, o, !Js)) && (m = Xe) !== null) switch (m.tag) {
                                    case 3:
                                        AP(m.stateNode.containerInfo, s, u, (1 & m.mode) != 0);
                                        break;
                                    case 5:
                                        PP(m.type, m.memoizedProps, m.stateNode, s, u, (1 & m.mode) != 0)
                                }
                                p && Vr(o)
                            } else o.stateNode = Ct(p, s, u, o)
                        }
                        return De(o), null;
                    case 13:
                        if (zt(Qt), p = o.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                            if (Ht && ar !== null && 1 & o.mode && !(128 & o.flags)) Cy(), Yn(), o.flags |= 98560, m = !1;
                            else if (m = Vo(o), p !== null && p.dehydrated !== null) {
                                if (s === null) {
                                    if (!m) throw Error(a(318));
                                    if (!St) throw Error(a(344));
                                    if (!(m = (m = o.memoizedState) !== null ? m.dehydrated : null)) throw Error(a(317));
                                    xP(m, o)
                                } else Yn(), !(128 & o.flags) && (o.memoizedState = null), o.flags |= 4;
                                De(o), m = !1
                            } else Ar !== null && (Wd(Ar), Ar = null), m = !0;
                            if (!m) return 65536 & o.flags ? o : null
                        }
                        return 128 & o.flags ? (o.lanes = u, o) : ((u = p !== null) != (s !== null && s.memoizedState !== null) && u && (o.child.flags |= 8192, 1 & o.mode && (s === null || 1 & Qt.current ? se === 0 && (se = 3) : $d())), o.updateQueue !== null && (o.flags |= 4), De(o), null);
                    case 4:
                        return Jn(), la(s, o), s === null && ir(o.stateNode.containerInfo), De(o), null;
                    case 10:
                        return id(o.type._context), De(o), null;
                    case 19:
                        if (zt(Qt), (m = o.memoizedState) === null) return De(o), null;
                        if (p = (128 & o.flags) != 0, (v = m.rendering) === null)
                            if (p) ha(m, !1);
                            else {
                                if (se !== 0 || s !== null && 128 & s.flags)
                                    for (s = o.child; s !== null;) {
                                        if ((v = el(s)) !== null) {
                                            for (o.flags |= 128, ha(m, !1), (s = v.updateQueue) !== null && (o.updateQueue = s, o.flags |= 4), o.subtreeFlags = 0, s = u, u = o.child; u !== null;) m = s, (p = u).flags &= 14680066, (v = p.alternate) === null ? (p.childLanes = 0, p.lanes = m, p.child = null, p.subtreeFlags = 0, p.memoizedProps = null, p.memoizedState = null, p.updateQueue = null, p.dependencies = null, p.stateNode = null) : (p.childLanes = v.childLanes, p.lanes = v.lanes, p.child = v.child, p.subtreeFlags = 0, p.deletions = null, p.memoizedProps = v.memoizedProps, p.memoizedState = v.memoizedState, p.updateQueue = v.updateQueue, p.type = v.type, m = v.dependencies, p.dependencies = m === null ? null : {
                                                lanes: m.lanes,
                                                firstContext: m.firstContext
                                            }), u = u.sibling;
                                            return Lt(Qt, 1 & Qt.current | 2), o.child
                                        }
                                        s = s.sibling
                                    }
                                m.tail !== null && pe() > Gd && (o.flags |= 128, p = !0, ha(m, !1), o.lanes = 4194304)
                            }
                        else {
                            if (!p)
                                if ((s = el(v)) !== null) {
                                    if (o.flags |= 128, p = !0, (s = s.updateQueue) !== null && (o.updateQueue = s, o.flags |= 4), ha(m, !0), m.tail === null && m.tailMode === "hidden" && !v.alternate && !Ht) return De(o), null
                                } else 2 * pe() - m.renderingStartTime > Gd && u !== 1073741824 && (o.flags |= 128, p = !0, ha(m, !1), o.lanes = 4194304);
                            m.isBackwards ? (v.sibling = o.child, o.child = v) : ((s = m.last) !== null ? s.sibling = v : o.child = v, m.last = v)
                        }
                        return m.tail !== null ? (o = m.tail, m.rendering = o, m.tail = o.sibling, m.renderingStartTime = pe(), o.sibling = null, s = Qt.current, Lt(Qt, p ? 1 & s | 2 : 1 & s), o) : (De(o), null);
                    case 22:
                    case 23:
                        return Xd(), u = o.memoizedState !== null, s !== null && s.memoizedState !== null !== u && (o.flags |= 8192), u && 1 & o.mode ? 1073741824 & $e && (De(o), xt && 6 & o.subtreeFlags && (o.flags |= 8192)) : De(o), null;
                    case 24:
                    case 25:
                        return null
                }
                throw Error(a(156, o.tag))
            }

            function YP(s, o) {
                switch (Kc(o), o.tag) {
                    case 1:
                        return We(o.type) && zc(), 65536 & (s = o.flags) ? (o.flags = -65537 & s | 128, o) : null;
                    case 3:
                        return Jn(), zt(Be), zt(Ae), dd(), 65536 & (s = o.flags) && !(128 & s) ? (o.flags = -65537 & s | 128, o) : null;
                    case 5:
                        return ud(o), null;
                    case 13:
                        if (zt(Qt), (s = o.memoizedState) !== null && s.dehydrated !== null) {
                            if (o.alternate === null) throw Error(a(340));
                            Yn()
                        }
                        return 65536 & (s = o.flags) ? (o.flags = -65537 & s | 128, o) : null;
                    case 19:
                        return zt(Qt), null;
                    case 4:
                        return Jn(), null;
                    case 10:
                        return id(o.type._context), null;
                    case 22:
                    case 23:
                        return Xd(), null;
                    default:
                        return null
                }
            }
            var cl = !1,
                Ce = !1,
                qP = typeof WeakSet == "function" ? WeakSet : Set,
                it = null;

            function es(s, o) {
                var u = s.ref;
                if (u !== null)
                    if (typeof u == "function") try {
                        u(null)
                    } catch (p) {
                        jt(s, o, p)
                    } else u.current = null
            }

            function P0(s, o, u) {
                try {
                    u()
                } catch (p) {
                    jt(s, o, p)
                }
            }
            var C0 = !1;

            function ua(s, o, u) {
                var p = o.updateQueue;
                if ((p = p !== null ? p.lastEffect : null) !== null) {
                    var m = p = p.next;
                    do {
                        if ((m.tag & s) === s) {
                            var v = m.destroy;
                            m.destroy = void 0, v !== void 0 && P0(o, u, v)
                        }
                        m = m.next
                    } while (m !== p)
                }
            }

            function dl(s, o) {
                if ((o = (o = o.updateQueue) !== null ? o.lastEffect : null) !== null) {
                    var u = o = o.next;
                    do {
                        if ((u.tag & s) === s) {
                            var p = u.create;
                            u.destroy = p()
                        }
                        u = u.next
                    } while (u !== o)
                }
            }

            function Id(s) {
                var o = s.ref;
                if (o !== null) {
                    var u = s.stateNode;
                    s.tag === 5 ? s = ft(u) : s = u, typeof o == "function" ? o(s) : o.current = s
                }
            }

            function I0(s) {
                var o = s.alternate;
                o !== null && (s.alternate = null, I0(o)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (o = s.stateNode) !== null && Lc(o), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null
            }

            function R0(s) {
                return s.tag === 5 || s.tag === 3 || s.tag === 4
            }

            function M0(s) {
                t: for (;;) {
                    for (; s.sibling === null;) {
                        if (s.return === null || R0(s.return)) return null;
                        s = s.return
                    }
                    for (s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18;) {
                        if (2 & s.flags || s.child === null || s.tag === 4) continue t;
                        s.child.return = s, s = s.child
                    }
                    if (!(2 & s.flags)) return s.stateNode
                }
            }

            function Rd(s, o, u) {
                var p = s.tag;
                if (p === 5 || p === 6) s = s.stateNode, o ? JA(u, s, o) : YA(u, s);
                else if (p !== 4 && (s = s.child) !== null)
                    for (Rd(s, o, u), s = s.sibling; s !== null;) Rd(s, o, u), s = s.sibling
            }

            function Md(s, o, u) {
                var p = s.tag;
                if (p === 5 || p === 6) s = s.stateNode, o ? ZA(u, s, o) : VA(u, s);
                else if (p !== 4 && (s = s.child) !== null)
                    for (Md(s, o, u), s = s.sibling; s !== null;) Md(s, o, u), s = s.sibling
            }
            var Ne = null,
                Yr = !1;

            function qr(s, o, u) {
                for (u = u.child; u !== null;) Dd(s, o, u), u = u.sibling
            }

            function Dd(s, o, u) {
                if (zr && typeof zr.onCommitFiberUnmount == "function") try {
                    zr.onCommitFiberUnmount(jo, u)
                } catch (A) {}
                switch (u.tag) {
                    case 5:
                        Ce || es(u, o);
                    case 6:
                        if (xt) {
                            var p = Ne,
                                m = Yr;
                            Ne = null, qr(s, o, u), Yr = m, (Ne = p) !== null && (Yr ? eP(Ne, u.stateNode) : tP(Ne, u.stateNode))
                        } else qr(s, o, u);
                        break;
                    case 18:
                        xt && Ne !== null && (Yr ? wP(Ne, u.stateNode) : TP(Ne, u.stateNode));
                        break;
                    case 4:
                        xt ? (p = Ne, m = Yr, Ne = u.stateNode.containerInfo, Yr = !0, qr(s, o, u), Ne = p, Yr = m) : (kt && (p = u.stateNode.containerInfo, m = cy(p), Bc(p, m)), qr(s, o, u));
                        break;
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (!Ce && (p = u.updateQueue) !== null && (p = p.lastEffect) !== null) {
                            m = p = p.next;
                            do {
                                var v = m,
                                    b = v.destroy;
                                v = v.tag, b !== void 0 && (2 & v || 4 & v) && P0(u, o, b), m = m.next
                            } while (m !== p)
                        }
                        qr(s, o, u);
                        break;
                    case 1:
                        if (!Ce && (es(u, o), typeof(p = u.stateNode).componentWillUnmount == "function")) try {
                            p.props = u.memoizedProps, p.state = u.memoizedState, p.componentWillUnmount()
                        } catch (A) {
                            jt(u, o, A)
                        }
                        qr(s, o, u);
                        break;
                    case 21:
                        qr(s, o, u);
                        break;
                    case 22:
                        1 & u.mode ? (Ce = (p = Ce) || u.memoizedState !== null, qr(s, o, u), Ce = p) : qr(s, o, u);
                        break;
                    default:
                        qr(s, o, u)
                }
            }

            function D0(s) {
                var o = s.updateQueue;
                if (o !== null) {
                    s.updateQueue = null;
                    var u = s.stateNode;
                    u === null && (u = s.stateNode = new qP), o.forEach(function(p) {
                        var m = rC.bind(null, s, p);
                        u.has(p) || (u.add(p), p.then(m, m))
                    })
                }
            }

            function Cr(s, o) {
                var u = o.deletions;
                if (u !== null)
                    for (var p = 0; p < u.length; p++) {
                        var m = u[p];
                        try {
                            var v = s,
                                b = o;
                            if (xt) {
                                var A = b;
                                t: for (; A !== null;) {
                                    switch (A.tag) {
                                        case 5:
                                            Ne = A.stateNode, Yr = !1;
                                            break t;
                                        case 3:
                                        case 4:
                                            Ne = A.stateNode.containerInfo, Yr = !0;
                                            break t
                                    }
                                    A = A.return
                                }
                                if (Ne === null) throw Error(a(160));
                                Dd(v, b, m), Ne = null, Yr = !1
                            } else Dd(v, b, m);
                            var R = m.alternate;
                            R !== null && (R.return = null), m.return = null
                        } catch (L) {
                            jt(m, o, L)
                        }
                    }
                if (12854 & o.subtreeFlags)
                    for (o = o.child; o !== null;) N0(o, s), o = o.sibling
            }

            function N0(s, o) {
                var u = s.alternate,
                    p = s.flags;
                switch (s.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        if (Cr(o, s), Qr(s), 4 & p) {
                            try {
                                ua(3, s, s.return), dl(3, s)
                            } catch (k) {
                                jt(s, s.return, k)
                            }
                            try {
                                ua(5, s, s.return)
                            } catch (k) {
                                jt(s, s.return, k)
                            }
                        }
                        break;
                    case 1:
                        Cr(o, s), Qr(s), 512 & p && u !== null && es(u, u.return);
                        break;
                    case 5:
                        if (Cr(o, s), Qr(s), 512 & p && u !== null && es(u, u.return), xt) {
                            if (32 & s.flags) {
                                var m = s.stateNode;
                                try {
                                    uy(m)
                                } catch (k) {
                                    jt(s, s.return, k)
                                }
                            }
                            if (4 & p && (m = s.stateNode) != null) {
                                var v = s.memoizedProps;
                                if (u = u !== null ? u.memoizedProps : v, p = s.type, o = s.updateQueue, s.updateQueue = null, o !== null) try {
                                    KA(m, o, p, u, v, s)
                                } catch (k) {
                                    jt(s, s.return, k)
                                }
                            }
                        }
                        break;
                    case 6:
                        if (Cr(o, s), Qr(s), 4 & p && xt) {
                            if (s.stateNode === null) throw Error(a(162));
                            m = s.stateNode, v = s.memoizedProps, u = u !== null ? u.memoizedProps : v;
                            try {
                                qA(m, u, v)
                            } catch (k) {
                                jt(s, s.return, k)
                            }
                        }
                        break;
                    case 3:
                        if (Cr(o, s), Qr(s), 4 & p) {
                            if (xt && St && u !== null && u.memoizedState.isDehydrated) try {
                                bP(o.containerInfo)
                            } catch (k) {
                                jt(s, s.return, k)
                            }
                            if (kt) {
                                m = o.containerInfo, v = o.pendingChildren;
                                try {
                                    Bc(m, v)
                                } catch (k) {
                                    jt(s, s.return, k)
                                }
                            }
                        }
                        break;
                    case 4:
                        if (Cr(o, s), Qr(s), 4 & p && kt) {
                            m = (v = s.stateNode).containerInfo, v = v.pendingChildren;
                            try {
                                Bc(m, v)
                            } catch (k) {
                                jt(s, s.return, k)
                            }
                        }
                        break;
                    case 13:
                        Cr(o, s), Qr(s), 8192 & (m = s.child).flags && (v = m.memoizedState !== null, m.stateNode.isHidden = v, !v || m.alternate !== null && m.alternate.memoizedState !== null || (Ud = pe())), 4 & p && D0(s);
                        break;
                    case 22:
                        var b = u !== null && u.memoizedState !== null;
                        if (1 & s.mode ? (Ce = (u = Ce) || b, Cr(o, s), Ce = u) : Cr(o, s), Qr(s), 8192 & p) {
                            if (u = s.memoizedState !== null, (s.stateNode.isHidden = u) && !b && (1 & s.mode) != 0)
                                for (it = s, p = s.child; p !== null;) {
                                    for (o = it = p; it !== null;) {
                                        var A = (b = it).child;
                                        switch (b.tag) {
                                            case 0:
                                            case 11:
                                            case 14:
                                            case 15:
                                                ua(4, b, b.return);
                                                break;
                                            case 1:
                                                es(b, b.return);
                                                var R = b.stateNode;
                                                if (typeof R.componentWillUnmount == "function") {
                                                    var L = b,
                                                        F = b.return;
                                                    try {
                                                        var K = L;
                                                        R.props = K.memoizedProps, R.state = K.memoizedState, R.componentWillUnmount()
                                                    } catch (k) {
                                                        jt(L, F, k)
                                                    }
                                                }
                                                break;
                                            case 5:
                                                es(b, b.return);
                                                break;
                                            case 22:
                                                if (b.memoizedState !== null) {
                                                    B0(o);
                                                    continue
                                                }
                                        }
                                        A !== null ? (A.return = b, it = A) : B0(o)
                                    }
                                    p = p.sibling
                                }
                            if (xt) {
                                t: if (p = null, xt)
                                    for (o = s;;) {
                                        if (o.tag === 5) {
                                            if (p === null) {
                                                p = o;
                                                try {
                                                    m = o.stateNode, u ? rP(m) : nP(o.stateNode, o.memoizedProps)
                                                } catch (k) {
                                                    jt(s, s.return, k)
                                                }
                                            }
                                        } else if (o.tag === 6) {
                                            if (p === null) try {
                                                v = o.stateNode, u ? iP(v) : sP(v, o.memoizedProps)
                                            } catch (k) {
                                                jt(s, s.return, k)
                                            }
                                        } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === s) && o.child !== null) {
                                            o.child.return = o, o = o.child;
                                            continue
                                        }
                                        if (o === s) break t;
                                        for (; o.sibling === null;) {
                                            if (o.return === null || o.return === s) break t;
                                            p === o && (p = null), o = o.return
                                        }
                                        p === o && (p = null), o.sibling.return = o.return, o = o.sibling
                                    }
                            }
                        }
                        break;
                    case 19:
                        Cr(o, s), Qr(s), 4 & p && D0(s);
                        break;
                    case 21:
                        break;
                    default:
                        Cr(o, s), Qr(s)
                }
            }

            function Qr(s) {
                var o = s.flags;
                if (2 & o) {
                    try {
                        if (xt) {
                            t: {
                                for (var u = s.return; u !== null;) {
                                    if (R0(u)) {
                                        var p = u;
                                        break t
                                    }
                                    u = u.return
                                }
                                throw Error(a(160))
                            }
                            switch (p.tag) {
                                case 5:
                                    var m = p.stateNode;
                                    32 & p.flags && (uy(m), p.flags &= -33), Md(s, M0(s), m);
                                    break;
                                case 3:
                                case 4:
                                    var v = p.stateNode.containerInfo;
                                    Rd(s, M0(s), v);
                                    break;
                                default:
                                    throw Error(a(161))
                            }
                        }
                    } catch (b) {
                        jt(s, s.return, b)
                    }
                    s.flags &= -3
                }
                4096 & o && (s.flags &= -4097)
            }

            function QP(s, o, u) {
                it = s, O0(s)
            }

            function O0(s, o, u) {
                for (var p = (1 & s.mode) != 0; it !== null;) {
                    var m = it,
                        v = m.child;
                    if (m.tag === 22 && p) {
                        var b = m.memoizedState !== null || cl;
                        if (!b) {
                            var A = m.alternate,
                                R = A !== null && A.memoizedState !== null || Ce;
                            A = cl;
                            var L = Ce;
                            if (cl = b, (Ce = R) && !L)
                                for (it = m; it !== null;) R = (b = it).child, b.tag === 22 && b.memoizedState !== null ? k0(m) : R !== null ? (R.return = b, it = R) : k0(m);
                            for (; v !== null;) it = v, O0(v), v = v.sibling;
                            it = m, cl = A, Ce = L
                        }
                        L0(s)
                    } else 8772 & m.subtreeFlags && v !== null ? (v.return = m, it = v) : L0(s)
                }
            }

            function L0(s) {
                for (; it !== null;) {
                    var o = it;
                    if (8772 & o.flags) {
                        var u = o.alternate;
                        try {
                            if (8772 & o.flags) switch (o.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Ce || dl(5, o);
                                    break;
                                case 1:
                                    var p = o.stateNode;
                                    if (4 & o.flags && !Ce)
                                        if (u === null) p.componentDidMount();
                                        else {
                                            var m = o.elementType === o.type ? u.memoizedProps : Pr(o.type, u.memoizedProps);
                                            p.componentDidUpdate(m, u.memoizedState, p.__reactInternalSnapshotBeforeUpdate)
                                        }
                                    var v = o.updateQueue;
                                    v !== null && Ny(o, v, p);
                                    break;
                                case 3:
                                    var b = o.updateQueue;
                                    if (b !== null) {
                                        if (u = null, o.child !== null) switch (o.child.tag) {
                                            case 5:
                                                u = ft(o.child.stateNode);
                                                break;
                                            case 1:
                                                u = o.child.stateNode
                                        }
                                        Ny(o, b, u)
                                    }
                                    break;
                                case 5:
                                    var A = o.stateNode;
                                    u === null && 4 & o.flags && QA(A, o.type, o.memoizedProps, o);
                                    break;
                                case 6:
                                case 4:
                                case 12:
                                case 19:
                                case 17:
                                case 21:
                                case 22:
                                case 23:
                                case 25:
                                    break;
                                case 13:
                                    if (St && o.memoizedState === null) {
                                        var R = o.alternate;
                                        if (R !== null) {
                                            var L = R.memoizedState;
                                            if (L !== null) {
                                                var F = L.dehydrated;
                                                F !== null && EP(F)
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    throw Error(a(163))
                            }
                            Ce || 512 & o.flags && Id(o)
                        } catch (K) {
                            jt(o, o.return, K)
                        }
                    }
                    if (o === s) {
                        it = null;
                        break
                    }
                    if ((u = o.sibling) !== null) {
                        u.return = o.return, it = u;
                        break
                    }
                    it = o.return
                }
            }

            function B0(s) {
                for (; it !== null;) {
                    var o = it;
                    if (o === s) {
                        it = null;
                        break
                    }
                    var u = o.sibling;
                    if (u !== null) {
                        u.return = o.return, it = u;
                        break
                    }
                    it = o.return
                }
            }

            function k0(s) {
                for (; it !== null;) {
                    var o = it;
                    try {
                        switch (o.tag) {
                            case 0:
                            case 11:
                            case 15:
                                var u = o.return;
                                try {
                                    dl(4, o)
                                } catch (R) {
                                    jt(o, u, R)
                                }
                                break;
                            case 1:
                                var p = o.stateNode;
                                if (typeof p.componentDidMount == "function") {
                                    var m = o.return;
                                    try {
                                        p.componentDidMount()
                                    } catch (R) {
                                        jt(o, m, R)
                                    }
                                }
                                var v = o.return;
                                try {
                                    Id(o)
                                } catch (R) {
                                    jt(o, v, R)
                                }
                                break;
                            case 5:
                                var b = o.return;
                                try {
                                    Id(o)
                                } catch (R) {
                                    jt(o, b, R)
                                }
                        }
                    } catch (R) {
                        jt(o, o.return, R)
                    }
                    if (o === s) {
                        it = null;
                        break
                    }
                    var A = o.sibling;
                    if (A !== null) {
                        A.return = o.return, it = A;
                        break
                    }
                    it = o.return
                }
            }
            var pl = 0,
                fl = 1,
                ml = 2,
                gl = 3,
                yl = 4;
            if (typeof Symbol == "function" && Symbol.for) {
                var ca = Symbol.for;
                pl = ca("selector.component"), fl = ca("selector.has_pseudo_class"), ml = ca("selector.role"), gl = ca("selector.test_id"), yl = ca("selector.text")
            }

            function Nd(s) {
                var o = rr(s);
                if (o != null) {
                    if (typeof o.memoizedProps["data-testname"] != "string") throw Error(a(364));
                    return o
                }
                if ((s = zA(s)) === null) throw Error(a(362));
                return s.stateNode.current
            }

            function Od(s, o) {
                switch (o.$$typeof) {
                    case pl:
                        if (s.type === o.value) return !0;
                        break;
                    case fl:
                        t: {
                            o = o.value,
                            s = [s, 0];
                            for (var u = 0; u < s.length;) {
                                var p = s[u++],
                                    m = s[u++],
                                    v = o[m];
                                if (p.tag !== 5 || !qs(p)) {
                                    for (; v != null && Od(p, v);) v = o[++m];
                                    if (m === o.length) {
                                        o = !0;
                                        break t
                                    }
                                    for (p = p.child; p !== null;) s.push(p, m), p = p.sibling
                                }
                            }
                            o = !1
                        }
                        return o;
                    case ml:
                        if (s.tag === 5 && WA(s.stateNode, o.value)) return !0;
                        break;
                    case yl:
                        if ((s.tag === 5 || s.tag === 6) && (s = jA(s)) !== null && 0 <= s.indexOf(o.value)) return !0;
                        break;
                    case gl:
                        if (s.tag === 5 && typeof(s = s.memoizedProps["data-testname"]) == "string" && s.toLowerCase() === o.value.toLowerCase()) return !0;
                        break;
                    default:
                        throw Error(a(365))
                }
                return !1
            }

            function Ld(s) {
                switch (s.$$typeof) {
                    case pl:
                        return "<" + (X(s.value) || "Unknown") + ">";
                    case fl:
                        return ":has(" + (Ld(s) || "") + ")";
                    case ml:
                        return '[role="' + s.value + '"]';
                    case yl:
                        return '"' + s.value + '"';
                    case gl:
                        return '[data-testname="' + s.value + '"]';
                    default:
                        throw Error(a(365))
                }
            }

            function F0(s, o) {
                var u = [];
                s = [s, 0];
                for (var p = 0; p < s.length;) {
                    var m = s[p++],
                        v = s[p++],
                        b = o[v];
                    if (m.tag !== 5 || !qs(m)) {
                        for (; b != null && Od(m, b);) b = o[++v];
                        if (v === o.length) u.push(m);
                        else
                            for (m = m.child; m !== null;) s.push(m, v), m = m.sibling
                    }
                }
                return u
            }

            function Bd(s, o) {
                if (!Ys) throw Error(a(363));
                s = F0(s = Nd(s), o), o = [], s = Array.from(s);
                for (var u = 0; u < s.length;) {
                    var p = s[u++];
                    if (p.tag === 5) qs(p) || o.push(p.stateNode);
                    else
                        for (p = p.child; p !== null;) s.push(p), p = p.sibling
                }
                return o
            }
            var KP = Math.ceil,
                vl = l.ReactCurrentDispatcher,
                kd = l.ReactCurrentOwner,
                te = l.ReactCurrentBatchConfig,
                wt = 0,
                ge = null,
                ne = null,
                _e = 0,
                $e = 0,
                rs = Pi(0),
                se = 0,
                da = null,
                cn = 0,
                xl = 0,
                Fd = 0,
                pa = null,
                Ve = null,
                Ud = 0,
                Gd = 1 / 0,
                Mi = null;

            function is() {
                Gd = pe() + 500
            }
            var U0, _l = !1,
                zd = null,
                Di = null,
                bl = !1,
                Ni = null,
                El = 0,
                fa = 0,
                Hd = null,
                Tl = -1,
                wl = 0;

            function Ie() {
                return 6 & wt ? pe() : Tl !== -1 ? Tl : Tl = pe()
            }

            function Oi(s) {
                return 1 & s.mode ? 2 & wt && _e !== 0 ? _e & -_e : BP.transition !== null ? (wl === 0 && (wl = xy()), wl) : (s = At) !== 0 ? s : sn() : 1
            }

            function ur(s, o, u, p) {
                if (50 < fa) throw fa = 0, Hd = null, Error(a(185));
                Zs(s, u, p), 2 & wt && s === ge || (s === ge && (!(2 & wt) && (xl |= u), se === 4 && Li(s, _e)), Ue(s, p), u === 1 && wt === 0 && !(1 & o.mode) && (is(), Wo && Hr()))
            }

            function Ue(s, o) {
                var u = s.callbackNode;
                (function(m, v) {
                    for (var b = m.suspendedLanes, A = m.pingedLanes, R = m.expirationTimes, L = m.pendingLanes; 0 < L;) {
                        var F = 31 - wr(L),
                            K = 1 << F,
                            k = R[F];
                        k === -1 ? K & b && !(K & A) || (R[F] = MP(K, v)) : k <= v && (m.expiredLanes |= K), L &= ~K
                    }
                })(s, o);
                var p = Ho(s, s === ge ? _e : 0);
                if (p === 0) u !== null && by(u), s.callbackNode = null, s.callbackPriority = 0;
                else if (o = p & -p, s.callbackPriority !== o) {
                    if (u != null && by(u), o === 1) s.tag === 0 ? function(m) {
                        Wo = !0, Ty(m)
                    }(z0.bind(null, s)) : Ty(z0.bind(null, s)), jn ? GA(function() {
                        !(6 & wt) && Hr()
                    }) : Vc(Yc, Hr), u = null;
                    else {
                        switch (_y(p)) {
                            case 1:
                                u = Yc;
                                break;
                            case 4:
                                u = OP;
                                break;
                            case 16:
                            default:
                                u = Ey;
                                break;
                            case 536870912:
                                u = LP
                        }
                        u = q0(u, G0.bind(null, s))
                    }
                    s.callbackPriority = o, s.callbackNode = u
                }
            }

            function G0(s, o) {
                if (Tl = -1, wl = 0, (6 & wt) != 0) throw Error(a(327));
                var u = s.callbackNode;
                if (pn() && s.callbackNode !== u) return null;
                var p = Ho(s, s === ge ? _e : 0);
                if (p === 0) return null;
                if (30 & p || p & s.expiredLanes || o) o = Sl(s, p);
                else {
                    o = p;
                    var m = wt;
                    wt |= 2;
                    var v = W0();
                    for (ge === s && _e === o || (Mi = null, is(), dn(s, o));;) try {
                        JP();
                        break
                    } catch (A) {
                        j0(s, A)
                    }
                    rd(), vl.current = v, wt = m, ne !== null ? o = 0 : (ge = null, _e = 0, o = se)
                }
                if (o !== 0) {
                    if (o === 2 && (m = Wc(s)) !== 0 && (p = m, o = jd(s, m)), o === 1) throw u = da, dn(s, 0), Li(s, p), Ue(s, pe()), u;
                    if (o === 6) Li(s, p);
                    else {
                        if (m = s.current.alternate, (30 & p) == 0 && ! function(A) {
                                for (var R = A;;) {
                                    if (16384 & R.flags) {
                                        var L = R.updateQueue;
                                        if (L !== null && (L = L.stores) !== null)
                                            for (var F = 0; F < L.length; F++) {
                                                var K = L[F],
                                                    k = K.getSnapshot;
                                                K = K.value;
                                                try {
                                                    if (!Sr(k(), K)) return !1
                                                } catch (W) {
                                                    return !1
                                                }
                                            }
                                    }
                                    if (L = R.child, 16384 & R.subtreeFlags && L !== null) L.return = R, R = L;
                                    else {
                                        if (R === A) break;
                                        for (; R.sibling === null;) {
                                            if (R.return === null || R.return === A) return !0;
                                            R = R.return
                                        }
                                        R.sibling.return = R.return, R = R.sibling
                                    }
                                }
                                return !0
                            }(m) && ((o = Sl(s, p)) === 2 && (v = Wc(s)) !== 0 && (p = v, o = jd(s, v)), o === 1)) throw u = da, dn(s, 0), Li(s, p), Ue(s, pe()), u;
                        switch (s.finishedWork = m, s.finishedLanes = p, o) {
                            case 0:
                            case 1:
                                throw Error(a(345));
                            case 2:
                            case 5:
                                ns(s, Ve, Mi);
                                break;
                            case 3:
                                if (Li(s, p), (130023424 & p) === p && 10 < (o = Ud + 500 - pe())) {
                                    if (Ho(s, 0) !== 0) break;
                                    if (((m = s.suspendedLanes) & p) !== p) {
                                        Ie(), s.pingedLanes |= s.suspendedLanes & m;
                                        break
                                    }
                                    s.timeoutHandle = Ot(ns.bind(null, s, Ve, Mi), o);
                                    break
                                }
                                ns(s, Ve, Mi);
                                break;
                            case 4:
                                if (Li(s, p), (4194240 & p) === p) break;
                                for (o = s.eventTimes, m = -1; 0 < p;) {
                                    var b = 31 - wr(p);
                                    v = 1 << b, (b = o[b]) > m && (m = b), p &= ~v
                                }
                                if (p = m, 10 < (p = (120 > (p = pe() - p) ? 120 : 480 > p ? 480 : 1080 > p ? 1080 : 1920 > p ? 1920 : 3e3 > p ? 3e3 : 4320 > p ? 4320 : 1960 * KP(p / 1960)) - p)) {
                                    s.timeoutHandle = Ot(ns.bind(null, s, Ve, Mi), p);
                                    break
                                }
                                ns(s, Ve, Mi);
                                break;
                            default:
                                throw Error(a(329))
                        }
                    }
                }
                return Ue(s, pe()), s.callbackNode === u ? G0.bind(null, s) : null
            }

            function jd(s, o) {
                var u = pa;
                return s.current.memoizedState.isDehydrated && (dn(s, o).flags |= 256), (s = Sl(s, o)) !== 2 && (o = Ve, Ve = u, o !== null && Wd(o)), s
            }

            function Wd(s) {
                Ve === null ? Ve = s : Ve.push.apply(Ve, s)
            }

            function Li(s, o) {
                for (o &= ~Fd, o &= ~xl, s.suspendedLanes |= o, s.pingedLanes &= ~o, s = s.expirationTimes; 0 < o;) {
                    var u = 31 - wr(o),
                        p = 1 << u;
                    s[u] = -1, o &= ~p
                }
            }

            function z0(s) {
                if (6 & wt) throw Error(a(327));
                pn();
                var o = Ho(s, 0);
                if (!(1 & o)) return Ue(s, pe()), null;
                var u = Sl(s, o);
                if (s.tag !== 0 && u === 2) {
                    var p = Wc(s);
                    p !== 0 && (o = p, u = jd(s, p))
                }
                if (u === 1) throw u = da, dn(s, 0), Li(s, o), Ue(s, pe()), u;
                if (u === 6) throw Error(a(345));
                return s.finishedWork = s.current.alternate, s.finishedLanes = o, ns(s, Ve, Mi), Ue(s, pe()), null
            }

            function H0(s) {
                Ni !== null && Ni.tag === 0 && !(6 & wt) && pn();
                var o = wt;
                wt |= 1;
                var u = te.transition,
                    p = At;
                try {
                    if (te.transition = null, At = 1, s) return s()
                } finally {
                    At = p, te.transition = u, !(6 & (wt = o)) && Hr()
                }
            }

            function Xd() {
                $e = rs.current, zt(rs)
            }

            function dn(s, o) {
                s.finishedWork = null, s.finishedLanes = 0;
                var u = s.timeoutHandle;
                if (u !== xe && (s.timeoutHandle = xe, de(u)), ne !== null)
                    for (u = ne.return; u !== null;) {
                        var p = u;
                        switch (Kc(p), p.tag) {
                            case 1:
                                (p = p.type.childContextTypes) != null && zc();
                                break;
                            case 3:
                                Jn(), zt(Be), zt(Ae), dd();
                                break;
                            case 5:
                                ud(p);
                                break;
                            case 4:
                                Jn();
                                break;
                            case 13:
                            case 19:
                                zt(Qt);
                                break;
                            case 10:
                                id(p.type._context);
                                break;
                            case 22:
                            case 23:
                                Xd()
                        }
                        u = u.return
                    }
                if (ge = s, ne = s = Bi(s.current, null), _e = $e = o, se = 0, da = null, Fd = xl = cn = 0, Ve = pa = null, hn !== null) {
                    for (o = 0; o < hn.length; o++)
                        if ((p = (u = hn[o]).interleaved) !== null) {
                            u.interleaved = null;
                            var m = p.next,
                                v = u.pending;
                            if (v !== null) {
                                var b = v.next;
                                v.next = m, p.next = b
                            }
                            u.pending = p
                        }
                    hn = null
                }
                return s
            }

            function j0(s, o) {
                for (;;) {
                    var u = ne;
                    try {
                        if (rd(), rl.current = al, il) {
                            for (var p = $t.memoizedState; p !== null;) {
                                var m = p.queue;
                                m !== null && (m.pending = null), p = p.next
                            }
                            il = !1
                        }
                        if (un = 0, me = fe = $t = null, ia = !1, na = 0, kd.current = null, u === null || u.return === null) {
                            se = 1, da = o, ne = null;
                            break
                        }
                        t: {
                            var v = s,
                                b = u.return,
                                A = u,
                                R = o;
                            if (o = _e, A.flags |= 32768, R !== null && typeof R == "object" && typeof R.then == "function") {
                                var L = R,
                                    F = A,
                                    K = F.tag;
                                if (!(1 & F.mode) && (K === 0 || K === 11 || K === 15)) {
                                    var k = F.alternate;
                                    k ? (F.updateQueue = k.updateQueue, F.memoizedState = k.memoizedState, F.lanes = k.lanes) : (F.updateQueue = null, F.memoizedState = null)
                                }
                                var W = d0(b);
                                if (W !== null) {
                                    W.flags &= -257, p0(W, b, A, 0, o), 1 & W.mode && c0(v, L, o), R = L;
                                    var st = (o = W).updateQueue;
                                    if (st === null) {
                                        var yt = new Set;
                                        yt.add(R), o.updateQueue = yt
                                    } else st.add(R);
                                    break t
                                }
                                if (!(1 & o)) {
                                    c0(v, L, o), $d();
                                    break t
                                }
                                R = Error(a(426))
                            } else if (Ht && 1 & A.mode) {
                                var U = d0(b);
                                if (U !== null) {
                                    !(65536 & U.flags) && (U.flags |= 256), p0(U, b, A, 0, o), td(ts(R, A));
                                    break t
                                }
                            }
                            v = R = ts(R, A),
                            se !== 4 && (se = 2),
                            pa === null ? pa = [v] : pa.push(v),
                            v = b;do {
                                switch (v.tag) {
                                    case 3:
                                        v.flags |= 65536, o &= -o, v.lanes |= o, Dy(v, h0(0, R, o));
                                        break t;
                                    case 1:
                                        A = R;
                                        var C = v.type,
                                            N = v.stateNode;
                                        if (!(128 & v.flags) && (typeof C.getDerivedStateFromError == "function" || N !== null && typeof N.componentDidCatch == "function" && (Di === null || !Di.has(N)))) {
                                            v.flags |= 65536, o &= -o, v.lanes |= o, Dy(v, u0(v, A, o));
                                            break t
                                        }
                                }
                                v = v.return
                            } while (v !== null)
                        }
                        $0(u)
                    } catch (H) {
                        o = H, ne === u && u !== null && (ne = u = u.return);
                        continue
                    }
                    break
                }
            }

            function W0() {
                var s = vl.current;
                return vl.current = al, s === null ? al : s
            }

            function $d() {
                se !== 0 && se !== 3 && se !== 2 || (se = 4), ge === null || !(268435455 & cn) && !(268435455 & xl) || Li(ge, _e)
            }

            function Sl(s, o) {
                var u = wt;
                wt |= 2;
                var p = W0();
                for (ge === s && _e === o || (Mi = null, dn(s, o));;) try {
                    ZP();
                    break
                } catch (m) {
                    j0(s, m)
                }
                if (rd(), wt = u, vl.current = p, ne !== null) throw Error(a(261));
                return ge = null, _e = 0, se
            }

            function ZP() {
                for (; ne !== null;) X0(ne)
            }

            function JP() {
                for (; ne !== null && !DP();) X0(ne)
            }

            function X0(s) {
                var o = U0(s.alternate, s, $e);
                s.memoizedProps = s.pendingProps, o === null ? $0(s) : ne = o, kd.current = null
            }

            function $0(s) {
                var o = s;
                do {
                    var u = o.alternate;
                    if (s = o.return, (32768 & o.flags) == 0) {
                        if ((u = VP(u, o, $e)) !== null) return void(ne = u)
                    } else {
                        if ((u = YP(u, o)) !== null) return u.flags &= 32767, void(ne = u);
                        if (s === null) return se = 6, void(ne = null);
                        s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null
                    }
                    if ((o = o.sibling) !== null) return void(ne = o);
                    ne = o = s
                } while (o !== null);
                se === 0 && (se = 5)
            }

            function ns(s, o, u) {
                var p = At,
                    m = te.transition;
                try {
                    te.transition = null, At = 1,
                        function(v, b, A, R) {
                            do pn(); while (Ni !== null);
                            if (6 & wt) throw Error(a(327));
                            A = v.finishedWork;
                            var L = v.finishedLanes;
                            if (A === null) return null;
                            if (v.finishedWork = null, v.finishedLanes = 0, A === v.current) throw Error(a(177));
                            v.callbackNode = null, v.callbackPriority = 0;
                            var F = A.lanes | A.childLanes;
                            if (function(W, st) {
                                    var yt = W.pendingLanes & ~st;
                                    W.pendingLanes = st, W.suspendedLanes = 0, W.pingedLanes = 0, W.expiredLanes &= st, W.mutableReadLanes &= st, W.entangledLanes &= st, st = W.entanglements;
                                    var U = W.eventTimes;
                                    for (W = W.expirationTimes; 0 < yt;) {
                                        var C = 31 - wr(yt),
                                            N = 1 << C;
                                        st[C] = 0, U[C] = -1, W[C] = -1, yt &= ~N
                                    }
                                }(v, F), v === ge && (ne = ge = null, _e = 0), !(2064 & A.subtreeFlags) && !(2064 & A.flags) || bl || (bl = !0, q0(Ey, function() {
                                    return pn(), null
                                })), F = (15990 & A.flags) != 0, (15990 & A.subtreeFlags) != 0 || F) {
                                F = te.transition, te.transition = null;
                                var K = At;
                                At = 1;
                                var k = wt;
                                wt |= 4, kd.current = null,
                                    function(W, st) {
                                        for (rt(W.containerInfo), it = st; it !== null;)
                                            if (st = (W = it).child, (1028 & W.subtreeFlags) != 0 && st !== null) st.return = W, it = st;
                                            else
                                                for (; it !== null;) {
                                                    W = it;
                                                    try {
                                                        var yt = W.alternate;
                                                        if (1024 & W.flags) switch (W.tag) {
                                                            case 0:
                                                            case 11:
                                                            case 15:
                                                            case 5:
                                                            case 6:
                                                            case 4:
                                                            case 17:
                                                                break;
                                                            case 1:
                                                                if (yt !== null) {
                                                                    var U = yt.memoizedProps,
                                                                        C = yt.memoizedState,
                                                                        N = W.stateNode,
                                                                        H = N.getSnapshotBeforeUpdate(W.elementType === W.type ? U : Pr(W.type, U), C);
                                                                    N.__reactInternalSnapshotBeforeUpdate = H
                                                                }
                                                                break;
                                                            case 3:
                                                                xt && aP(W.stateNode.containerInfo);
                                                                break;
                                                            default:
                                                                throw Error(a(163))
                                                        }
                                                    } catch (ct) {
                                                        jt(W, W.return, ct)
                                                    }
                                                    if ((st = W.sibling) !== null) {
                                                        st.return = W.return, it = st;
                                                        break
                                                    }
                                                    it = W.return
                                                }
                                        yt = C0, C0 = !1
                                    }(v, A), N0(A, v), D(v.containerInfo), v.current = A, QP(A), NP(), wt = k, At = K, te.transition = F
                            } else v.current = A;
                            if (bl && (bl = !1, Ni = v, El = L), F = v.pendingLanes, F === 0 && (Di = null), function(W) {
                                    if (zr && typeof zr.onCommitFiberRoot == "function") try {
                                        zr.onCommitFiberRoot(jo, W, void 0, (128 & W.current.flags) == 128)
                                    } catch (st) {}
                                }(A.stateNode), Ue(v, pe()), b !== null)
                                for (R = v.onRecoverableError, A = 0; A < b.length; A++) L = b[A], R(L.value, {
                                    componentStack: L.stack,
                                    digest: L.digest
                                });
                            if (_l) throw _l = !1, v = zd, zd = null, v;
                            1 & El && v.tag !== 0 && pn(), F = v.pendingLanes, 1 & F ? v === Hd ? fa++ : (fa = 0, Hd = v) : fa = 0, Hr()
                        }(s, o, u, p)
                } finally {
                    te.transition = m, At = p
                }
                return null
            }

            function pn() {
                if (Ni !== null) {
                    var s = _y(El),
                        o = te.transition,
                        u = At;
                    try {
                        if (te.transition = null, At = 16 > s ? 16 : s, Ni === null) var p = !1;
                        else {
                            if (s = Ni, Ni = null, El = 0, (6 & wt) != 0) throw Error(a(331));
                            var m = wt;
                            for (wt |= 4, it = s.current; it !== null;) {
                                var v = it,
                                    b = v.child;
                                if (16 & it.flags) {
                                    var A = v.deletions;
                                    if (A !== null) {
                                        for (var R = 0; R < A.length; R++) {
                                            var L = A[R];
                                            for (it = L; it !== null;) {
                                                var F = it;
                                                switch (F.tag) {
                                                    case 0:
                                                    case 11:
                                                    case 15:
                                                        ua(8, F, v)
                                                }
                                                var K = F.child;
                                                if (K !== null) K.return = F, it = K;
                                                else
                                                    for (; it !== null;) {
                                                        var k = (F = it).sibling,
                                                            W = F.return;
                                                        if (I0(F), F === L) {
                                                            it = null;
                                                            break
                                                        }
                                                        if (k !== null) {
                                                            k.return = W, it = k;
                                                            break
                                                        }
                                                        it = W
                                                    }
                                            }
                                        }
                                        var st = v.alternate;
                                        if (st !== null) {
                                            var yt = st.child;
                                            if (yt !== null) {
                                                st.child = null;
                                                do {
                                                    var U = yt.sibling;
                                                    yt.sibling = null, yt = U
                                                } while (yt !== null)
                                            }
                                        }
                                        it = v
                                    }
                                }
                                if (2064 & v.subtreeFlags && b !== null) b.return = v, it = b;
                                else t: for (; it !== null;) {
                                    if (2048 & (v = it).flags) switch (v.tag) {
                                        case 0:
                                        case 11:
                                        case 15:
                                            ua(9, v, v.return)
                                    }
                                    var C = v.sibling;
                                    if (C !== null) {
                                        C.return = v.return, it = C;
                                        break t
                                    }
                                    it = v.return
                                }
                            }
                            var N = s.current;
                            for (it = N; it !== null;) {
                                var H = (b = it).child;
                                if (2064 & b.subtreeFlags && H !== null) H.return = b, it = H;
                                else t: for (b = N; it !== null;) {
                                    if (2048 & (A = it).flags) try {
                                        switch (A.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                dl(9, A)
                                        }
                                    } catch (Rt) {
                                        jt(A, A.return, Rt)
                                    }
                                    if (A === b) {
                                        it = null;
                                        break t
                                    }
                                    var ct = A.sibling;
                                    if (ct !== null) {
                                        ct.return = A.return, it = ct;
                                        break t
                                    }
                                    it = A.return
                                }
                            }
                            if (wt = m, Hr(), zr && typeof zr.onPostCommitFiberRoot == "function") try {
                                zr.onPostCommitFiberRoot(jo, s)
                            } catch (Rt) {}
                            p = !0
                        }
                        return p
                    } finally {
                        At = u, te.transition = o
                    }
                }
                return !1
            }

            function V0(s, o, u) {
                s = Ri(s, o = h0(0, o = ts(u, o), 1), 1), o = Ie(), s !== null && (Zs(s, 1, o), Ue(s, o))
            }

            function jt(s, o, u) {
                if (s.tag === 3) V0(s, s, u);
                else
                    for (; o !== null;) {
                        if (o.tag === 3) {
                            V0(o, s, u);
                            break
                        }
                        if (o.tag === 1) {
                            var p = o.stateNode;
                            if (typeof o.type.getDerivedStateFromError == "function" || typeof p.componentDidCatch == "function" && (Di === null || !Di.has(p))) {
                                o = Ri(o, s = u0(o, s = ts(u, s), 1), 1), s = Ie(), o !== null && (Zs(o, 1, s), Ue(o, s));
                                break
                            }
                        }
                        o = o.return
                    }
            }

            function tC(s, o, u) {
                var p = s.pingCache;
                p !== null && p.delete(o), o = Ie(), s.pingedLanes |= s.suspendedLanes & u, ge === s && (_e & u) === u && (se === 4 || se === 3 && (130023424 & _e) === _e && 500 > pe() - Ud ? dn(s, 0) : Fd |= u), Ue(s, o)
            }

            function Y0(s, o) {
                o === 0 && (1 & s.mode ? (o = jc, !(130023424 & (jc <<= 1)) && (jc = 4194304)) : o = 1);
                var u = Ie();
                (s = Wr(s, o)) !== null && (Zs(s, o, u), Ue(s, u))
            }

            function eC(s) {
                var o = s.memoizedState,
                    u = 0;
                o !== null && (u = o.retryLane), Y0(s, u)
            }

            function rC(s, o) {
                var u = 0;
                switch (s.tag) {
                    case 13:
                        var p = s.stateNode,
                            m = s.memoizedState;
                        m !== null && (u = m.retryLane);
                        break;
                    case 19:
                        p = s.stateNode;
                        break;
                    default:
                        throw Error(a(314))
                }
                p !== null && p.delete(o), Y0(s, u)
            }

            function q0(s, o) {
                return Vc(s, o)
            }

            function iC(s, o, u, p) {
                this.tag = s, this.key = u, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = p, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
            }

            function cr(s, o, u, p) {
                return new iC(s, o, u, p)
            }

            function Vd(s) {
                return !(!(s = s.prototype) || !s.isReactComponent)
            }

            function Bi(s, o) {
                var u = s.alternate;
                return u === null ? ((u = cr(s.tag, o, s.key, s.mode)).elementType = s.elementType, u.type = s.type, u.stateNode = s.stateNode, u.alternate = s, s.alternate = u) : (u.pendingProps = o, u.type = s.type, u.flags = 0, u.subtreeFlags = 0, u.deletions = null), u.flags = 14680064 & s.flags, u.childLanes = s.childLanes, u.lanes = s.lanes, u.child = s.child, u.memoizedProps = s.memoizedProps, u.memoizedState = s.memoizedState, u.updateQueue = s.updateQueue, o = s.dependencies, u.dependencies = o === null ? null : {
                    lanes: o.lanes,
                    firstContext: o.firstContext
                }, u.sibling = s.sibling, u.index = s.index, u.ref = s.ref, u
            }

            function Al(s, o, u, p, m, v) {
                var b = 2;
                if (p = s, typeof s == "function") Vd(s) && (b = 1);
                else if (typeof s == "string") b = 5;
                else t: switch (s) {
                    case d:
                        return fn(u.children, m, v, o);
                    case f:
                        b = 8, m |= 8;
                        break;
                    case g:
                        return (s = cr(12, u, o, 2 | m)).elementType = g, s.lanes = v, s;
                    case E:
                        return (s = cr(13, u, o, m)).elementType = E, s.lanes = v, s;
                    case w:
                        return (s = cr(19, u, o, m)).elementType = w, s.lanes = v, s;
                    case T:
                        return Pl(u, m, v, o);
                    default:
                        if (typeof s == "object" && s !== null) switch (s.$$typeof) {
                            case y:
                                b = 10;
                                break t;
                            case x:
                                b = 9;
                                break t;
                            case _:
                                b = 11;
                                break t;
                            case I:
                                b = 14;
                                break t;
                            case S:
                                b = 16, p = null;
                                break t
                        }
                        throw Error(a(130, s == null ? s : typeof s, ""))
                }
                return (o = cr(b, u, o, m)).elementType = s, o.type = p, o.lanes = v, o
            }

            function fn(s, o, u, p) {
                return (s = cr(7, s, p, o)).lanes = u, s
            }

            function Pl(s, o, u, p) {
                return (s = cr(22, s, p, o)).elementType = T, s.lanes = u, s.stateNode = {
                    isHidden: !1
                }, s
            }

            function Yd(s, o, u) {
                return (s = cr(6, s, null, o)).lanes = u, s
            }

            function qd(s, o, u) {
                return (o = cr(4, s.children !== null ? s.children : [], s.key, o)).lanes = u, o.stateNode = {
                    containerInfo: s.containerInfo,
                    pendingChildren: null,
                    implementation: s.implementation
                }, o
            }

            function nC(s, o, u, p, m) {
                this.tag = o, this.containerInfo = s, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = xe, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Xc(0), this.expirationTimes = Xc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Xc(0), this.identifierPrefix = p, this.onRecoverableError = m, St && (this.mutableSourceEagerHydrationData = null)
            }

            function Q0(s, o, u, p, m, v, b, A, R) {
                return s = new nC(s, o, u, A, R), o === 1 ? (o = 1, v === !0 && (o |= 8)) : o = 0, v = cr(3, null, null, o), s.current = v, v.stateNode = s, v.memoizedState = {
                    element: p,
                    isDehydrated: u,
                    cache: null,
                    transitions: null,
                    pendingSuspenseBoundaries: null
                }, ad(v), s
            }

            function K0(s) {
                if (!s) return Ci;
                t: {
                    if (M(s = s._reactInternals) !== s || s.tag !== 1) throw Error(a(170));
                    var o = s;do {
                        switch (o.tag) {
                            case 3:
                                o = o.stateNode.context;
                                break t;
                            case 1:
                                if (We(o.type)) {
                                    o = o.stateNode.__reactInternalMemoizedMergedChildContext;
                                    break t
                                }
                        }
                        o = o.return
                    } while (o !== null);
                    throw Error(a(171))
                }
                if (s.tag === 1) {
                    var u = s.type;
                    if (We(u)) return yy(s, u, o)
                }
                return o
            }

            function Z0(s) {
                var o = s._reactInternals;
                if (o === void 0) throw typeof s.render == "function" ? Error(a(188)) : (s = Object.keys(s).join(","), Error(a(268, s)));
                return (s = Y(o)) === null ? null : s.stateNode
            }

            function J0(s, o) {
                if ((s = s.memoizedState) !== null && s.dehydrated !== null) {
                    var u = s.retryLane;
                    s.retryLane = u !== 0 && u < o ? u : o
                }
            }

            function Cl(s, o) {
                J0(s, o), (s = s.alternate) && J0(s, o)
            }

            function sC(s) {
                return (s = Y(s)) === null ? null : s.stateNode
            }

            function aC() {
                return null
            }
            return U0 = function(s, o, u) {
                if (s !== null)
                    if (s.memoizedProps !== o.pendingProps || Be.current) ke = !0;
                    else {
                        if (!(s.lanes & u) && !(128 & o.flags)) return ke = !1,
                            function(K, k, W) {
                                switch (k.tag) {
                                    case 3:
                                        _0(k), Yn();
                                        break;
                                    case 5:
                                        zy(k);
                                        break;
                                    case 1:
                                        We(k.type) && zo(k);
                                        break;
                                    case 4:
                                        hd(k, k.stateNode.containerInfo);
                                        break;
                                    case 10:
                                        Iy(0, k.type._context, k.memoizedProps.value);
                                        break;
                                    case 13:
                                        var st = k.memoizedState;
                                        if (st !== null) return st.dehydrated !== null ? (Lt(Qt, 1 & Qt.current), k.flags |= 128, null) : W & k.child.childLanes ? E0(K, k, W) : (Lt(Qt, 1 & Qt.current), (K = di(K, k, W)) !== null ? K.sibling : null);
                                        Lt(Qt, 1 & Qt.current);
                                        break;
                                    case 19:
                                        if (st = (W & k.childLanes) != 0, (128 & K.flags) != 0) {
                                            if (st) return w0(K, k, W);
                                            k.flags |= 128
                                        }
                                        var yt = k.memoizedState;
                                        if (yt !== null && (yt.rendering = null, yt.tail = null, yt.lastEffect = null), Lt(Qt, Qt.current), st) break;
                                        return null;
                                    case 22:
                                    case 23:
                                        return k.lanes = 0, y0(K, k, W)
                                }
                                return di(K, k, W)
                            }(s, o, u);
                        ke = (131072 & s.flags) != 0
                    }
                else ke = !1, Ht && 1048576 & o.flags && wy(o, $o, o.index);
                switch (o.lanes = 0, o.tag) {
                    case 2:
                        var p = o.type;
                        ul(s, o), s = o.pendingProps;
                        var m = Xn(o, Ae.current);
                        Qn(o, u), m = md(null, o, p, s, m, u);
                        var v = gd();
                        return o.flags |= 1, typeof m == "object" && m !== null && typeof m.render == "function" && m.$$typeof === void 0 ? (o.tag = 1, o.memoizedState = null, o.updateQueue = null, We(p) ? (v = !0, zo(o)) : v = !1, o.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, ad(o), m.updater = Jo, o.stateNode = m, m._reactInternals = o, ld(o, p, s, u), o = wd(null, o, p, !0, v, u)) : (o.tag = 0, Ht && v && Qc(o), Fe(null, o, m, u), o = o.child), o;
                    case 16:
                        p = o.elementType;
                        t: {
                            switch (ul(s, o), s = o.pendingProps, p = (m = p._init)(p._payload), o.type = p, m = o.tag = function(K) {
                                if (typeof K == "function") return Vd(K) ? 1 : 0;
                                if (K != null) {
                                    if ((K = K.$$typeof) === _) return 11;
                                    if (K === I) return 14
                                }
                                return 2
                            }(p), s = Pr(p, s), m) {
                                case 0:
                                    o = Td(null, o, p, s, u);
                                    break t;
                                case 1:
                                    o = x0(null, o, p, s, u);
                                    break t;
                                case 11:
                                    o = f0(null, o, p, s, u);
                                    break t;
                                case 14:
                                    o = m0(null, o, p, Pr(p.type, s), u);
                                    break t
                            }
                            throw Error(a(306, p, ""))
                        }
                        return o;
                    case 0:
                        return p = o.type, m = o.pendingProps, Td(s, o, p, m = o.elementType === p ? m : Pr(p, m), u);
                    case 1:
                        return p = o.type, m = o.pendingProps, x0(s, o, p, m = o.elementType === p ? m : Pr(p, m), u);
                    case 3:
                        t: {
                            if (_0(o), s === null) throw Error(a(387));p = o.pendingProps,
                            m = (v = o.memoizedState).element,
                            My(s, o),
                            Zo(o, p, null, u);
                            var b = o.memoizedState;
                            if (p = b.element, St && v.isDehydrated) {
                                if (v = {
                                        element: p,
                                        isDehydrated: !1,
                                        cache: b.cache,
                                        pendingSuspenseBoundaries: b.pendingSuspenseBoundaries,
                                        transitions: b.transitions
                                    }, o.updateQueue.baseState = v, o.memoizedState = v, 256 & o.flags) {
                                    o = b0(s, o, p, u, m = ts(Error(a(423)), o));
                                    break t
                                }
                                if (p !== m) {
                                    o = b0(s, o, p, u, m = ts(Error(a(424)), o));
                                    break t
                                }
                                for (St && (ar = mP(o.stateNode.containerInfo), Xe = o, Ht = !0, Ar = null, Js = !1), u = Gy(o, null, p, u), o.child = u; u;) u.flags = -3 & u.flags | 4096, u = u.sibling
                            } else {
                                if (Yn(), p === m) {
                                    o = di(s, o, u);
                                    break t
                                }
                                Fe(s, o, p, u)
                            }
                            o = o.child
                        }
                        return o;
                    case 5:
                        return zy(o), s === null && Jc(o), p = o.type, m = o.pendingProps, v = s !== null ? s.memoizedProps : null, b = m.children, Nt(p, m) ? b = null : v !== null && Nt(p, v) && (o.flags |= 32), v0(s, o), Fe(s, o, b, u), o.child;
                    case 6:
                        return s === null && Jc(o), null;
                    case 13:
                        return E0(s, o, u);
                    case 4:
                        return hd(o, o.stateNode.containerInfo), p = o.pendingProps, s === null ? o.child = Kn(o, null, p, u) : Fe(s, o, p, u), o.child;
                    case 11:
                        return p = o.type, m = o.pendingProps, f0(s, o, p, m = o.elementType === p ? m : Pr(p, m), u);
                    case 7:
                        return Fe(s, o, o.pendingProps, u), o.child;
                    case 8:
                    case 12:
                        return Fe(s, o, o.pendingProps.children, u), o.child;
                    case 10:
                        t: {
                            if (p = o.type._context, m = o.pendingProps, v = o.memoizedProps, Iy(0, p, b = m.value), v !== null)
                                if (Sr(v.value, b)) {
                                    if (v.children === m.children && !Be.current) {
                                        o = di(s, o, u);
                                        break t
                                    }
                                } else
                                    for ((v = o.child) !== null && (v.return = o); v !== null;) {
                                        var A = v.dependencies;
                                        if (A !== null) {
                                            b = v.child;
                                            for (var R = A.firstContext; R !== null;) {
                                                if (R.context === p) {
                                                    if (v.tag === 1) {
                                                        (R = ci(-1, u & -u)).tag = 2;
                                                        var L = v.updateQueue;
                                                        if (L !== null) {
                                                            var F = (L = L.shared).pending;
                                                            F === null ? R.next = R : (R.next = F.next, F.next = R), L.pending = R
                                                        }
                                                    }
                                                    v.lanes |= u, (R = v.alternate) !== null && (R.lanes |= u), nd(v.return, u, o), A.lanes |= u;
                                                    break
                                                }
                                                R = R.next
                                            }
                                        } else if (v.tag === 10) b = v.type === o.type ? null : v.child;
                                        else if (v.tag === 18) {
                                            if ((b = v.return) === null) throw Error(a(341));
                                            b.lanes |= u, (A = b.alternate) !== null && (A.lanes |= u), nd(b, u, o), b = v.sibling
                                        } else b = v.child;
                                        if (b !== null) b.return = v;
                                        else
                                            for (b = v; b !== null;) {
                                                if (b === o) {
                                                    b = null;
                                                    break
                                                }
                                                if ((v = b.sibling) !== null) {
                                                    v.return = b.return, b = v;
                                                    break
                                                }
                                                b = b.return
                                            }
                                        v = b
                                    }
                            Fe(s, o, m.children, u),
                            o = o.child
                        }
                        return o;
                    case 9:
                        return m = o.type, p = o.pendingProps.children, Qn(o, u), p = p(m = or(m)), o.flags |= 1, Fe(s, o, p, u), o.child;
                    case 14:
                        return m = Pr(p = o.type, o.pendingProps), m0(s, o, p, m = Pr(p.type, m), u);
                    case 15:
                        return g0(s, o, o.type, o.pendingProps, u);
                    case 17:
                        return p = o.type, m = o.pendingProps, m = o.elementType === p ? m : Pr(p, m), ul(s, o), o.tag = 1, We(p) ? (s = !0, zo(o)) : s = !1, Qn(o, u), By(o, p, m), ld(o, p, m, u), wd(null, o, p, !0, s, u);
                    case 19:
                        return w0(s, o, u);
                    case 22:
                        return y0(s, o, u)
                }
                throw Error(a(156, o.tag))
            }, e.attemptContinuousHydration = function(s) {
                if (s.tag === 13) {
                    var o = Wr(s, 134217728);
                    o !== null && ur(o, s, 134217728, Ie()), Cl(s, 134217728)
                }
            }, e.attemptDiscreteHydration = function(s) {
                if (s.tag === 13) {
                    var o = Wr(s, 1);
                    o !== null && ur(o, s, 1, Ie()), Cl(s, 1)
                }
            }, e.attemptHydrationAtCurrentPriority = function(s) {
                if (s.tag === 13) {
                    var o = Oi(s),
                        u = Wr(s, o);
                    u !== null && ur(u, s, o, Ie()), Cl(s, o)
                }
            }, e.attemptSynchronousHydration = function(s) {
                switch (s.tag) {
                    case 3:
                        var o = s.stateNode;
                        if (o.current.memoizedState.isDehydrated) {
                            var u = Ks(o.pendingLanes);
                            u !== 0 && ($c(o, 1 | u), Ue(o, pe()), !(6 & wt) && (is(), Hr()))
                        }
                        break;
                    case 13:
                        H0(function() {
                            var p = Wr(s, 1);
                            if (p !== null) {
                                var m = Ie();
                                ur(p, s, 1, m)
                            }
                        }), Cl(s, 1)
                }
            }, e.batchedUpdates = function(s, o) {
                var u = wt;
                wt |= 1;
                try {
                    return s(o)
                } finally {
                    (wt = u) === 0 && (is(), Wo && Hr())
                }
            }, e.createComponentSelector = function(s) {
                return {
                    $$typeof: pl,
                    value: s
                }
            }, e.createContainer = function(s, o, u, p, m, v, b) {
                return Q0(s, o, !1, null, 0, p, 0, v, b)
            }, e.createHasPseudoClassSelector = function(s) {
                return {
                    $$typeof: fl,
                    value: s
                }
            }, e.createHydrationContainer = function(s, o, u, p, m, v, b, A, R) {
                return (s = Q0(u, p, !0, s, 0, v, 0, A, R)).context = K0(null), u = s.current, (v = ci(p = Ie(), m = Oi(u))).callback = o != null ? o : null, Ri(u, v, m), s.current.lanes = m, Zs(s, m, p), Ue(s, p), s
            }, e.createPortal = function(s, o, u) {
                var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
                return {
                    $$typeof: c,
                    key: p == null ? null : "" + p,
                    children: s,
                    containerInfo: o,
                    implementation: u
                }
            }, e.createRoleSelector = function(s) {
                return {
                    $$typeof: ml,
                    value: s
                }
            }, e.createTestNameSelector = function(s) {
                return {
                    $$typeof: gl,
                    value: s
                }
            }, e.createTextSelector = function(s) {
                return {
                    $$typeof: yl,
                    value: s
                }
            }, e.deferredUpdates = function(s) {
                var o = At,
                    u = te.transition;
                try {
                    return te.transition = null, At = 16, s()
                } finally {
                    At = o, te.transition = u
                }
            }, e.discreteUpdates = function(s, o, u, p, m) {
                var v = At,
                    b = te.transition;
                try {
                    return te.transition = null, At = 1, s(o, u, p, m)
                } finally {
                    At = v, te.transition = b, wt === 0 && is()
                }
            }, e.findAllNodes = Bd, e.findBoundingRects = function(s, o) {
                if (!Ys) throw Error(a(363));
                o = Bd(s, o), s = [];
                for (var u = 0; u < o.length; u++) s.push(HA(o[u]));
                for (o = s.length - 1; 0 < o; o--)
                    for (var p = (u = s[o]).x, m = p + u.width, v = u.y, b = v + u.height, A = o - 1; 0 <= A; A--)
                        if (o !== A) {
                            var R = s[A],
                                L = R.x,
                                F = L + R.width,
                                K = R.y,
                                k = K + R.height;
                            if (p >= L && v >= K && m <= F && b <= k) {
                                s.splice(o, 1);
                                break
                            }
                            if (!(p !== L || u.width !== R.width || k < v || K > b)) {
                                K > v && (R.height += K - v, R.y = v), k < b && (R.height = b - K), s.splice(o, 1);
                                break
                            }
                            if (!(v !== K || u.height !== R.height || F < p || L > m)) {
                                L > p && (R.width += L - p, R.x = p), F < m && (R.width = m - L), s.splice(o, 1);
                                break
                            }
                        }
                return s
            }, e.findHostInstance = Z0, e.findHostInstanceWithNoPortals = function(s) {
                return (s = (s = nt(s)) !== null ? B(s) : null) === null ? null : s.stateNode
            }, e.findHostInstanceWithWarning = function(s) {
                return Z0(s)
            }, e.flushControlled = function(s) {
                var o = wt;
                wt |= 1;
                var u = te.transition,
                    p = At;
                try {
                    te.transition = null, At = 1, s()
                } finally {
                    At = p, te.transition = u, (wt = o) === 0 && (is(), Hr())
                }
            }, e.flushPassiveEffects = pn, e.flushSync = H0, e.focusWithin = function(s, o) {
                if (!Ys) throw Error(a(363));
                for (o = F0(s = Nd(s), o), o = Array.from(o), s = 0; s < o.length;) {
                    var u = o[s++];
                    if (!qs(u)) {
                        if (u.tag === 5 && XA(u.stateNode)) return !0;
                        for (u = u.child; u !== null;) o.push(u), u = u.sibling
                    }
                }
                return !1
            }, e.getCurrentUpdatePriority = function() {
                return At
            }, e.getFindAllNodesFailureDescription = function(s, o) {
                if (!Ys) throw Error(a(363));
                var u = 0,
                    p = [];
                s = [Nd(s), 0];
                for (var m = 0; m < s.length;) {
                    var v = s[m++],
                        b = s[m++],
                        A = o[b];
                    if ((v.tag !== 5 || !qs(v)) && (Od(v, A) && (p.push(Ld(A)), ++b > u && (u = b)), b < o.length))
                        for (v = v.child; v !== null;) s.push(v, b), v = v.sibling
                }
                if (u < o.length) {
                    for (s = []; u < o.length; u++) s.push(Ld(o[u]));
                    return `findAllNodes was able to match part of the selector:
  ` + p.join(" > ") + `

No matching component was found for:
  ` + s.join(" > ")
                }
                return null
            }, e.getPublicRootInstance = function(s) {
                return (s = s.current).child ? s.child.tag === 5 ? ft(s.child.stateNode) : s.child.stateNode : null
            }, e.injectIntoDevTools = function(s) {
                if (s = {
                        bundleType: s.bundleType,
                        version: s.version,
                        rendererPackageName: s.rendererPackageName,
                        rendererConfig: s.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: l.ReactCurrentDispatcher,
                        findHostInstanceByFiber: sC,
                        findFiberByHostInstance: s.findFiberByHostInstance || aC,
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.2.0"
                    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") s = !1;
                else {
                    var o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (o.isDisabled || !o.supportsFiber) s = !0;
                    else {
                        try {
                            jo = o.inject(s), zr = o
                        } catch (u) {}
                        s = !!o.checkDCE
                    }
                }
                return s
            }, e.isAlreadyRendering = function() {
                return !1
            }, e.observeVisibleRects = function(s, o, u, p) {
                if (!Ys) throw Error(a(363));
                s = Bd(s, o);
                var m = $A(s, u, p).disconnect;
                return {
                    disconnect: function() {
                        m()
                    }
                }
            }, e.registerMutableSourceForHydration = function(s, o) {
                var u = o._getVersion;
                u = u(o._source), s.mutableSourceEagerHydrationData == null ? s.mutableSourceEagerHydrationData = [o, u] : s.mutableSourceEagerHydrationData.push(o, u)
            }, e.runWithPriority = function(s, o) {
                var u = At;
                try {
                    return At = s, o()
                } finally {
                    At = u
                }
            }, e.shouldError = function() {
                return null
            }, e.shouldSuspend = function() {
                return !1
            }, e.updateContainer = function(s, o, u, p) {
                var m = o.current,
                    v = Ie(),
                    b = Oi(m);
                return u = K0(u), o.context === null ? o.context = u : o.pendingContext = u, (o = ci(v, b)).payload = {
                    element: s
                }, (p = p === void 0 ? null : p) !== null && (o.callback = p), (s = Ri(m, o, b)) !== null && (ur(s, m, b, v), Ko(s, m, b)), b
            }, e
        }), Wg
    }({
        get exports() {
            return Cc
        },
        set exports(t) {
            Cc = t
        }
    }).exports = oA();
    var lA = OS(Cc),
        Vg = {
            name: "root",
            private: !0,
            workspaces: ["packages/*"],
            scripts: {
                build: "nx run-many --target=build --all --parallel",
                "build:force": "nx run-many --target=build --all --parallel --skip-nx-cache",
                "build:docs": "nx run @pixi/react-docs:deploy",
                clean: "rimraf packages/*/dist packages/*/build",
                lint: "eslint .",
                prepare: "husky install",
                prerelease: "./scripts/checkReleaseBranch.mjs && npm run lint && npm run test:force && npm run build:force",
                release: "lerna publish --no-private",
                test: "nx run-many --target=test --all --parallel",
                "test:force": "nx run-many --target=test --all --parallel --skip-nx-cache",
                "test:ci": "nx run-many --target=test:ci --all --parallel",
                "test:ci:force": "nx run-many --target=test:ci --all --parallel --skip-nx-cache",
                "test:types": "nx run-many --target=test:types --all --parallel",
                "test:types:force": "nx run-many --target=test:types --all --parallel --skip-nx-cache"
            },
            husky: {
                hooks: {
                    "pre-commit": "lint-staged"
                }
            },
            "lint-staged": {
                "*.{ts,js,mjs}": ["eslint --cache --fix"]
            },
            resolutions: {
                "get-pkg-repo": "4.1.1",
                "hosted-git-info": "^2.1.4"
            },
            dependencies: {
                "@babel/runtime": "^7.14.8",
                "@pixi/app": "^7.1.1",
                "@pixi/constants": "^7.1.1",
                "@pixi/core": "^7.1.1",
                "@pixi/display": "^7.1.1",
                "@pixi/extensions": "^7.1.1",
                "@pixi/graphics": "^7.1.1",
                "@pixi/math": "^7.1.1",
                "@pixi/mesh": "^7.1.1",
                "@pixi/mesh-extras": "^7.1.1",
                "@pixi/particle-container": "^7.1.1",
                "@pixi/sprite": "^7.1.1",
                "@pixi/sprite-animated": "^7.1.1",
                "@pixi/sprite-tiling": "^7.1.1",
                "@pixi/text": "^7.1.1",
                "@pixi/text-bitmap": "^7.1.1",
                "@pixi/ticker": "^7.1.1",
                "@react-spring/animated": "^9.6.1",
                "@react-spring/types": "^9.6.1",
                react: "^18.0.0",
                "react-dom": "^18.0.0",
                "react-reconciler": "0.29.0",
                "react-spring": "^9.6.1"
            },
            devDependencies: {
                "@babel/cli": "^7.20.7",
                "@babel/core": "^7.20.7",
                "@babel/eslint-parser": "^7.19.1",
                "@babel/plugin-transform-runtime": "^7.19.6",
                "@babel/preset-env": "^7.20.2",
                "@babel/preset-react": "^7.18.6",
                "@nrwl/nx-cloud": "latest",
                "@pixi/eslint-config": "^4.0.1",
                "@rollup/plugin-alias": "^4.0.2",
                "@rollup/plugin-babel": "^6.0.3",
                "@rollup/plugin-commonjs": "^24.0.0",
                "@rollup/plugin-json": "^6.0.0",
                "@rollup/plugin-node-resolve": "^15.0.1",
                "@rollup/plugin-replace": "^5.0.2",
                "@rollup/plugin-terser": "^0.2.1",
                "@rollup/plugin-typescript": "^10.0.1",
                "@types/jest": "^29.2.4",
                "@types/react": "17.0.15",
                "@types/react-dom": "17.0.9",
                "@types/react-reconciler": "0.28.2",
                "babel-jest": "^29.3.1",
                "babel-plugin-module-resolver": "4.1.0",
                "cross-env": "^7.0.3",
                eslint: "^8.29.0",
                "eslint-plugin-react": "^7.31.11",
                husky: "^8.0.2",
                jest: "^29.3.1",
                "jest-environment-jsdom": "^29.3.1",
                "jest-extended": "^3.2.0",
                "jest-watch-typeahead": "^2.2.1",
                lerna: "^6.0.3",
                "lint-staged": "^13.1.0",
                nx: "15.3.0",
                rimraf: "^3.0.2",
                rollup: "^3.7.0",
                "rollup-plugin-filesize": "^9.1.2",
                "rollup-plugin-visualizer": "^5.9.0",
                "ts-jest": "^29.0.3",
                "ts-node": "^10.9.1",
                typescript: "^4.9.4"
            }
        },
        Rc = {},
        Oo = {
            get exports() {
                return Rc
            },
            set exports(t) {
                Rc = t
            }
        };
    (function() {
        var t, e, r, i, n, a;
        typeof performance < "u" && performance !== null && performance.now ? Oo.exports = function() {
            return performance.now()
        } : typeof process < "u" && process !== null && process.hrtime ? (Oo.exports = function() {
            return (t() - n) / 1e6
        }, e = process.hrtime, i = (t = function() {
            var l;
            return 1e9 * (l = e())[0] + l[1]
        })(), a = 1e9 * process.uptime(), n = i - a) : Date.now ? (Oo.exports = function() {
            return Date.now() - r
        }, r = Date.now()) : (Oo.exports = function() {
            return new Date().getTime() - r
        }, r = new Date().getTime())
    }).call(NS);
    var Yg, Hn = {},
        nn = {};
    ({
        get exports() {
            return Hn
        },
        set exports(t) {
            Hn = t
        }
    }).exports = (Yg || (Yg = 1, nn.ConcurrentRoot = 1, nn.ContinuousEventPriority = 4, nn.DefaultEventPriority = 16, nn.DiscreteEventPriority = 1, nn.IdleEventPriority = 536870912, nn.LegacyRoot = 0), nn);
    var hA = {};

    function Mc(t, e) {
        t.addChild && (t.addChild(e), typeof e.didMount == "function" && e.didMount(e, t))
    }

    function qg(t, e) {
        var r, i, n;
        (r = t.willUnmount) === null || r === void 0 || r.call(t, t, e), ((i = t.config) === null || i === void 0 ? void 0 : i.destroyChildren) !== !1 && (n = t.children) !== null && n !== void 0 && n.length && oi(t.children).forEach(function(a) {
            qg(a, t)
        })
    }

    function Qg(t, e) {
        var r;
        qg(e, t), t.removeChild(e);
        var i = (r = e.config) !== null && r !== void 0 ? r : {},
            n = i.destroy,
            a = n === void 0 || n,
            l = i.destroyChildren,
            h = l === void 0 || l,
            c = i.destroyTexture,
            d = c !== void 0 && c,
            f = i.destroyBaseTexture,
            g = f !== void 0 && f;
        a && e.destroy({
            children: h,
            texture: d,
            baseTexture: g
        })
    }

    function Kg(t, e, r) {
        Yt(e !== r, "pixi-react: PixiFiber cannot insert node before itself"), t.children.indexOf(e) !== -1 && t.removeChild(e);
        var i = t.getChildIndex(r);
        t.addChildAt(e, i)
    }
    var Zg = null,
        Tr = lA({
            getRootHostContext: function() {
                return hA
            },
            getChildHostContext: function(t) {
                return t
            },
            getChildHostContextForEventComponent: function(t) {
                return t
            },
            getPublicInstance: function(t) {
                return t
            },
            getCurrentEventPriority: function() {
                return function() {
                    var t, e;
                    if (typeof window > "u") return Hn.DefaultEventPriority;
                    switch ((t = window) === null || t === void 0 || (e = t.event) === null || e === void 0 ? void 0 : e.type) {
                        case "click":
                        case "contextmenu":
                        case "dblclick":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                            return Hn.DiscreteEventPriority;
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "pointerenter":
                        case "pointerleave":
                        case "wheel":
                            return Hn.ContinuousEventPriority;
                        default:
                            return Hn.DefaultEventPriority
                    }
                }()
            },
            prepareForCommit: function() {
                return null
            },
            resetAfterCommit: function() {},
            createInstance: function(t) {
                var e, r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
                    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
                    a = iA[t];
                if (typeof a == "function" && (e = a(n, i)), !e) {
                    var l = zg[t];
                    l && ((e = l.create(i, {
                        root: n
                    })).didMount = l.didMount ? l.didMount.bind(e) : void 0, e.willUnmount = l.willUnmount ? l.willUnmount.bind(e) : void 0, e.applyProps = l.applyProps ? l.applyProps.bind(e) : void 0, e.config = l.config)
                }
                return e && (e.__reactpixi = {
                    root: n
                }, (typeof((r = e) === null || r === void 0 ? void 0 : r.applyProps) == "function" ? e.applyProps : Gr)(e, {}, i)), e
            },
            hideInstance: function(t) {
                t.visible = !1
            },
            unhideInstance: function(t, e) {
                var r = e == null || !e.hasOwnProperty("visible") || e.visible;
                t.visible = r
            },
            finalizeInitialChildren: function(t, e, r) {
                return !1
            },
            prepareUpdate: function(t, e, r, i, n, a) {
                return Zg = function(l, h, c, d) {
                    var f = null;
                    for (var g in c) !d.hasOwnProperty(g) && c.hasOwnProperty(g) && c[g] !== null && (g === Ac || (f || (f = []), f.push(g, null)));
                    for (var y in d) {
                        var x = d[y],
                            _ = c !== null ? c[y] : void 0;
                        !d.hasOwnProperty(y) || x === _ || x === null && _ === null || y === Ac || (f || (f = []), f.push(y, x))
                    }
                    return f
                }(0, 0, r, i)
            },
            shouldSetTextContent: function(t, e) {
                return !1
            },
            shouldDeprioritizeSubtree: function(t, e) {
                var r = e.alpha === void 0 || e.alpha > 0,
                    i = e.renderable === void 0 || e.renderable === !0,
                    n = e.visible === void 0 || e.visible === !0;
                return !(r && i && n)
            },
            createTextInstance: function(t, e, r) {
                Yt(!1, 'pixi-react: Error trying to add text node "'.concat(t, '"'), "PixiFiber does not support text nodes as children of a Pixi component. To pass a string value to your component, use a property other than children. If you wish to display some text, you can use &lt;Text text={string} /&gt; instead.")
            },
            unhideTextInstance: function(t, e) {},
            mountEventComponent: function() {},
            updateEventComponent: function() {},
            handleEventTarget: function() {},
            scheduleTimeout: setTimeout,
            cancelTimeout: clearTimeout,
            noTimeout: -1,
            warnsIfNotActing: !1,
            now: Rc,
            isPrimaryRenderer: !1,
            supportsMutation: !0,
            supportsPersistence: !1,
            supportsHydration: !1,
            supportsMicrotasks: !0,
            scheduleMicrotask: queueMicrotask,
            appendInitialChild: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Mc.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "appendInitialChild"
                }), a
            },
            appendChild: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Mc.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "appendChild"
                }), a
            },
            appendChildToContainer: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Mc.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "appendChildToContainer"
                }), a
            },
            removeChild: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Qg.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "removeChild"
                }), a
            },
            removeChildFromContainer: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Qg.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "removeChildFromContainer"
                }), a
            },
            insertBefore: Kg,
            insertInContainerBefore: function() {
                for (var t, e, r = arguments.length, i = new Array(r), n = 0; n < r; n++) i[n] = arguments[n];
                var a = Kg.apply(null, i);
                return (t = i[0].__reactpixi) === null || t === void 0 || (e = t.root) === null || e === void 0 || e.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "insertInContainerBefore"
                }), a
            },
            commitUpdate: function(t, e, r, i, n) {
                var a, l, h = t && t.applyProps;
                typeof h != "function" && (h = Gr), (h(t, i, n) || Zg) && ((a = t.__reactpixi) === null || a === void 0 || (l = a.root) === null || l === void 0 || l.emit("__REACT_PIXI_REQUEST_RENDER__", {
                    detail: "commitUpdate"
                }))
            },
            commitMount: function(t, e, r, i, n) {},
            commitTextUpdate: function(t, e, r) {},
            resetTextContent: function(t) {},
            clearContainer: function(t) {},
            getFundamentalComponentInstance: function(t) {
                throw new Error("Not yet implemented.")
            },
            mountFundamentalComponent: function(t) {
                throw new Error("Not yet implemented.")
            },
            shouldUpdateFundamentalComponent: function(t) {
                throw new Error("Not yet implemented.")
            },
            unmountFundamentalComponent: function(t) {
                throw new Error("Not yet implemented.")
            },
            getInstanceFromNode: function(t) {
                throw new Error("Not yet implemented.")
            },
            isOpaqueHydratingObject: function(t) {
                throw new Error("Not yet implemented")
            },
            makeOpaqueHydratingObject: function(t) {
                throw new Error("Not yet implemented.")
            },
            makeClientIdInDEV: function(t) {
                throw new Error("Not yet implemented")
            },
            beforeActiveInstanceBlur: function(t) {},
            afterActiveInstanceBlur: function() {},
            detachDeletedInstance: function() {},
            preparePortalMount: function(t) {}
        }),
        uA = Vg.dependencies["react-dom"].replace(/[^0-9.]/g, ""),
        cA = Vg.name;
    Tr.injectIntoDevTools({
        bundleType: 0,
        version: uA,
        rendererPackageName: cA,
        findHostInstanceByFiber: Tr.findHostInstance
    });
    var Ai = new Map;

    function Jg(t) {
        if (Yt(Kt.prototype.isPrototypeOf(t), "Invalid argument `container`, expected instance of `PIXI.Container`."), Ai.has(t)) {
            var e = Ai.get(t).pixiFiberContainer;
            Tr.updateContainer(null, e, void 0, function() {
                Ai.delete(t)
            })
        }
    }

    function ty(t) {
        Yt(Kt.prototype.isPrototypeOf(t), "Invalid argument `container`, expected instance of `PIXI.Container`.");
        var e = Ai.get(t);
        if (Yt(!e, "Pixi React: createRoot should only be called once"), !e) {
            var r = Tr.createContainer(t);
            e = {
                pixiFiberContainer: r,
                reactRoot: {
                    render: function(i) {
                        return Tr.updateContainer(i, r, void 0), Tr.getPublicRootInstance(r)
                    },
                    unmount: function() {
                        Jg(t), Ai.delete(t)
                    }
                }
            }, Ai.set(t, e)
        }
        return e.reactRoot
    }

    function dA(t, e, r) {
        var i;
        return Ai.has(e) ? i = Ai.get(e).reactRoot : i = ty(e), i.render(t)
    }

    function pA(t) {
        Jg(t)
    }

    function Vs() {
        return Vs = Object.assign ? Object.assign.bind() : function(t) {
            for (var e = 1; e < arguments.length; e++) {
                var r = arguments[e];
                for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
            }
            return t
        }, Vs.apply(this, arguments)
    }

    function fA(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function mA(t, e) {
        for (var r = 0; r < e.length; r++) {
            var i = e[r];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, Og(i.key), i)
        }
    }

    function li(t) {
        if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }

    function Lo(t, e) {
        return Lo = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
            return r.__proto__ = i, r
        }, Lo(t, e)
    }

    function gA(t, e) {
        if (e && (je(e) === "object" || typeof e == "function")) return e;
        if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return li(t)
    }

    function Bo(t) {
        return Bo = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }, Bo(t)
    }
    var ko = Ir.createContext(null),
        ey = ko.Provider,
        ry = ko.Consumer,
        yA = function(t) {
            var e = Ir.forwardRef(function(r, i) {
                return Ir.createElement(ry, null, function(n) {
                    return Ir.createElement(t, Vs({}, r, {
                        ref: i,
                        app: n
                    }))
                })
            });
            return e.displayName = "withPIXIApp(".concat(t.displayName || t.name, ")"), e
        };

    function vA(t) {
        var e = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
            if (typeof Proxy == "function") return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
            } catch (r) {
                return !1
            }
        }();
        return function() {
            var r, i = Bo(t);
            if (e) {
                var n = Bo(this).constructor;
                r = Reflect.construct(i, arguments, n)
            } else r = i.apply(this, arguments);
            return gA(this, r)
        }
    }

    function iy(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(t, n).enumerable
            })), r.push.apply(r, i)
        }
        return r
    }

    function Fo(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e] != null ? arguments[e] : {};
            e % 2 ? iy(Object(r), !0).forEach(function(i) {
                Jt(t, i, r[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : iy(Object(r)).forEach(function(i) {
                Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i))
            })
        }
        return t
    }
    var ny = function() {},
        sy = {
            width: Bt.number,
            height: Bt.number,
            onMount: Bt.func,
            onUnmount: Bt.func,
            raf: Bt.bool,
            renderOnComponentChange: Bt.bool,
            children: Bt.node,
            options: Bt.shape({
                autoStart: Bt.bool,
                width: Bt.number,
                height: Bt.number,
                useContextAlpha: Bt.bool,
                backgroundAlpha: Bt.number,
                autoDensity: Bt.bool,
                antialias: Bt.bool,
                preserveDrawingBuffer: Bt.bool,
                resolution: Bt.number,
                forceCanvas: Bt.bool,
                backgroundColor: Bt.number,
                clearBeforeRender: Bt.bool,
                powerPreference: Bt.string,
                sharedTicker: Bt.bool,
                sharedLoader: Bt.bool,
                resizeTo: function(t, e) {
                    var r = t[e];
                    r && Yt(r === window || r instanceof HTMLElement, "Invalid prop `resizeTo` of type ".concat(je(r), ", expect `window` or an `HTMLElement`."))
                },
                view: function(t, e, r) {
                    var i = t[e];
                    i && Yt(i instanceof HTMLCanvasElement, "Invalid prop `view` of type ".concat(je(i), ", supplied to ").concat(r, ", expected `<canvas> Element`"))
                }
            })
        },
        xA = {
            width: 800,
            height: 600,
            onMount: ny,
            onUnmount: ny,
            raf: !0,
            renderOnComponentChange: !0
        },
        Dc = function(t) {
            (function(a, l) {
                if (typeof l != "function" && l !== null) throw new TypeError("Super expression must either be null or a function");
                a.prototype = Object.create(l && l.prototype, {
                    constructor: {
                        value: a,
                        writable: !0,
                        configurable: !0
                    }
                }), Object.defineProperty(a, "prototype", {
                    writable: !1
                }), l && Lo(a, l)
            })(n, Ir.Component);
            var e, r, i = vA(n);

            function n() {
                var a;
                fA(this, n);
                for (var l = arguments.length, h = new Array(l), c = 0; c < l; c++) h[c] = arguments[c];
                return Jt(li(a = i.call.apply(i, [this].concat(h))), "_canvas", null), Jt(li(a), "_mediaQuery", null), Jt(li(a), "_ticker", null), Jt(li(a), "_needsUpdate", !0), Jt(li(a), "app", null), Jt(li(a), "updateSize", function() {
                    var d = a.props,
                        f = d.width,
                        g = d.height,
                        y = d.options;
                    y != null && y.resolution || (a.app.renderer.resolution = window.devicePixelRatio, a.resetInteractionManager()), a.app.renderer.resize(f, g)
                }), Jt(li(a), "needsRenderUpdate", function() {
                    a._needsUpdate = !0
                }), Jt(li(a), "renderStage", function() {
                    var d = a.props,
                        f = d.renderOnComponentChange;
                    !d.raf && f && a._needsUpdate && (a._needsUpdate = !1, a.app.renderer.render(a.app.stage))
                }), a
            }
            return e = n, (r = [{
                key: "componentDidMount",
                value: function() {
                    var a = this.props,
                        l = a.onMount,
                        h = a.width,
                        c = a.height,
                        d = a.options,
                        f = a.raf,
                        g = a.renderOnComponentChange;
                    this.app = new gn(Fo(Fo({
                        width: h,
                        height: c,
                        view: this._canvas
                    }, d), {}, {
                        autoDensity: (d == null ? void 0 : d.autoDensity) !== !1
                    })), this.app.ticker.autoStart = !1, this.app.ticker[f ? "start" : "stop"](), this.app.stage.__reactpixi = {
                        root: this.app.stage
                    }, this.mountNode = Tr.createContainer(this.app.stage), Tr.updateContainer(this.getChildren(), this.mountNode, this), l(this.app), d != null && d.autoDensity && window.matchMedia && (d == null ? void 0 : d.resolution) === void 0 && (this._mediaQuery = window.matchMedia("(-webkit-min-device-pixel-ratio: 1.3), (min-resolution: 120dpi)"), this._mediaQuery.addListener(this.updateSize)), g && !f && (this._ticker = new Vt, this._ticker.autoStart = !0, this._ticker.add(this.renderStage), this.app.stage.on("__REACT_PIXI_REQUEST_RENDER__", this.needsRenderUpdate)), this.updateSize(), this.renderStage()
                }
            }, {
                key: "componentDidUpdate",
                value: function(a, l, h) {
                    var c, d = this.props,
                        f = d.width,
                        g = d.height,
                        y = d.raf,
                        x = d.renderOnComponentChange,
                        _ = d.options;
                    (_ == null ? void 0 : _.resolution) !== void 0 && (a == null ? void 0 : a.options.resolution) !== (_ == null ? void 0 : _.resolution) && (this.app.renderer.resolution = _.resolution, this.resetInteractionManager()), a.height === g && a.width === f && ((c = a.options) === null || c === void 0 ? void 0 : c.resolution) === (_ == null ? void 0 : _.resolution) || this.updateSize(), a.raf !== y && this.app.ticker[y ? "start" : "stop"](), Tr.updateContainer(this.getChildren(), this.mountNode, this), a.width === f && a.height === g && a.raf === y && a.renderOnComponentChange === x && a.options === _ || (this._needsUpdate = !0, this.renderStage())
                }
            }, {
                key: "resetInteractionManager",
                value: function() {
                    var a = this.app.renderer.plugins.interaction;
                    a != null && a.resolution && (a.resolution = this.app.renderer.resolution)
                }
            }, {
                key: "getChildren",
                value: function() {
                    var a = this.props.children;
                    return Ir.createElement(ey, {
                        value: this.app
                    }, a)
                }
            }, {
                key: "componentDidCatch",
                value: function(a, l) {}
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.props.onUnmount(this.app), this._ticker && (this._ticker.remove(this.renderStage), this._ticker.destroy()), this.app.stage.off("__REACT_PIXI_REQUEST_RENDER__", this.needsRenderUpdate), Tr.updateContainer(null, this.mountNode, this), this._mediaQuery && (this._mediaQuery.removeListener(this.updateSize), this._mediaQuery = null), this.app.destroy()
                }
            }, {
                key: "render",
                value: function() {
                    var a, l, h = this,
                        c = this.props.options;
                    return c && c.view ? (Yt(c.view instanceof HTMLCanvasElement, "options.view needs to be a `HTMLCanvasElement`"), null) : Ir.createElement("canvas", Vs({}, (a = this.props, l = [].concat(oi(Object.keys(sy)), oi(Object.keys(Pc))), Object.keys(a).filter(function(d) {
                        return !l.includes(d)
                    }).reduce(function(d, f) {
                        return Fo(Fo({}, d), {}, Jt({}, f, a[f]))
                    }, {})), {
                        ref: function(d) {
                            return h._canvas = d
                        }
                    }))
                }
            }]) && mA(e.prototype, r), Object.defineProperty(e, "prototype", {
                writable: !1
            }), n
        }();
    Dc.propTypes = sy, Dc.defaultProps = xA;
    var _A = Dc;

    function ay() {
        var t = Ee.useContext(ko);
        return Yt(t instanceof gn, "No Context found with `%s`. Make sure to wrap component with `%s`", "PIXI.Application", "AppProvider"), t
    }

    function bA(t) {
        var e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            r = ay();
        Yt(typeof t == "function", "`useTick` needs a callback function."), Yt(r instanceof gn, "No Context found with `%s`. Make sure to wrap component with `%s`", "PIXI.Application", "AppProvider");
        var i = Ee.useRef(null);
        Ee.useEffect(function() {
            i.current = t
        }, [t]), Ee.useEffect(function() {
            if (e) {
                var n = function(a) {
                    return i.current.apply(r.ticker, [a, r.ticker])
                };
                return r.ticker.add(n),
                    function() {
                        r.ticker && r.ticker.remove(n)
                    }
            }
        }, [e])
    }

    function EA() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
        } catch (t) {
            return !1
        }
    }

    function Nc(t, e, r) {
        return Nc = EA() ? Reflect.construct.bind() : function(i, n, a) {
            var l = [null];
            l.push.apply(l, n);
            var h = new(Function.bind.apply(i, l));
            return a && Lo(h, a.prototype), h
        }, Nc.apply(null, arguments)
    }
    var TA = ["children", "apply"];

    function oy(t, e) {
        var r = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(t);
            e && (i = i.filter(function(n) {
                return Object.getOwnPropertyDescriptor(t, n).enumerable
            })), r.push.apply(r, i)
        }
        return r
    }

    function Uo(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e] != null ? arguments[e] : {};
            e % 2 ? oy(Object(r), !0).forEach(function(i) {
                Jt(t, i, r[i])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : oy(Object(r)).forEach(function(i) {
                Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i))
            })
        }
        return t
    }
    var wA = function(t, e) {
            Yt(je(e) === "object", "Second argument needs to be an indexed object with { prop: Filter }");
            var r = Object.keys(e),
                i = function(n) {
                    var a = n.children,
                        l = n.apply,
                        h = Si(n, TA),
                        c = Ee.useRef(Ee.useMemo(function() {
                            return r.map(function(g) {
                                var y, x = (h == null || (y = h[g]) === null || y === void 0 ? void 0 : y.construct) || [];
                                return Nc(e[g], oi(x))
                            })
                        }, [r])),
                        d = Ee.useMemo(function() {
                            return r.reduce(function(g, y, x) {
                                return Uo(Uo({}, g), {}, Jt({}, y, c.current[x]))
                            }, {})
                        }, [r]),
                        f = Ee.useMemo(function() {
                            return Object.keys(h).filter(kg(Bg(r))).reduce(function(g, y) {
                                return Uo(Uo({}, g), {}, Jt({}, y, h[y]))
                            }, {})
                        }, [h, r]);
                    return r.forEach(function(g, y) {
                        return Object.assign(c.current[y], h[g])
                    }), l && function() {
                        for (var g = arguments.length, y = new Array(g), x = 0; x < g; x++) y[x] = arguments[x];
                        return y.every(function(_) {
                            return typeof _ == "function"
                        })
                    }(l) && l.call(t, d), Ir.createElement(t, Vs({}, f, {
                        filters: c.current
                    }), a)
                };
            return i.displayName = "FilterWrapper", i.propTypes = {
                children: Bt.node,
                apply: Bt.func
            }, i
        },
        SA = Le.BitmapText,
        AA = Le.Container,
        PA = Le.Graphics,
        CA = Le.NineSlicePlane,
        IA = Le.ParticleContainer,
        RA = Le.Sprite,
        MA = Le.AnimatedSprite,
        DA = Le.Text,
        NA = Le.TilingSprite,
        OA = Le.SimpleMesh,
        LA = Le.SimpleRope;
    const BA = Object.freeze(Object.defineProperty({
            __proto__: null,
            AnimatedSprite: MA,
            AppConsumer: ry,
            AppContext: ko,
            AppProvider: ey,
            BitmapText: SA,
            Container: AA,
            Graphics: PA,
            NineSlicePlane: CA,
            ParticleContainer: IA,
            PixiComponent: nA,
            PixiFiber: Tr,
            SimpleMesh: OA,
            SimpleRope: LA,
            Sprite: RA,
            Stage: _A,
            TYPES: Le,
            Text: DA,
            TilingSprite: NA,
            applyDefaultProps: Gr,
            createRoot: ty,
            eventHandlers: Do,
            render: dA,
            unmountComponentAtNode: pA,
            useApp: ay,
            useTick: bA,
            withFilters: wA,
            withPixiApp: yA
        }, Symbol.toStringTag, {
            value: "Module"
        })),
        kA = Af(BA);
    Rg.exports = kA, vs = Rg.exports;
    let ly;
    ly = ka(vs), lv = vv({
        __proto__: null,
        default: ly
    }, [vs]);
    class FA extends Kt {
        constructor(e, r) {
            super(), ie(this, "particles"), wh(e) ? e = Q.from(e) : nv(e) && wh(e[0]) && (e = e.map(i => Q.from(i))), this.particles = new It(this, Ig(r, e))
        }
    }
    av = vs.PixiComponent("Particles", {
        create({
            textures: t,
            config: e,
            emit: r = !0
        }) {
            const i = new FA(t, e);
            return i.particles.emit = r, i
        },
        willUnmount(t) {
            t.particles.destroy()
        },
        applyProps(t, e, {
            textures: r,
            config: i,
            emit: n = !0
        }) {
            t.particles.destroy(), t.particles = new It(t, Ig(i, r)), t.particles.emit = n, t.particles.autoUpdate = !0
        }
    }), yp = class {
        constructor(t = 0) {
            ie(this, "elems", []), ie(this, "freeElems", []), ie(this, "size"), this.size = t;
            for (let e = 0; e < t; e++) this.expand()
        }
        get freeNum() {
            return this.freeElems.length
        }
        get() {
            this.freeElems.length == 0 && this.expand();
            let t = this.freeElems.pop();
            return this.elems[t]
        }
        put(t) {
            let e = this.elems.indexOf(t);
            e !== -1 && this.freeElems.push(e)
        }
        expand() {
            this.size++, this.freeElems.push(this.elems.push(this.createElement()) - 1)
        }
    };
    class UA extends yp {
        createElement() {
            const e = vh({
                resolution: window.devicePixelRatio,
                autoDensity: !0,
                backgroundAlpha: 0
            });
            return e.plugins.interaction.autoPreventDefault = !1, e.view.style && (e.view.style.touchAction = "auto"), e
        }
    }
    const hy = class La {
        constructor({
            width: e = 600,
            height: r = 400,
            fps: i = 60
        } = {}) {
            ie(this, "stage", new Kt), ie(this, "ticker", new Vt), ie(this, "loader", mn), ie(this, "renderer"), this.renderer = La.rendererPool.get(), this.renderer.resize(e, r), this.render = this.render.bind(this), this.ticker.autoStart = !0, this.ticker.maxFPS = i, this.ticker.add(this.render), this.render()
        }
        get view() {
            return this.renderer.view
        }
        get screen() {
            return this.renderer.screen
        }
        render() {
            this.renderer.render(this.stage)
        }
        destroy(e = !0) {
            this.ticker.destroy(), this.loader.reset(), this.stage.destroy(e ? {
                children: !0,
                texture: !0,
                baseTexture: !0
            } : void 0), this.ticker = null, this.loader = null, this.stage = null, La.rendererPool.put(this.renderer), this.tryGC()
        }
        tryGC() {
            if (La.rendererPool.freeNum == La.rendererPool.size) {
                for (let e in ve) ve[e].destroy();
                for (let e in Me) Me[e].destroy()
            }
        }
    };
    ie(hy, "rendererPool", new UA), pp = hy;
    let Oc;
    Oc = Ee.createContext({}), ov = Ir.memo(Ir.forwardRef(function({
        width: t = 600,
        height: e = 400,
        fps: r = 60,
        children: i
    }, n) {
        const a = Ee.useRef(null),
            l = Ee.useRef(null),
            [h] = Ee.useState(() => new pp({
                width: t,
                height: e
            })),
            c = d => {
                n && (typeof n == "function" ? n(d) : n.current = d)
            };
        return Ee.useLayoutEffect(() => {
            const d = a.current;
            if (!d) return;
            const f = d.parentNode;
            f.replaceChild(h.renderer.view, d);
            const g = vs.createRoot(h.stage);
            return l.current = g, c(h), () => {
                c(null), f.replaceChild(d, h.renderer.view), h.destroy(!1), g.unmount()
            }
        }, []), Ee.useLayoutEffect(() => {
            const d = l.current;
            d && d.render(i || null)
        }, [i]), Ee.useEffect(() => {
            h.renderer.resize(t, e), h.ticker.maxFPS = r
        }), iv.jsx(Oc.Provider, {
            value: h,
            children: iv.jsx("div", {
                ref: a
            })
        })
    })), gv = function() {
        return Ee.useContext(Oc)
    }, pv = Ee.lazy(() => cC(() =>
        import ("./chunk-cb552c6e.js").then(async t => (await t.__tla, t)), ["assets/chunk-cb552c6e.js", "assets/chunk-a4af42e8.js", "assets/chunk-73e80d68.js", "assets/chunk-cf010ec4.js", "assets/chunk-64278058.js"]))
});
export {
    Zd as $, ma as A, Re as B, Kt as C, ga as D, Zr as E, ss as F, ya as G, Rl as H, as as I, Ml as J, Jd as K, tp as L, Dl as M, ep as N, dr as O, Ye as P, rp as Q, va as R, mn as S, Ft as T, Nl as U, gn as V, pi as W, yn as X, ip as Y, Zt as Z, Ol as _, mC as __tla, Ll as a, np as a$, Bl as a0, Z as a1, kl as a2, V as a3, sp as a4, ap as a5, op as a6, os as a7, ls as a8, qe as a9, Fl as aA, pr as aB, ee as aC, fr as aD, Wt as aE, sv as aF, lp as aG, Ul as aH, Ut as aI, Fi as aJ, hp as aK, hs as aL, vn as aM, Gl as aN, up as aO, cp as aP, us as aQ, zl as aR, Jr as aS, cs as aT, Ge as aU, dp as aV, Hl as aW, av as aX, pp as aY, ov as aZ, lv as a_, Ui as aa, xa as ab, ae as ac, fp as ad, jl as ae, _a as af, Wl as ag, ba as ah, mp as ai, gp as aj, Ea as ak, hv as al, Xl as am, fi as an, $l as ao, ti as ap, Ta as aq, Vl as ar, uv as as, wa as at, Oe as au, ds as av, xn as aw, Yl as ax, mi as ay, Qe as az, ql as b, Ql as b$, Kl as b0, gt as b1, _n as b2, yp as b3, Zl as b4, Ke as b5, Jl as b6, vp as b7, th as b8, xp as b9, eh as bA, ei as bB, rh as bC, ih as bD, _p as bE, Gi as bF, ps as bG, dt as bH, nh as bI, bp as bJ, Ep as bK, fs as bL, ms as bM, oe as bN, gi as bO, Q as bP, Ze as bQ, Sa as bR, sh as bS, ah as bT, Vt as bU, oh as bV, lh as bW, hh as bX, cv as bY, gs as bZ, dv as b_, uh as ba, Tp as bb, bt as bc, yi as bd, ch as be, dh as bf, zi as bg, ph as bh, bn as bi, wp as bj, fh as bk, ze as bl, Aa as bm, Rr as bn, le as bo, En as bp, mh as bq, Mr as br, gh as bs, Sp as bt, Ap as bu, Pp as bv, pv as bw, Dr as bx, Cp as by, Pa as bz, ut as c, vi as c0, mr as c1, fv as c2, Ca as c3, yh as c4, Ia as c5, Nr as c6, Ra as c7, Ma as c8, Ip as c9, mv as cA, Gt as cB, gr as cC, ys as cD, Rp as cE, Mp as cF, Dp as cG, Np as cH, Op as cI, Lp as cJ, Tn as cK, Bp as cL, kp as cM, Fp as cN, Up as cO, Gp as cP, zp as cQ, et as cR, Hp as cS, Hi as cT, jp as cU, gv as cV, yv as cW, vs as cX, Wp as cY, xi as cZ, Xp as ca, vh as cb, xh as cc, $p as cd, _h as ce, xs as cf, Vp as cg, Or as ch, Da as ci, Yp as cj, _s as ck, qp as cl, _i as cm, bh as cn, Qp as co, Kp as cp, Zp as cq, Jp as cr, tf as cs, lt as ct, Eh as cu, ef as cv, rf as cw, nf as cx, sf as cy, af as cz, Je as d, Th as e, of as f, Na as g, Oa as h, wh as i, Sh as j, bs as k, lf as l, mt as m, hf as n, Ah as o, Ph as p, yr as q, uf as r, cf as s, df as t, wn as u, pf as v, Ch as w, tr as x, ji as y, Es as z
};