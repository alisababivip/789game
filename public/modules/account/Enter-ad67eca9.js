import {
    r as q,
    _ as v
} from "./_bc_ui_share-16017657.js";
import {
    R as de,
    r as Se
} from "./react_share-ba7e619d.js";
import {
    l as ct
} from "./lodash_es_share-b99bc9c1.js";
import {
    n as dt,
    e as gt,
    Q as ft,
    c as Le,
    k as wt,
    w as mt,
    Y as yt,
    _ as St,
    g as j,
    p as le,
    u as Et,
    o as Re,
    y as U,
    U as ne,
    x as xe,
    z as _t,
    A as It,
    i as we,
    a as me,
    M as Rt,
    D as Nt,
    B as Ve,
    f as vt,
    C as Ee,
    E as Ne,
    v as We,
    j as ke,
    G as oe,
    N as L,
    F as ve,
    H as qt,
    I as Je,
    J as Ct,
    O as $e,
    P as Ye,
    R as qe,
    W as Lt,
    S as xt,
    T as Ot,
    V as Xe,
    X as Pt,
    Z as Dt,
    t as Tt,
    $ as At,
    a0 as Mt,
    a1 as Vt,
    a2 as kt,
    b as $t,
    d as Ut,
    a3 as bt,
    a4 as jt,
    a5 as Ze,
    a6 as Ft,
    q as He,
    a7 as Oe,
    l as Gt,
    m as Bt,
    a8 as zt
} from "./index-76559910.js";
const Ht = de.memo(function() {
    return q.jsxs("svg", {
        width: "12",
        height: "12",
        viewBox: "0 0 10 11",
        xmlns: "http://www.w3.org/2000/svg",
        className: "icon",
        children: [q.jsx("path", {
            d: "M6.8619 3.38909C6.37169 2.93243 5.70412 2.67872 5.02615 2.68886C3.77446 2.68886 2.72093 3.50068 2.33502 4.60677L0.749573 3.40937C1.56315 1.83647 3.21119 0.841974 5.02615 0.841974C6.21523 0.831834 7.36257 1.25803 8.22834 2.04957L6.8619 3.38909Z"
        }), q.jsx("path", {
            d: "M2.3347 6.39258C2.13649 5.81418 2.13665 5.18503 2.33485 4.60658L0.749407 3.40918C0.0713866 4.72837 0.0712314 6.28098 0.749252 7.59003C1.56283 9.16293 3.21103 10.1574 5.02598 10.1574C6.3159 10.1574 7.39831 9.74346 8.19046 9.03657L8.19682 9.04135C9.10425 8.21928 9.62582 7.02188 9.62582 5.61133C9.62582 5.29678 9.59451 4.97204 9.54236 4.66763H5.02588V6.46376H7.61271C7.5084 7.04221 7.1643 7.54952 6.65329 7.87426C6.22567 8.15839 5.67265 8.32053 5.02598 8.32053C3.7743 8.32053 2.72076 7.49867 2.33485 6.40272L0.751787 7.58806L2.3347 6.39258Z"
        })]
    })
});
de.memo(function() {
    return q.jsx("svg", {
        width: "12",
        height: "12",
        viewBox: "0 0 7 11",
        xmlns: "http://www.w3.org/2000/svg",
        className: "icon",
        children: q.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M4.73953 10.9526V5.94653H6.31494L6.6145 4.04838H4.73953V2.8166C4.73953 2.29728 5.00132 1.79111 5.84154 1.79111H6.69366V0.175107C6.69366 0.175107 5.92018 0.046875 5.18033 0.046875C3.63649 0.046875 2.62709 0.955939 2.62709 2.60169V4.04838H0.91095V5.94653H2.62709V10.9526H4.73953Z"
        })
    })
});
const Kt = de.memo(function() {
        return q.jsx("svg", {
            width: "12",
            height: "12",
            viewBox: "0 0 10 9",
            xmlns: "http://www.w3.org/2000/svg",
            className: "tel icon",
            children: q.jsx("path", {
                d: "M0.631267 4.23359L8.94963 0.522088C9.26472 0.381636 9.63257 0.52552 9.77174 0.843552C9.82141 0.956236 9.83693 1.08093 9.81624 1.20277L8.70026 7.90193C8.63145 8.31346 8.24549 8.59114 7.83779 8.52187C7.7219 8.50206 7.6117 8.45479 7.51702 8.38397L4.70353 6.27916C4.42674 6.07231 4.36827 5.6781 4.57367 5.39854C4.59695 5.36641 4.62386 5.33651 4.65335 5.30942L7.47408 2.69548C7.49943 2.67187 7.50098 2.6322 7.4777 2.6064C7.45752 2.58436 7.42441 2.57962 7.39854 2.59569L3.11829 5.27286C2.96256 5.36984 2.77269 5.39345 2.59885 5.33677L0.655584 4.70362C0.52417 4.66082 0.452255 4.51881 0.49468 4.38657C0.51641 4.31856 0.566078 4.2625 0.631267 4.23354V4.23359Z"
            })
        })
    }),
    Qt = de.memo(function() {
        return q.jsx("svg", {
            width: "12",
            height: "12",
            viewBox: "0 0 12 12",
            xmlns: "http://www.w3.org/2000/svg",
            className: "icon",
            children: q.jsx("path", {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M0.614979 0.00163379C0.625651 -0.00178505 0.637657 0.000226031 0.646994 0.00706371L0.745707 0.0805353L4.39007 1.43949C4.3914 1.43661 4.39273 1.43386 4.39474 1.43125C4.4014 1.42173 4.41208 1.4161 4.42408 1.4161H7.58155C7.59289 1.4161 7.60423 1.42179 7.6109 1.43131C7.61223 1.43346 7.61356 1.43567 7.61423 1.43802L11.2486 0.0811386L11.3486 0.00706371C11.358 0.000226031 11.37 -0.00178505 11.3806 0.00163379C11.392 0.00505263 11.4007 0.0134992 11.404 0.024359L11.9983 1.79612C12.0003 1.80202 12.0003 1.80846 11.9996 1.81456L11.6061 3.69988L11.8362 3.8733C11.8449 3.88001 11.8502 3.89046 11.8502 3.90153C11.8502 3.91265 11.8449 3.92311 11.8362 3.92988L11.4987 4.18703L11.7522 4.38311C11.7608 4.38955 11.7655 4.39927 11.7662 4.40973C11.7668 4.42018 11.7622 4.43037 11.7548 4.43741L11.4127 4.7492L11.6108 4.89192C11.6194 4.89775 11.6241 4.90666 11.6254 4.91652C11.6268 4.92637 11.6234 4.93629 11.6174 4.94387L11.0878 5.55953L11.9049 8.07466C11.9089 8.08545 11.9069 8.09732 11.9002 8.10657C11.8936 8.11575 11.8822 8.12118 11.8709 8.12118H11.8602L11.1079 10.6706L8.45595 9.94175L7.94172 10.362L6.8939 11.0865H5.1024L4.05925 10.362L3.66039 10.0359L3.52967 9.97392C3.51966 9.96937 3.51299 9.96085 3.51032 9.95093L0.892442 10.6706L0.134756 8.08552L0.937796 5.58587C0.931126 5.58393 0.925123 5.58018 0.921122 5.57481L0.382872 4.94374C0.376202 4.93616 0.373534 4.92631 0.374868 4.91645C0.375535 4.9066 0.380871 4.89768 0.388874 4.89192L0.587633 4.7492L0.245474 4.43741C0.238138 4.43037 0.233469 4.42032 0.234136 4.40986C0.234136 4.39947 0.239472 4.38975 0.247475 4.38325L0.496925 4.18723L0.159434 3.92988C0.150097 3.92311 0.144761 3.91259 0.145428 3.90139C0.145428 3.89026 0.150764 3.87974 0.159434 3.8731L0.393543 3.69968L0.000694001 1.81456C-0.000639952 1.80846 2.70248e-05 1.80209 0.00202795 1.79619L0.591635 0.0244261C0.59497 0.0135662 0.603641 0.00505263 0.614979 0.00163379ZM3.73509 2.53967L4.75092 3.30687L4.33471 3.67537L3.27949 4.567L1.14966 5.18967L0.711109 4.67494L0.889232 4.54649C0.896874 4.54094 0.902165 4.53231 0.902165 4.52286C0.902753 4.51347 0.899226 4.50431 0.892171 4.49793L0.589421 4.22207L0.812222 4.04712C0.819864 4.04109 0.823979 4.03194 0.823979 4.02231C0.823979 4.01262 0.819276 4.00352 0.811634 3.99761L0.51535 3.77156L0.704054 3.63153C0.714048 3.62426 0.718751 3.61197 0.7164 3.60004L0.367796 1.92721L0.87042 0.415094L3.73509 2.53967ZM10.8432 5.18626L11.2852 4.67221L11.1074 4.54401C11.0991 4.53847 11.0945 4.52985 11.0939 4.52041C11.0933 4.51103 11.0974 4.50189 11.1044 4.49552L11.4061 4.22023L11.1802 4.04554C11.1725 4.03959 11.1678 4.03038 11.1684 4.02071C11.1684 4.01097 11.1725 4.00183 11.1807 3.99593L11.4772 3.76997L11.2917 3.63026C11.2823 3.62295 11.2776 3.61073 11.2799 3.59894L11.628 1.92861L11.122 0.418512L7.24491 3.29416L7.81665 3.80419L8.71593 4.56437L10.8432 5.18626ZM5.04102 7.42137L4.65751 6.60802L3.75442 7.01862C3.75643 7.02284 3.75776 7.02747 3.75776 7.03223L3.75843 7.04402L5.04102 7.42137ZM5.32045 9.03574L5.15504 9.14957C5.16038 9.15661 5.16238 9.16532 5.16171 9.17417L5.04966 10.1639L5.11636 10.0999H6.87984L6.9959 10.2021L6.87451 9.20528C6.86584 9.20622 6.85716 9.20421 6.84983 9.19918L6.63373 9.05089H5.3498C5.33779 9.05089 5.32712 9.04493 5.32045 9.03574ZM8.23372 7.01098L6.98714 7.37626L6.9858 7.36654L7.34797 6.60802L8.23372 7.01098Z"
            })
        })
    }),
    Wt = de.memo(function() {
        return q.jsx("svg", {
            width: "16",
            height: "16",
            viewBox: "0 0 13 9",
            xmlns: "http://www.w3.org/2000/svg",
            className: "icon",
            children: q.jsx("path", {
                fillRule: "evenodd",
                clipRule: "evenodd",
                d: "M11.4289 3.91921L12.1201 4.58746C12.2153 4.67825 12.2153 4.82718 12.1201 4.91797L9.00652 7.93605C8.91132 8.02685 8.75766 8.02685 8.66608 7.93605L6.45637 5.79324C6.43412 5.77145 6.39429 5.77145 6.37204 5.79324L4.16233 7.93605C4.06713 8.02685 3.91347 8.02685 3.82189 7.93605L0.697462 4.91797C0.602265 4.82718 0.602265 4.67825 0.697462 4.58746L1.38868 3.91921C1.48387 3.82842 1.63753 3.82842 1.72911 3.91921L3.93882 6.06203C3.96107 6.08381 4.00142 6.08381 4.02315 6.06203L6.23287 3.91921C6.32806 3.82842 6.48172 3.82842 6.5733 3.91921L8.78353 6.06203C8.80526 6.08381 8.84561 6.08381 8.86734 6.06203L11.0776 3.91921C11.18 3.82842 11.3337 3.82842 11.4289 3.91921ZM2.9949 2.36498C4.87918 0.53817 7.93791 0.53817 9.82219 2.36498L10.0493 2.58655C10.144 2.67735 10.144 2.82627 10.0493 2.91707L9.27326 3.66883C9.22566 3.71605 9.14909 3.71605 9.10149 3.66883L8.79054 3.36739C7.47331 2.09261 5.34379 2.09261 4.02655 3.36739L3.69388 3.69062C3.64628 3.73783 3.56919 3.73783 3.52159 3.69062L2.74604 2.93885C2.65085 2.84806 2.65085 2.69913 2.74604 2.60834L2.9949 2.36498Z"
            })
        })
    });
de.memo(function() {
    return q.jsx("svg", {
        width: "13",
        height: "13",
        viewBox: "0 0 15 15",
        xmlns: "http://www.w3.org/2000/svg",
        className: "icon",
        children: q.jsx("path", {
            d: "M7.2 0a7 7 0 0 0-5.67 11.1l-.87 2.6 2.7-.86A7 7 0 1 0 7.2 0Zm4.08 9.88c-.17.48-.84.88-1.38 1-.36.07-.84.13-2.45-.53-2.06-.86-3.38-2.95-3.49-3.08-.1-.14-.83-1.1-.83-2.11 0-1 .51-1.5.72-1.7.17-.18.45-.26.71-.26h.24c.2.02.3.03.44.36l.63 1.51c.05.1.1.24.03.38-.06.14-.12.2-.22.32s-.2.21-.3.34c-.1.1-.21.23-.1.43.13.2.54.88 1.14 1.41.79.7 1.42.92 1.65 1.02.17.07.37.05.49-.08.16-.17.35-.45.55-.73.14-.2.31-.22.5-.15s1.19.56 1.4.66c.2.1.34.16.38.24.05.09.05.5-.12.97Z"
        })
    })
});
const Jt = de.memo(function() {
        return q.jsx("svg", {
            width: "14",
            height: "14",
            className: "icon",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 1024 1024",
            children: q.jsx("path", {
                d: "M972.55 409.27h.01l-.29-2.37-.01-.12-.01-.1-1.08-8.91-.74-6.16-.23-1.86-.46.06c-11.29-64.2-42.3-125.13-90.32-177.14-47.8-51.78-109.9-92.65-179.6-118.21-59.7-21.9-123.06-33.01-188.3-33.01-88.07 0-173.6 20.7-247.34 59.9C121.97 196.9 38.1 335.78 50.5 475.16c6.41 72.12 34.67 140.78 81.71 198.55 44.28 54.37 104.18 98.25 173.22 126.89 42.45 17.6 84.42 25.9 128.86 34.69l5.2 1.03c12.23 2.42 15.53 5.75 16.37 7.06 1.57 2.45.75 7.27.12 9.93-.58 2.45-1.18 4.9-1.78 7.34-4.77 19.46-9.7 39.58-5.83 61.77 4.46 25.5 20.39 40.13 43.7 40.13 25.08 0 53.62-16.82 72.5-27.95l2.52-1.48c45.06-26.46 87.5-56.3 119.44-79.34 69.9-50.43 149.12-107.6 208.52-181.54 59.81-74.48 87.98-170.19 77.5-262.97zm-635.07 141.1h-79.84a21.85 21.85 0 0 1-21.84-21.84V360.96a21.85 21.85 0 0 1 43.69 0v145.73h57.99a21.85 21.85 0 0 1 0 43.69zm83.29-22.43a21.85 21.85 0 0 1-43.7 0V360.36a21.85 21.85 0 0 1 43.7 0v167.58zm197.46 0a21.85 21.85 0 0 1-39.52 12.83l-78.67-108.34v95.51a21.85 21.85 0 0 1-43.69 0V365.16a21.85 21.85 0 0 1 39.53-12.84l78.66 108.35v-100.3a21.85 21.85 0 0 1 43.7 0v167.57zm159.19 18.4H669.3a21.85 21.85 0 0 1-21.85-21.84V356.92a21.85 21.85 0 0 1 21.85-21.84h104.76a21.85 21.85 0 0 1 0 43.69h-82.91v40.1h67.29a21.85 21.85 0 0 1 0 43.69h-67.3v40.1h86.28a21.85 21.85 0 0 1 0 43.68z"
            })
        })
    }),
    Yt = de.memo(function() {
        return q.jsxs("svg", {
            width: "12",
            height: "12",
            className: "icon",
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 16 16",
            children: [q.jsx("g", {
                clipPath: "url(#a)",
                children: q.jsx("path", {
                    d: "M16 8A8 8 0 0 1 .17 9.642l3.177 1.335a2.098 2.098 0 0 0 4.154-.396l.004-.002 2.402-1.79a2.727 2.727 0 1 0 .031-5.456A2.728 2.728 0 0 0 7.211 6.01l-1.76 2.462a2.068 2.068 0 0 0-1.194.34L.061 7.048C.533 3.079 3.905 0 8 0a8 8 0 0 1 8 8ZM4.949 11.651l-1.03-.432a1.62 1.62 0 0 0 3.106-.665 1.627 1.627 0 0 0-1.621-1.607c-.191 0-.38.033-.573.106l1.028.432a1.174 1.174 0 0 1-.91 2.166Zm4.989-3.734a1.857 1.857 0 0 1-1.854-1.855c0-1.023.832-1.855 1.854-1.855 1.023 0 1.854.832 1.854 1.855a1.857 1.857 0 0 1-1.854 1.855Zm0-.455a1.401 1.401 0 1 0-.002-2.802 1.401 1.401 0 0 0 .002 2.802Z"
                })
            }), q.jsx("defs", {
                children: q.jsx("clipPath", {
                    id: "a",
                    children: q.jsx("path", {
                        d: "M0 0h16v16H0z"
                    })
                })
            })]
        })
    }),
    Xt = ct.once(() => v.utils.loadScript("https://accounts.google.com/gsi/client")),
    Zt = () => {
        const S = document.createElement("div");
        S.style.display = "none", S.classList.add("custom-google-button"), document.body.appendChild(S), window.google && window.google.accounts.id.renderButton(S, {
            theme: "filled_blue"
        });
        const o = S.querySelector("div[role=button]");
        return {
            click: () => {
                o && o.click()
            }
        }
    };
async function ei(S) {
    try {
        await Xt(), window.google && window.google.accounts.id.initialize({
            client_id: v.env.GOOGLE_KEY,
            callback: o => {
                let t = o.credential.split(".");
                const i = JSON.parse(decodeURIComponent(encodeURI(window.atob(t[1].replace(/-/g, "+").replace(/_/g, "/")))));
                S && S({
                    fullName: i.name,
                    idToken: o.credential,
                    openUserId: i.sub,
                    picture: i.picture
                })
            }
        })
    } catch (o) {
        console.log(o)
    }
}
async function et(S) {
    const o = await v.http.post("/account/open/login-callback/", S);
    return v.app.emit("signin-success"), o
}
async function Ue(S, o) {
    const t = window.open("", "_blank", "resizable=no,scrollbars=no,status=no,width=420,height=680,location=no");
    let i = await ti(S);
    return S === "line" && (i += `?invitationCode=${o}`), new Promise((e, c) => {
        if (!t) return;
        const w = m => {
            if (m.source === t) try {
                let y;
                S === "steam" || S === "line" ? y = m.data : (y = JSON.parse(m.data), S === "telegram" && (y = y.result, y.id = String(y.id), y.auth_date = String(y.auth_date))), e(y), t == null || t.close()
            } catch (y) {
                c(y)
            } finally {
                window.removeEventListener("message", w)
            }
        };
        window.addEventListener("message", w), t.location.href = i
    })
}
async function ti(S) {
    return S === "steam" ? await v.http.get("/account/steam/login/url/") : S === "telegram" ? `https://oauth.telegram.org/auth?bot_id=${await v.http.post("/account/open/telegram/botid/")}&origin=${encodeURIComponent(location.origin)}&request_access=write` : S === "line" ? `${location.origin}/api/account/open/line/oauth/` : ""
}
async function tt() {
    return v.http.get("/account/wallet/login/message/")
}
async function it(S) {
    const o = await v.http.post("/account/wallet/login/varify/", S);
    return v.app.emit("signin-success"), o
}
var ii = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    be = Math.ceil,
    se = Math.floor,
    X = "[BigNumber Error] ",
    st = X + "Number primitive has more than 15 significant digits: ",
    ae = 1e14,
    x = 14,
    je = 9007199254740991,
    Fe = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    fe = 1e7,
    H = 1e9;

function lt(S) {
    var o, t, i, e = _.prototype = {
            constructor: _,
            toString: null,
            valueOf: null
        },
        c = new _(1),
        w = 20,
        m = 4,
        y = -7,
        I = 21,
        T = -1e7,
        P = 1e7,
        O = !1,
        k = 1,
        $ = 0,
        Y = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: " ",
            suffix: ""
        },
        Z = "0123456789abcdefghijklmnopqrstuvwxyz",
        K = !0;

    function _(s, r) {
        var n, d, l, p, f, a, h, g, u = this;
        if (!(u instanceof _)) return new _(s, r);
        if (r == null) {
            if (s && s._isBigNumber === !0) {
                u.s = s.s, !s.c || s.e > P ? u.c = u.e = null : s.e < T ? u.c = [u.e = 0] : (u.e = s.e, u.c = s.c.slice());
                return
            }
            if ((a = typeof s == "number") && s * 0 == 0) {
                if (u.s = 1 / s < 0 ? (s = -s, -1) : 1, s === ~~s) {
                    for (p = 0, f = s; f >= 10; f /= 10, p++);
                    p > P ? u.c = u.e = null : (u.e = p, u.c = [s]);
                    return
                }
                g = String(s)
            } else {
                if (!ii.test(g = String(s))) return i(u, g, a);
                u.s = g.charCodeAt(0) == 45 ? (g = g.slice(1), -1) : 1
            }(p = g.indexOf(".")) > -1 && (g = g.replace(".", "")), (f = g.search(/e/i)) > 0 ? (p < 0 && (p = f), p += +g.slice(f + 1), g = g.substring(0, f)) : p < 0 && (p = g.length)
        } else {
            if (b(r, 2, Z.length, "Base"), r == 10 && K) return u = new _(s), D(u, w + u.e + 1, m);
            if (g = String(s), a = typeof s == "number") {
                if (s * 0 != 0) return i(u, g, a, r);
                if (u.s = 1 / s < 0 ? (g = g.slice(1), -1) : 1, _.DEBUG && g.replace(/^0\.0*|\./, "").length > 15) throw Error(st + s)
            } else u.s = g.charCodeAt(0) === 45 ? (g = g.slice(1), -1) : 1;
            for (n = Z.slice(0, r), p = f = 0, h = g.length; f < h; f++)
                if (n.indexOf(d = g.charAt(f)) < 0) {
                    if (d == ".") {
                        if (f > p) {
                            p = h;
                            continue
                        }
                    } else if (!l && (g == g.toUpperCase() && (g = g.toLowerCase()) || g == g.toLowerCase() && (g = g.toUpperCase()))) {
                        l = !0, f = -1, p = 0;
                        continue
                    }
                    return i(u, String(s), a, r)
                }
            a = !1, g = t(g, r, 10, u.s), (p = g.indexOf(".")) > -1 ? g = g.replace(".", "") : p = g.length
        }
        for (f = 0; g.charCodeAt(f) === 48; f++);
        for (h = g.length; g.charCodeAt(--h) === 48;);
        if (g = g.slice(f, ++h)) {
            if (h -= f, a && _.DEBUG && h > 15 && (s > je || s !== se(s))) throw Error(st + u.s * s);
            if ((p = p - f - 1) > P) u.c = u.e = null;
            else if (p < T) u.c = [u.e = 0];
            else {
                if (u.e = p, u.c = [], f = (p + 1) % x, p < 0 && (f += x), f < h) {
                    for (f && u.c.push(+g.slice(0, f)), h -= x; f < h;) u.c.push(+g.slice(f, f += x));
                    f = x - (g = g.slice(f)).length
                } else f -= h;
                for (; f--; g += "0");
                u.c.push(+g)
            }
        } else u.c = [u.e = 0]
    }
    _.clone = lt, _.ROUND_UP = 0, _.ROUND_DOWN = 1, _.ROUND_CEIL = 2, _.ROUND_FLOOR = 3, _.ROUND_HALF_UP = 4, _.ROUND_HALF_DOWN = 5, _.ROUND_HALF_EVEN = 6, _.ROUND_HALF_CEIL = 7, _.ROUND_HALF_FLOOR = 8, _.EUCLID = 9, _.config = _.set = function(s) {
        var r, n;
        if (s != null)
            if (typeof s == "object") {
                if (s.hasOwnProperty(r = "DECIMAL_PLACES") && (n = s[r], b(n, 0, H, r), w = n), s.hasOwnProperty(r = "ROUNDING_MODE") && (n = s[r], b(n, 0, 8, r), m = n), s.hasOwnProperty(r = "EXPONENTIAL_AT") && (n = s[r], n && n.pop ? (b(n[0], -H, 0, r), b(n[1], 0, H, r), y = n[0], I = n[1]) : (b(n, -H, H, r), y = -(I = n < 0 ? -n : n))), s.hasOwnProperty(r = "RANGE"))
                    if (n = s[r], n && n.pop) b(n[0], -H, -1, r), b(n[1], 1, H, r), T = n[0], P = n[1];
                    else if (b(n, -H, H, r), n) T = -(P = n < 0 ? -n : n);
                else throw Error(X + r + " cannot be zero: " + n);
                if (s.hasOwnProperty(r = "CRYPTO"))
                    if (n = s[r], n === !!n)
                        if (n)
                            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) O = n;
                            else throw O = !n, Error(X + "crypto unavailable");
                else O = n;
                else throw Error(X + r + " not true or false: " + n);
                if (s.hasOwnProperty(r = "MODULO_MODE") && (n = s[r], b(n, 0, 9, r), k = n), s.hasOwnProperty(r = "POW_PRECISION") && (n = s[r], b(n, 0, H, r), $ = n), s.hasOwnProperty(r = "FORMAT"))
                    if (n = s[r], typeof n == "object") Y = n;
                    else throw Error(X + r + " not an object: " + n);
                if (s.hasOwnProperty(r = "ALPHABET"))
                    if (n = s[r], typeof n == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(n)) K = n.slice(0, 10) == "0123456789", Z = n;
                    else throw Error(X + r + " invalid: " + n)
            } else throw Error(X + "Object expected: " + s);
        return {
            DECIMAL_PLACES: w,
            ROUNDING_MODE: m,
            EXPONENTIAL_AT: [y, I],
            RANGE: [T, P],
            CRYPTO: O,
            MODULO_MODE: k,
            POW_PRECISION: $,
            FORMAT: Y,
            ALPHABET: Z
        }
    }, _.isBigNumber = function(s) {
        if (!s || s._isBigNumber !== !0) return !1;
        if (!_.DEBUG) return !0;
        var r, n, d = s.c,
            l = s.e,
            p = s.s;
        e: if ({}.toString.call(d) == "[object Array]") {
            if ((p === 1 || p === -1) && l >= -H && l <= H && l === se(l)) {
                if (d[0] === 0) {
                    if (l === 0 && d.length === 1) return !0;
                    break e
                }
                if (r = (l + 1) % x, r < 1 && (r += x), String(d[0]).length == r) {
                    for (r = 0; r < d.length; r++)
                        if (n = d[r], n < 0 || n >= ae || n !== se(n)) break e;
                    if (n !== 0) return !0
                }
            }
        } else
        if (d === null && l === null && (p === null || p === 1 || p === -1)) return !0;
        throw Error(X + "Invalid BigNumber: " + s)
    }, _.maximum = _.max = function() {
        return ee(arguments, -1)
    }, _.minimum = _.min = function() {
        return ee(arguments, 1)
    }, _.random = function() {
        var s = 9007199254740992,
            r = Math.random() * s & 2097151 ? function() {
                return se(Math.random() * s)
            } : function() {
                return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0)
            };
        return function(n) {
            var d, l, p, f, a, h = 0,
                g = [],
                u = new _(c);
            if (n == null ? n = w : b(n, 0, H), f = be(n / x), O)
                if (crypto.getRandomValues) {
                    for (d = crypto.getRandomValues(new Uint32Array(f *= 2)); h < f;) a = d[h] * 131072 + (d[h + 1] >>> 11), a >= 9e15 ? (l = crypto.getRandomValues(new Uint32Array(2)), d[h] = l[0], d[h + 1] = l[1]) : (g.push(a % 1e14), h += 2);
                    h = f / 2
                } else if (crypto.randomBytes) {
                for (d = crypto.randomBytes(f *= 7); h < f;) a = (d[h] & 31) * 281474976710656 + d[h + 1] * 1099511627776 + d[h + 2] * 4294967296 + d[h + 3] * 16777216 + (d[h + 4] << 16) + (d[h + 5] << 8) + d[h + 6], a >= 9e15 ? crypto.randomBytes(7).copy(d, h) : (g.push(a % 1e14), h += 7);
                h = f / 7
            } else throw O = !1, Error(X + "crypto unavailable");
            if (!O)
                for (; h < f;) a = r(), a < 9e15 && (g[h++] = a % 1e14);
            for (f = g[--h], n %= x, f && n && (a = Fe[x - n], g[h] = se(f / a) * a); g[h] === 0; g.pop(), h--);
            if (h < 0) g = [p = 0];
            else {
                for (p = -1; g[0] === 0; g.splice(0, 1), p -= x);
                for (h = 1, a = g[0]; a >= 10; a /= 10, h++);
                h < x && (p -= x - h)
            }
            return u.e = p, u.c = g, u
        }
    }(), _.sum = function() {
        for (var s = 1, r = arguments, n = new _(r[0]); s < r.length;) n = n.plus(r[s++]);
        return n
    }, t = function() {
        var s = "0123456789";

        function r(n, d, l, p) {
            for (var f, a = [0], h, g = 0, u = n.length; g < u;) {
                for (h = a.length; h--; a[h] *= d);
                for (a[0] += p.indexOf(n.charAt(g++)), f = 0; f < a.length; f++) a[f] > l - 1 && (a[f + 1] == null && (a[f + 1] = 0), a[f + 1] += a[f] / l | 0, a[f] %= l)
            }
            return a.reverse()
        }
        return function(n, d, l, p, f) {
            var a, h, g, u, E, N, C, M, F = n.indexOf("."),
                z = w,
                A = m;
            for (F >= 0 && (u = $, $ = 0, n = n.replace(".", ""), M = new _(d), N = M.pow(n.length - F), $ = u, M.c = r(he(ie(N.c), N.e, "0"), 10, l, s), M.e = M.c.length), C = r(n, d, l, f ? (a = Z, s) : (a = s, Z)), g = u = C.length; C[--u] == 0; C.pop());
            if (!C[0]) return a.charAt(0);
            if (F < 0 ? --g : (N.c = C, N.e = g, N.s = p, N = o(N, M, z, A, l), C = N.c, E = N.r, g = N.e), h = g + z + 1, F = C[h], u = l / 2, E = E || h < 0 || C[h + 1] != null, E = A < 4 ? (F != null || E) && (A == 0 || A == (N.s < 0 ? 3 : 2)) : F > u || F == u && (A == 4 || E || A == 6 && C[h - 1] & 1 || A == (N.s < 0 ? 8 : 7)), h < 1 || !C[0]) n = E ? he(a.charAt(1), -z, a.charAt(0)) : a.charAt(0);
            else {
                if (C.length = h, E)
                    for (--l; ++C[--h] > l;) C[h] = 0, h || (++g, C = [1].concat(C));
                for (u = C.length; !C[--u];);
                for (F = 0, n = ""; F <= u; n += a.charAt(C[F++]));
                n = he(n, g, a.charAt(0))
            }
            return n
        }
    }(), o = function() {
        function s(d, l, p) {
            var f, a, h, g, u = 0,
                E = d.length,
                N = l % fe,
                C = l / fe | 0;
            for (d = d.slice(); E--;) h = d[E] % fe, g = d[E] / fe | 0, f = C * h + g * N, a = N * h + f % fe * fe + u, u = (a / p | 0) + (f / fe | 0) + C * g, d[E] = a % p;
            return u && (d = [u].concat(d)), d
        }

        function r(d, l, p, f) {
            var a, h;
            if (p != f) h = p > f ? 1 : -1;
            else
                for (a = h = 0; a < p; a++)
                    if (d[a] != l[a]) {
                        h = d[a] > l[a] ? 1 : -1;
                        break
                    } return h
        }

        function n(d, l, p, f) {
            for (var a = 0; p--;) d[p] -= a, a = d[p] < l[p] ? 1 : 0, d[p] = a * f + d[p] - l[p];
            for (; !d[0] && d.length > 1; d.splice(0, 1));
        }
        return function(d, l, p, f, a) {
            var h, g, u, E, N, C, M, F, z, A, V, Q, Ce, Ae, Me, ce, Ie, te = d.s == l.s ? 1 : -1,
                W = d.c,
                G = l.c;
            if (!W || !W[0] || !G || !G[0]) return new _(!d.s || !l.s || (W ? G && W[0] == G[0] : !G) ? NaN : W && W[0] == 0 || !G ? te * 0 : te / 0);
            for (F = new _(te), z = F.c = [], g = d.e - l.e, te = p + g + 1, a || (a = ae, g = re(d.e / x) - re(l.e / x), te = te / x | 0), u = 0; G[u] == (W[u] || 0); u++);
            if (G[u] > (W[u] || 0) && g--, te < 0) z.push(1), E = !0;
            else {
                for (Ae = W.length, ce = G.length, u = 0, te += 2, N = se(a / (G[0] + 1)), N > 1 && (G = s(G, N, a), W = s(W, N, a), ce = G.length, Ae = W.length), Ce = ce, A = W.slice(0, ce), V = A.length; V < ce; A[V++] = 0);
                Ie = G.slice(), Ie = [0].concat(Ie), Me = G[0], G[1] >= a / 2 && Me++;
                do {
                    if (N = 0, h = r(G, A, ce, V), h < 0) {
                        if (Q = A[0], ce != V && (Q = Q * a + (A[1] || 0)), N = se(Q / Me), N > 1)
                            for (N >= a && (N = a - 1), C = s(G, N, a), M = C.length, V = A.length; r(C, A, M, V) == 1;) N--, n(C, ce < M ? Ie : G, M, a), M = C.length, h = 1;
                        else N == 0 && (h = N = 1), C = G.slice(), M = C.length;
                        if (M < V && (C = [0].concat(C)), n(A, C, V, a), V = A.length, h == -1)
                            for (; r(G, A, ce, V) < 1;) N++, n(A, ce < V ? Ie : G, V, a), V = A.length
                    } else h === 0 && (N++, A = [0]);
                    z[u++] = N, A[0] ? A[V++] = W[Ce] || 0 : (A = [W[Ce]], V = 1)
                } while ((Ce++ < Ae || A[0] != null) && te--);
                E = A[0] != null, z[0] || z.splice(0, 1)
            }
            if (a == ae) {
                for (u = 1, te = z[0]; te >= 10; te /= 10, u++);
                D(F, p + (F.e = u + g * x - 1) + 1, f, E)
            } else F.e = g, F.r = +E;
            return F
        }
    }();

    function ge(s, r, n, d) {
        var l, p, f, a, h;
        if (n == null ? n = m : b(n, 0, 8), !s.c) return s.toString();
        if (l = s.c[0], f = s.e, r == null) h = ie(s.c), h = d == 1 || d == 2 && (f <= y || f >= I) ? De(h, f) : he(h, f, "0");
        else if (s = D(new _(s), r, n), p = s.e, h = ie(s.c), a = h.length, d == 1 || d == 2 && (r <= p || p <= y)) {
            for (; a < r; h += "0", a++);
            h = De(h, p)
        } else if (r -= f, h = he(h, p, "0"), p + 1 > a) {
            if (--r > 0)
                for (h += "."; r--; h += "0");
        } else if (r += p - a, r > 0)
            for (p + 1 == a && (h += "."); r--; h += "0");
        return s.s < 0 && l ? "-" + h : h
    }

    function ee(s, r) {
        for (var n, d, l = 1, p = new _(s[0]); l < s.length; l++) d = new _(s[l]), (!d.s || (n = ye(p, d)) === r || n === 0 && p.s === r) && (p = d);
        return p
    }

    function R(s, r, n) {
        for (var d = 1, l = r.length; !r[--l]; r.pop());
        for (l = r[0]; l >= 10; l /= 10, d++);
        return (n = d + n * x - 1) > P ? s.c = s.e = null : n < T ? s.c = [s.e = 0] : (s.e = n, s.c = r), s
    }
    i = function() {
        var s = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            r = /^([^.]+)\.$/,
            n = /^\.([^.]+)$/,
            d = /^-?(Infinity|NaN)$/,
            l = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(p, f, a, h) {
            var g, u = a ? f : f.replace(l, "");
            if (d.test(u)) p.s = isNaN(u) ? null : u < 0 ? -1 : 1;
            else {
                if (!a && (u = u.replace(s, function(E, N, C) {
                        return g = (C = C.toLowerCase()) == "x" ? 16 : C == "b" ? 2 : 8, !h || h == g ? N : E
                    }), h && (g = h, u = u.replace(r, "$1").replace(n, "0.$1")), f != u)) return new _(u, g);
                if (_.DEBUG) throw Error(X + "Not a" + (h ? " base " + h : "") + " number: " + f);
                p.s = null
            }
            p.c = p.e = null
        }
    }();

    function D(s, r, n, d) {
        var l, p, f, a, h, g, u, E = s.c,
            N = Fe;
        if (E) {
            e: {
                for (l = 1, a = E[0]; a >= 10; a /= 10, l++);
                if (p = r - l, p < 0) p += x,
                f = r,
                h = E[g = 0],
                u = se(h / N[l - f - 1] % 10);
                else if (g = be((p + 1) / x), g >= E.length)
                    if (d) {
                        for (; E.length <= g; E.push(0));
                        h = u = 0, l = 1, p %= x, f = p - x + 1
                    } else break e;
                else {
                    for (h = a = E[g], l = 1; a >= 10; a /= 10, l++);
                    p %= x, f = p - x + l, u = f < 0 ? 0 : se(h / N[l - f - 1] % 10)
                }
                if (d = d || r < 0 || E[g + 1] != null || (f < 0 ? h : h % N[l - f - 1]), d = n < 4 ? (u || d) && (n == 0 || n == (s.s < 0 ? 3 : 2)) : u > 5 || u == 5 && (n == 4 || d || n == 6 && (p > 0 ? f > 0 ? h / N[l - f] : 0 : E[g - 1]) % 10 & 1 || n == (s.s < 0 ? 8 : 7)), r < 1 || !E[0]) return E.length = 0, d ? (r -= s.e + 1, E[0] = N[(x - r % x) % x], s.e = -r || 0) : E[0] = s.e = 0, s;
                if (p == 0 ? (E.length = g, a = 1, g--) : (E.length = g + 1, a = N[x - p], E[g] = f > 0 ? se(h / N[l - f] % N[f]) * a : 0), d)
                    for (;;)
                        if (g == 0) {
                            for (p = 1, f = E[0]; f >= 10; f /= 10, p++);
                            for (f = E[0] += a, a = 1; f >= 10; f /= 10, a++);
                            p != a && (s.e++, E[0] == ae && (E[0] = 1));
                            break
                        } else {
                            if (E[g] += a, E[g] != ae) break;
                            E[g--] = 0, a = 1
                        }
                for (p = E.length; E[--p] === 0; E.pop());
            }
            s.e > P ? s.c = s.e = null : s.e < T && (s.c = [s.e = 0])
        }
        return s
    }

    function B(s) {
        var r, n = s.e;
        return n === null ? s.toString() : (r = ie(s.c), r = n <= y || n >= I ? De(r, n) : he(r, n, "0"), s.s < 0 ? "-" + r : r)
    }
    return e.absoluteValue = e.abs = function() {
        var s = new _(this);
        return s.s < 0 && (s.s = 1), s
    }, e.comparedTo = function(s, r) {
        return ye(this, new _(s, r))
    }, e.decimalPlaces = e.dp = function(s, r) {
        var n, d, l, p = this;
        if (s != null) return b(s, 0, H), r == null ? r = m : b(r, 0, 8), D(new _(p), s + p.e + 1, r);
        if (!(n = p.c)) return null;
        if (d = ((l = n.length - 1) - re(this.e / x)) * x, l = n[l])
            for (; l % 10 == 0; l /= 10, d--);
        return d < 0 && (d = 0), d
    }, e.dividedBy = e.div = function(s, r) {
        return o(this, new _(s, r), w, m)
    }, e.dividedToIntegerBy = e.idiv = function(s, r) {
        return o(this, new _(s, r), 0, 1)
    }, e.exponentiatedBy = e.pow = function(s, r) {
        var n, d, l, p, f, a, h, g, u, E = this;
        if (s = new _(s), s.c && !s.isInteger()) throw Error(X + "Exponent not an integer: " + B(s));
        if (r != null && (r = new _(r)), a = s.e > 14, !E.c || !E.c[0] || E.c[0] == 1 && !E.e && E.c.length == 1 || !s.c || !s.c[0]) return u = new _(Math.pow(+B(E), a ? s.s * (2 - Pe(s)) : +B(s))), r ? u.mod(r) : u;
        if (h = s.s < 0, r) {
            if (r.c ? !r.c[0] : !r.s) return new _(NaN);
            d = !h && E.isInteger() && r.isInteger(), d && (E = E.mod(r))
        } else {
            if (s.e > 9 && (E.e > 0 || E.e < -1 || (E.e == 0 ? E.c[0] > 1 || a && E.c[1] >= 24e7 : E.c[0] < 8e13 || a && E.c[0] <= 9999975e7))) return p = E.s < 0 && Pe(s) ? -0 : 0, E.e > -1 && (p = 1 / p), new _(h ? 1 / p : p);
            $ && (p = be($ / x + 2))
        }
        for (a ? (n = new _(.5), h && (s.s = 1), g = Pe(s)) : (l = Math.abs(+B(s)), g = l % 2), u = new _(c);;) {
            if (g) {
                if (u = u.times(E), !u.c) break;
                p ? u.c.length > p && (u.c.length = p) : d && (u = u.mod(r))
            }
            if (l) {
                if (l = se(l / 2), l === 0) break;
                g = l % 2
            } else if (s = s.times(n), D(s, s.e + 1, 1), s.e > 14) g = Pe(s);
            else {
                if (l = +B(s), l === 0) break;
                g = l % 2
            }
            E = E.times(E), p ? E.c && E.c.length > p && (E.c.length = p) : d && (E = E.mod(r))
        }
        return d ? u : (h && (u = c.div(u)), r ? u.mod(r) : p ? D(u, $, m, f) : u)
    }, e.integerValue = function(s) {
        var r = new _(this);
        return s == null ? s = m : b(s, 0, 8), D(r, r.e + 1, s)
    }, e.isEqualTo = e.eq = function(s, r) {
        return ye(this, new _(s, r)) === 0
    }, e.isFinite = function() {
        return !!this.c
    }, e.isGreaterThan = e.gt = function(s, r) {
        return ye(this, new _(s, r)) > 0
    }, e.isGreaterThanOrEqualTo = e.gte = function(s, r) {
        return (r = ye(this, new _(s, r))) === 1 || r === 0
    }, e.isInteger = function() {
        return !!this.c && re(this.e / x) > this.c.length - 2
    }, e.isLessThan = e.lt = function(s, r) {
        return ye(this, new _(s, r)) < 0
    }, e.isLessThanOrEqualTo = e.lte = function(s, r) {
        return (r = ye(this, new _(s, r))) === -1 || r === 0
    }, e.isNaN = function() {
        return !this.s
    }, e.isNegative = function() {
        return this.s < 0
    }, e.isPositive = function() {
        return this.s > 0
    }, e.isZero = function() {
        return !!this.c && this.c[0] == 0
    }, e.minus = function(s, r) {
        var n, d, l, p, f = this,
            a = f.s;
        if (s = new _(s, r), r = s.s, !a || !r) return new _(NaN);
        if (a != r) return s.s = -r, f.plus(s);
        var h = f.e / x,
            g = s.e / x,
            u = f.c,
            E = s.c;
        if (!h || !g) {
            if (!u || !E) return u ? (s.s = -r, s) : new _(E ? f : NaN);
            if (!u[0] || !E[0]) return E[0] ? (s.s = -r, s) : new _(u[0] ? f : m == 3 ? -0 : 0)
        }
        if (h = re(h), g = re(g), u = u.slice(), a = h - g) {
            for ((p = a < 0) ? (a = -a, l = u) : (g = h, l = E), l.reverse(), r = a; r--; l.push(0));
            l.reverse()
        } else
            for (d = (p = (a = u.length) < (r = E.length)) ? a : r, a = r = 0; r < d; r++)
                if (u[r] != E[r]) {
                    p = u[r] < E[r];
                    break
                } if (p && (l = u, u = E, E = l, s.s = -s.s), r = (d = E.length) - (n = u.length), r > 0)
            for (; r--; u[n++] = 0);
        for (r = ae - 1; d > a;) {
            if (u[--d] < E[d]) {
                for (n = d; n && !u[--n]; u[n] = r);
                --u[n], u[d] += ae
            }
            u[d] -= E[d]
        }
        for (; u[0] == 0; u.splice(0, 1), --g);
        return u[0] ? R(s, u, g) : (s.s = m == 3 ? -1 : 1, s.c = [s.e = 0], s)
    }, e.modulo = e.mod = function(s, r) {
        var n, d, l = this;
        return s = new _(s, r), !l.c || !s.s || s.c && !s.c[0] ? new _(NaN) : !s.c || l.c && !l.c[0] ? new _(l) : (k == 9 ? (d = s.s, s.s = 1, n = o(l, s, 0, 3), s.s = d, n.s *= d) : n = o(l, s, 0, k), s = l.minus(n.times(s)), !s.c[0] && k == 1 && (s.s = l.s), s)
    }, e.multipliedBy = e.times = function(s, r) {
        var n, d, l, p, f, a, h, g, u, E, N, C, M, F, z, A = this,
            V = A.c,
            Q = (s = new _(s, r)).c;
        if (!V || !Q || !V[0] || !Q[0]) return !A.s || !s.s || V && !V[0] && !Q || Q && !Q[0] && !V ? s.c = s.e = s.s = null : (s.s *= A.s, !V || !Q ? s.c = s.e = null : (s.c = [0], s.e = 0)), s;
        for (d = re(A.e / x) + re(s.e / x), s.s *= A.s, h = V.length, E = Q.length, h < E && (M = V, V = Q, Q = M, l = h, h = E, E = l), l = h + E, M = []; l--; M.push(0));
        for (F = ae, z = fe, l = E; --l >= 0;) {
            for (n = 0, N = Q[l] % z, C = Q[l] / z | 0, f = h, p = l + f; p > l;) g = V[--f] % z, u = V[f] / z | 0, a = C * g + u * N, g = N * g + a % z * z + M[p] + n, n = (g / F | 0) + (a / z | 0) + C * u, M[p--] = g % F;
            M[p] = n
        }
        return n ? ++d : M.splice(0, 1), R(s, M, d)
    }, e.negated = function() {
        var s = new _(this);
        return s.s = -s.s || null, s
    }, e.plus = function(s, r) {
        var n, d = this,
            l = d.s;
        if (s = new _(s, r), r = s.s, !l || !r) return new _(NaN);
        if (l != r) return s.s = -r, d.minus(s);
        var p = d.e / x,
            f = s.e / x,
            a = d.c,
            h = s.c;
        if (!p || !f) {
            if (!a || !h) return new _(l / 0);
            if (!a[0] || !h[0]) return h[0] ? s : new _(a[0] ? d : l * 0)
        }
        if (p = re(p), f = re(f), a = a.slice(), l = p - f) {
            for (l > 0 ? (f = p, n = h) : (l = -l, n = a), n.reverse(); l--; n.push(0));
            n.reverse()
        }
        for (l = a.length, r = h.length, l - r < 0 && (n = h, h = a, a = n, r = l), l = 0; r;) l = (a[--r] = a[r] + h[r] + l) / ae | 0, a[r] = ae === a[r] ? 0 : a[r] % ae;
        return l && (a = [l].concat(a), ++f), R(s, a, f)
    }, e.precision = e.sd = function(s, r) {
        var n, d, l, p = this;
        if (s != null && s !== !!s) return b(s, 1, H), r == null ? r = m : b(r, 0, 8), D(new _(p), s, r);
        if (!(n = p.c)) return null;
        if (l = n.length - 1, d = l * x + 1, l = n[l]) {
            for (; l % 10 == 0; l /= 10, d--);
            for (l = n[0]; l >= 10; l /= 10, d++);
        }
        return s && p.e + 1 > d && (d = p.e + 1), d
    }, e.shiftedBy = function(s) {
        return b(s, -je, je), this.times("1e" + s)
    }, e.squareRoot = e.sqrt = function() {
        var s, r, n, d, l, p = this,
            f = p.c,
            a = p.s,
            h = p.e,
            g = w + 4,
            u = new _("0.5");
        if (a !== 1 || !f || !f[0]) return new _(!a || a < 0 && (!f || f[0]) ? NaN : f ? p : 1 / 0);
        if (a = Math.sqrt(+B(p)), a == 0 || a == 1 / 0 ? (r = ie(f), (r.length + h) % 2 == 0 && (r += "0"), a = Math.sqrt(+r), h = re((h + 1) / 2) - (h < 0 || h % 2), a == 1 / 0 ? r = "5e" + h : (r = a.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + h), n = new _(r)) : n = new _(a + ""), n.c[0]) {
            for (h = n.e, a = h + g, a < 3 && (a = 0);;)
                if (l = n, n = u.times(l.plus(o(p, l, g, 1))), ie(l.c).slice(0, a) === (r = ie(n.c)).slice(0, a))
                    if (n.e < h && --a, r = r.slice(a - 3, a + 1), r == "9999" || !d && r == "4999") {
                        if (!d && (D(l, l.e + w + 2, 0), l.times(l).eq(p))) {
                            n = l;
                            break
                        }
                        g += 4, a += 4, d = 1
                    } else {
                        (!+r || !+r.slice(1) && r.charAt(0) == "5") && (D(n, n.e + w + 2, 1), s = !n.times(n).eq(p));
                        break
                    }
        }
        return D(n, n.e + w + 1, m, s)
    }, e.toExponential = function(s, r) {
        return s != null && (b(s, 0, H), s++), ge(this, s, r, 1)
    }, e.toFixed = function(s, r) {
        return s != null && (b(s, 0, H), s = s + this.e + 1), ge(this, s, r)
    }, e.toFormat = function(s, r, n) {
        var d, l = this;
        if (n == null) s != null && r && typeof r == "object" ? (n = r, r = null) : s && typeof s == "object" ? (n = s, s = r = null) : n = Y;
        else if (typeof n != "object") throw Error(X + "Argument not an object: " + n);
        if (d = l.toFixed(s, r), l.c) {
            var p, f = d.split("."),
                a = +n.groupSize,
                h = +n.secondaryGroupSize,
                g = n.groupSeparator || "",
                u = f[0],
                E = f[1],
                N = l.s < 0,
                C = N ? u.slice(1) : u,
                M = C.length;
            if (h && (p = a, a = h, h = p, M -= p), a > 0 && M > 0) {
                for (p = M % a || a, u = C.substr(0, p); p < M; p += a) u += g + C.substr(p, a);
                h > 0 && (u += g + C.slice(p)), N && (u = "-" + u)
            }
            d = E ? u + (n.decimalSeparator || "") + ((h = +n.fractionGroupSize) ? E.replace(new RegExp("\\d{" + h + "}\\B", "g"), "$&" + (n.fractionGroupSeparator || "")) : E) : u
        }
        return (n.prefix || "") + d + (n.suffix || "")
    }, e.toFraction = function(s) {
        var r, n, d, l, p, f, a, h, g, u, E, N, C = this,
            M = C.c;
        if (s != null && (a = new _(s), !a.isInteger() && (a.c || a.s !== 1) || a.lt(c))) throw Error(X + "Argument " + (a.isInteger() ? "out of range: " : "not an integer: ") + B(a));
        if (!M) return new _(C);
        for (r = new _(c), g = n = new _(c), d = h = new _(c), N = ie(M), p = r.e = N.length - C.e - 1, r.c[0] = Fe[(f = p % x) < 0 ? x + f : f], s = !s || a.comparedTo(r) > 0 ? p > 0 ? r : g : a, f = P, P = 1 / 0, a = new _(N), h.c[0] = 0; u = o(a, r, 0, 1), l = n.plus(u.times(d)), l.comparedTo(s) != 1;) n = d, d = l, g = h.plus(u.times(l = g)), h = l, r = a.minus(u.times(l = r)), a = l;
        return l = o(s.minus(n), d, 0, 1), h = h.plus(l.times(g)), n = n.plus(l.times(d)), h.s = g.s = C.s, p = p * 2, E = o(g, d, p, m).minus(C).abs().comparedTo(o(h, n, p, m).minus(C).abs()) < 1 ? [g, d] : [h, n], P = f, E
    }, e.toNumber = function() {
        return +B(this)
    }, e.toPrecision = function(s, r) {
        return s != null && b(s, 1, H), ge(this, s, r, 2)
    }, e.toString = function(s) {
        var r, n = this,
            d = n.s,
            l = n.e;
        return l === null ? d ? (r = "Infinity", d < 0 && (r = "-" + r)) : r = "NaN" : (s == null ? r = l <= y || l >= I ? De(ie(n.c), l) : he(ie(n.c), l, "0") : s === 10 && K ? (n = D(new _(n), w + l + 1, m), r = he(ie(n.c), n.e, "0")) : (b(s, 2, Z.length, "Base"), r = t(he(ie(n.c), l, "0"), 10, s, d, !0)), d < 0 && n.c[0] && (r = "-" + r)), r
    }, e.valueOf = e.toJSON = function() {
        return B(this)
    }, e._isBigNumber = !0, e[Symbol.toStringTag] = "BigNumber", e[Symbol.for("nodejs.util.inspect.custom")] = e.valueOf, S != null && _.set(S), _
}

function re(S) {
    var o = S | 0;
    return S > 0 || S === o ? o : o - 1
}

function ie(S) {
    for (var o, t, i = 1, e = S.length, c = S[0] + ""; i < e;) {
        for (o = S[i++] + "", t = x - o.length; t--; o = "0" + o);
        c += o
    }
    for (e = c.length; c.charCodeAt(--e) === 48;);
    return c.slice(0, e + 1 || 1)
}

function ye(S, o) {
    var t, i, e = S.c,
        c = o.c,
        w = S.s,
        m = o.s,
        y = S.e,
        I = o.e;
    if (!w || !m) return null;
    if (t = e && !e[0], i = c && !c[0], t || i) return t ? i ? 0 : -m : w;
    if (w != m) return w;
    if (t = w < 0, i = y == I, !e || !c) return i ? 0 : !e ^ t ? 1 : -1;
    if (!i) return y > I ^ t ? 1 : -1;
    for (m = (y = e.length) < (I = c.length) ? y : I, w = 0; w < m; w++)
        if (e[w] != c[w]) return e[w] > c[w] ^ t ? 1 : -1;
    return y == I ? 0 : y > I ^ t ? 1 : -1
}

function b(S, o, t, i) {
    if (S < o || S > t || S !== se(S)) throw Error(X + (i || "Argument") + (typeof S == "number" ? S < o || S > t ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(S))
}

function Pe(S) {
    var o = S.c.length - 1;
    return re(S.e / x) == o && S.c[o] % 2 != 0
}

function De(S, o) {
    return (S.length > 1 ? S.charAt(0) + "." + S.slice(1) : S) + (o < 0 ? "e" : "e+") + o
}

function he(S, o, t) {
    var i, e;
    if (o < 0) {
        for (e = t + "."; ++o; e += t);
        S = e + S
    } else if (i = S.length, ++o > i) {
        for (e = t, o -= i; --o; e += t);
        S += e
    } else o < i && (S = S.slice(0, o) + "." + S.slice(o));
    return S
}
lt();
const si = ct.once(function() {
    const o = v.env.host.includes("dogcrash.top") || v.env.isDevHost || v.env.isDev ? "t1-tozpsiwmuyjayyiw.dogcrash.game" : v.env.host;
    return v.utils.loadScript(`//${o}/metamask-sdk.js`)
});
async function ri(S) {
    await si();
    const t = new MetaMaskSDK.default().getProvider();
    return S && S(), await t.request({
        method: "eth_requestAccounts",
        params: []
    }), t
}
async function ni(S, o) {
    try {
        const t = await ri(o),
            [i] = await t.request({
                method: "eth_accounts",
                params: []
            }),
            e = await t.request({
                method: "personal_sign",
                params: [S, i]
            });
        return {
            publicAddress: i,
            signature: e
        }
    } catch (t) {
        return {
            publicAddress: "",
            signature: ""
        }
    }
}
const ht = "wc",
    pt = 2,
    ut = "client",
    Ke = `${ht}@${pt}:${ut}:`,
    Ge = {
        name: ut,
        logger: "error",
        controller: !1,
        relayUrl: "wss://relay.walletconnect.com"
    },
    rt = "WALLETCONNECT_DEEPLINK_CHOICE",
    oi = "proposal",
    ai = "Proposal expired",
    ci = "session",
    Te = j.SEVEN_DAYS,
    li = "engine",
    pe = {
        wc_sessionPropose: {
            req: {
                ttl: j.FIVE_MINUTES,
                prompt: !0,
                tag: 1100
            },
            res: {
                ttl: j.FIVE_MINUTES,
                prompt: !1,
                tag: 1101
            }
        },
        wc_sessionSettle: {
            req: {
                ttl: j.FIVE_MINUTES,
                prompt: !1,
                tag: 1102
            },
            res: {
                ttl: j.FIVE_MINUTES,
                prompt: !1,
                tag: 1103
            }
        },
        wc_sessionUpdate: {
            req: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1104
            },
            res: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1105
            }
        },
        wc_sessionExtend: {
            req: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1106
            },
            res: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1107
            }
        },
        wc_sessionRequest: {
            req: {
                ttl: j.FIVE_MINUTES,
                prompt: !0,
                tag: 1108
            },
            res: {
                ttl: j.FIVE_MINUTES,
                prompt: !1,
                tag: 1109
            }
        },
        wc_sessionEvent: {
            req: {
                ttl: j.FIVE_MINUTES,
                prompt: !0,
                tag: 1110
            },
            res: {
                ttl: j.FIVE_MINUTES,
                prompt: !1,
                tag: 1111
            }
        },
        wc_sessionDelete: {
            req: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1112
            },
            res: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1113
            }
        },
        wc_sessionPing: {
            req: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1114
            },
            res: {
                ttl: j.ONE_DAY,
                prompt: !1,
                tag: 1115
            }
        }
    },
    Be = {
        min: j.FIVE_MINUTES,
        max: j.SEVEN_DAYS
    },
    ue = {
        idle: "IDLE",
        active: "ACTIVE"
    },
    hi = "request",
    pi = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ui = Object.defineProperty,
    di = Object.defineProperties,
    gi = Object.getOwnPropertyDescriptors,
    nt = Object.getOwnPropertySymbols,
    fi = Object.prototype.hasOwnProperty,
    wi = Object.prototype.propertyIsEnumerable,
    ot = (S, o, t) => o in S ? ui(S, o, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : S[o] = t,
    J = (S, o) => {
        for (var t in o || (o = {})) fi.call(o, t) && ot(S, t, o[t]);
        if (nt)
            for (var t of nt(o)) wi.call(o, t) && ot(S, t, o[t]);
        return S
    },
    _e = (S, o) => di(S, gi(o));
class mi extends mt {
    constructor(o) {
        super(o), this.name = li, this.events = new yt, this.initialized = !1, this.ignoredPayloadTypes = [St], this.requestQueue = {
            state: ue.idle,
            queue: []
        }, this.sessionRequestQueue = {
            state: ue.idle,
            queue: []
        }, this.requestQueueDelay = j.ONE_SECOND, this.recentlyDeletedMap = new Map, this.recentlyDeletedLimit = 200, this.init = async () => {
            this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({
                methods: Object.keys(pe)
            }), this.initialized = !0, setTimeout(() => {
                this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue()
            }, j.toMiliseconds(this.requestQueueDelay)))
        }, this.connect = async t => {
            await this.isInitialized();
            const i = _e(J({}, t), {
                requiredNamespaces: t.requiredNamespaces || {},
                optionalNamespaces: t.optionalNamespaces || {}
            });
            await this.isValidConnect(i);
            const {
                pairingTopic: e,
                requiredNamespaces: c,
                optionalNamespaces: w,
                sessionProperties: m,
                relays: y
            } = i;
            let I = e,
                T, P = !1;
            try {
                I && (P = this.client.core.pairing.pairings.get(I).active)
            } catch (ee) {
                throw this.client.logger.error(`connect() -> pairing.get(${I}) failed`), ee
            }
            if (!I || !P) {
                const {
                    topic: ee,
                    uri: R
                } = await this.client.core.pairing.create();
                I = ee, T = R
            }
            if (!I) {
                const {
                    message: ee
                } = L("NO_MATCHING_KEY", `connect() pairing topic: ${I}`);
                throw new Error(ee)
            }
            const O = await this.client.core.crypto.generateKeyPair(),
                k = pe.wc_sessionPropose.req.ttl || j.FIVE_MINUTES,
                $ = le(k),
                Y = J({
                    requiredNamespaces: c,
                    optionalNamespaces: w,
                    relays: y != null ? y : [{
                        protocol: Et
                    }],
                    proposer: {
                        publicKey: O,
                        metadata: this.client.metadata
                    },
                    expiryTimestamp: $
                }, m && {
                    sessionProperties: m
                }),
                {
                    reject: Z,
                    resolve: K,
                    done: _
                } = Re(k, ai);
            this.events.once(U("session_connect"), async ({
                error: ee,
                session: R
            }) => {
                if (ee) Z(ee);
                else if (R) {
                    R.self.publicKey = O;
                    const D = _e(J({}, R), {
                        requiredNamespaces: Y.requiredNamespaces,
                        optionalNamespaces: Y.optionalNamespaces
                    });
                    await this.client.session.set(R.topic, D), await this.setExpiry(R.topic, R.expiry), I && await this.client.core.pairing.updateMetadata({
                        topic: I,
                        metadata: R.peer.metadata
                    }), K(D)
                }
            });
            const ge = await this.sendRequest({
                topic: I,
                method: "wc_sessionPropose",
                params: Y,
                throwOnFailedPublish: !0
            });
            return await this.setProposal(ge, J({
                id: ge
            }, Y)), {
                uri: T,
                approval: _
            }
        }, this.pair = async t => {
            await this.isInitialized();
            try {
                return await this.client.core.pairing.pair(t)
            } catch (i) {
                throw this.client.logger.error("pair() failed"), i
            }
        }, this.approve = async t => {
            await this.isInitialized();
            try {
                await this.isValidApprove(t)
            } catch (K) {
                throw this.client.logger.error("approve() -> isValidApprove() failed"), K
            }
            const {
                id: i,
                relayProtocol: e,
                namespaces: c,
                sessionProperties: w
            } = t;
            let m;
            try {
                m = this.client.proposal.get(i)
            } catch (K) {
                throw this.client.logger.error(`approve() -> proposal.get(${i}) failed`), K
            }
            let {
                pairingTopic: y,
                proposer: I,
                requiredNamespaces: T,
                optionalNamespaces: P
            } = m;
            y = y || "";
            const O = await this.client.core.crypto.generateKeyPair(),
                k = I.publicKey,
                $ = await this.client.core.crypto.generateSharedKey(O, k),
                Y = J({
                    relay: {
                        protocol: e != null ? e : "irn"
                    },
                    namespaces: c,
                    pairingTopic: y,
                    controller: {
                        publicKey: O,
                        metadata: this.client.metadata
                    },
                    expiry: le(Te)
                }, w && {
                    sessionProperties: w
                });
            await this.client.core.relayer.subscribe($);
            const Z = _e(J({}, Y), {
                topic: $,
                requiredNamespaces: T,
                optionalNamespaces: P,
                pairingTopic: y,
                acknowledged: !1,
                self: Y.controller,
                peer: {
                    publicKey: I.publicKey,
                    metadata: I.metadata
                },
                controller: O
            });
            await this.client.session.set($, Z);
            try {
                await this.sendResult({
                    id: i,
                    topic: y,
                    result: {
                        relay: {
                            protocol: e != null ? e : "irn"
                        },
                        responderPublicKey: O
                    },
                    throwOnFailedPublish: !0
                }), await this.sendRequest({
                    topic: $,
                    method: "wc_sessionSettle",
                    params: Y,
                    throwOnFailedPublish: !0
                })
            } catch (K) {
                throw this.client.logger.error(K), this.client.session.delete($, ne("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe($), K
            }
            return await this.client.core.pairing.updateMetadata({
                topic: y,
                metadata: I.metadata
            }), await this.client.proposal.delete(i, ne("USER_DISCONNECTED")), await this.client.core.pairing.activate({
                topic: y
            }), await this.setExpiry($, le(Te)), {
                topic: $,
                acknowledged: () => new Promise(K => setTimeout(() => K(this.client.session.get($)), 500))
            }
        }, this.reject = async t => {
            await this.isInitialized();
            try {
                await this.isValidReject(t)
            } catch (w) {
                throw this.client.logger.error("reject() -> isValidReject() failed"), w
            }
            const {
                id: i,
                reason: e
            } = t;
            let c;
            try {
                c = this.client.proposal.get(i).pairingTopic
            } catch (w) {
                throw this.client.logger.error(`reject() -> proposal.get(${i}) failed`), w
            }
            c && (await this.sendError(i, c, e), await this.client.proposal.delete(i, ne("USER_DISCONNECTED")))
        }, this.update = async t => {
            await this.isInitialized();
            try {
                await this.isValidUpdate(t)
            } catch (P) {
                throw this.client.logger.error("update() -> isValidUpdate() failed"), P
            }
            const {
                topic: i,
                namespaces: e
            } = t, {
                done: c,
                resolve: w,
                reject: m
            } = Re(), y = Oe(), I = xe().toString(), T = this.client.session.get(i).namespaces;
            return this.events.once(U("session_update", y), async ({
                error: P
            }) => {
                P ? m(P) : (await this.client.session.update(i, {
                    namespaces: e
                }), w())
            }), this.sendRequest({
                topic: i,
                method: "wc_sessionUpdate",
                params: {
                    namespaces: e
                },
                throwOnFailedPublish: !0,
                clientRpcId: y,
                relayRpcId: I
            }).catch(P => {
                this.client.logger.error(P), this.client.session.update(i, {
                    namespaces: T
                }), m(P)
            }), {
                acknowledged: c
            }
        }, this.extend = async t => {
            await this.isInitialized();
            try {
                await this.isValidExtend(t)
            } catch (y) {
                throw this.client.logger.error("extend() -> isValidExtend() failed"), y
            }
            const {
                topic: i
            } = t, e = Oe(), {
                done: c,
                resolve: w,
                reject: m
            } = Re();
            return this.events.once(U("session_extend", e), ({
                error: y
            }) => {
                y ? m(y) : w()
            }), await this.setExpiry(i, le(Te)), this.sendRequest({
                topic: i,
                method: "wc_sessionExtend",
                params: {},
                clientRpcId: e,
                throwOnFailedPublish: !0
            }).catch(y => {
                m(y)
            }), {
                acknowledged: c
            }
        }, this.request = async t => {
            await this.isInitialized();
            try {
                await this.isValidRequest(t)
            } catch (O) {
                throw this.client.logger.error("request() -> isValidRequest() failed"), O
            }
            const {
                chainId: i,
                request: e,
                topic: c,
                expiry: w = pe.wc_sessionRequest.req.ttl
            } = t, m = Oe(), y = xe().toString(), {
                done: I,
                resolve: T,
                reject: P
            } = Re(w, "Request expired. Please try again.");
            return this.events.once(U("session_request", m), ({
                error: O,
                result: k
            }) => {
                O ? P(O) : T(k)
            }), await Promise.all([new Promise(async O => {
                await this.sendRequest({
                    clientRpcId: m,
                    relayRpcId: y,
                    topic: c,
                    method: "wc_sessionRequest",
                    params: {
                        request: _e(J({}, e), {
                            expiryTimestamp: le(w)
                        }),
                        chainId: i
                    },
                    expiry: w,
                    throwOnFailedPublish: !0
                }).catch(k => P(k)), this.client.events.emit("session_request_sent", {
                    topic: c,
                    request: e,
                    chainId: i,
                    id: m
                }), O()
            }), new Promise(async O => {
                const k = await _t(this.client.core.storage, rt);
                It({
                    id: m,
                    topic: c,
                    wcDeepLink: k
                }), O()
            }), I()]).then(O => O[2])
        }, this.respond = async t => {
            await this.isInitialized(), await this.isValidRespond(t);
            const {
                topic: i,
                response: e
            } = t, {
                id: c
            } = e;
            we(e) ? await this.sendResult({
                id: c,
                topic: i,
                result: e.result,
                throwOnFailedPublish: !0
            }) : me(e) && await this.sendError(c, i, e.error), this.cleanupAfterResponse(t)
        }, this.ping = async t => {
            await this.isInitialized();
            try {
                await this.isValidPing(t)
            } catch (e) {
                throw this.client.logger.error("ping() -> isValidPing() failed"), e
            }
            const {
                topic: i
            } = t;
            if (this.client.session.keys.includes(i)) {
                const e = Oe(),
                    c = xe().toString(),
                    {
                        done: w,
                        resolve: m,
                        reject: y
                    } = Re();
                this.events.once(U("session_ping", e), ({
                    error: I
                }) => {
                    I ? y(I) : m()
                }), await Promise.all([this.sendRequest({
                    topic: i,
                    method: "wc_sessionPing",
                    params: {},
                    throwOnFailedPublish: !0,
                    clientRpcId: e,
                    relayRpcId: c
                }), w()])
            } else this.client.core.pairing.pairings.keys.includes(i) && await this.client.core.pairing.ping({
                topic: i
            })
        }, this.emit = async t => {
            await this.isInitialized(), await this.isValidEmit(t);
            const {
                topic: i,
                event: e,
                chainId: c
            } = t, w = xe().toString();
            await this.sendRequest({
                topic: i,
                method: "wc_sessionEvent",
                params: {
                    event: e,
                    chainId: c
                },
                throwOnFailedPublish: !0,
                relayRpcId: w
            })
        }, this.disconnect = async t => {
            await this.isInitialized(), await this.isValidDisconnect(t);
            const {
                topic: i
            } = t;
            if (this.client.session.keys.includes(i)) await this.sendRequest({
                topic: i,
                method: "wc_sessionDelete",
                params: ne("USER_DISCONNECTED"),
                throwOnFailedPublish: !0
            }), await this.deleteSession({
                topic: i,
                emitEvent: !1
            });
            else if (this.client.core.pairing.pairings.keys.includes(i)) await this.client.core.pairing.disconnect({
                topic: i
            });
            else {
                const {
                    message: e
                } = L("MISMATCHED_TOPIC", `Session or pairing topic not found: ${i}`);
                throw new Error(e)
            }
        }, this.find = t => (this.isInitialized(), this.client.session.getAll().filter(i => Rt(i, t))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.cleanupDuplicatePairings = async t => {
            if (t.pairingTopic) try {
                const i = this.client.core.pairing.pairings.get(t.pairingTopic),
                    e = this.client.core.pairing.pairings.getAll().filter(c => {
                        var w, m;
                        return ((w = c.peerMetadata) == null ? void 0 : w.url) && ((m = c.peerMetadata) == null ? void 0 : m.url) === t.peer.metadata.url && c.topic && c.topic !== i.topic
                    });
                if (e.length === 0) return;
                this.client.logger.info(`Cleaning up ${e.length} duplicate pairing(s)`), await Promise.all(e.map(c => this.client.core.pairing.disconnect({
                    topic: c.topic
                }))), this.client.logger.info("Duplicate pairings clean up finished")
            } catch (i) {
                this.client.logger.error(i)
            }
        }, this.deleteSession = async t => {
            const {
                topic: i,
                expirerHasDeleted: e = !1,
                emitEvent: c = !0,
                id: w = 0
            } = t, {
                self: m
            } = this.client.session.get(i);
            await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, ne("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(m.publicKey) && await this.client.core.crypto.deleteKeyPair(m.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), e || this.client.core.expirer.del(i), this.client.core.storage.removeItem(rt).catch(y => this.client.logger.warn(y)), this.getPendingSessionRequests().forEach(y => {
                y.topic === i && this.deletePendingSessionRequest(y.id, ne("USER_DISCONNECTED"))
            }), c && this.client.events.emit("session_delete", {
                id: w,
                topic: i
            })
        }, this.deleteProposal = async (t, i) => {
            await Promise.all([this.client.proposal.delete(t, ne("USER_DISCONNECTED")), i ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal")
        }, this.deletePendingSessionRequest = async (t, i, e = !1) => {
            await Promise.all([this.client.pendingRequest.delete(t, i), e ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter(c => c.id !== t), e && (this.sessionRequestQueue.state = ue.idle, this.client.events.emit("session_request_expire", {
                id: t
            }))
        }, this.setExpiry = async (t, i) => {
            this.client.session.keys.includes(t) && await this.client.session.update(t, {
                expiry: i
            }), this.client.core.expirer.set(t, i)
        }, this.setProposal = async (t, i) => {
            await this.client.proposal.set(t, i), this.client.core.expirer.set(t, le(pe.wc_sessionPropose.req.ttl))
        }, this.setPendingSessionRequest = async t => {
            const {
                id: i,
                topic: e,
                params: c,
                verifyContext: w
            } = t, m = c.request.expiryTimestamp || le(pe.wc_sessionRequest.req.ttl);
            await this.client.pendingRequest.set(i, {
                id: i,
                topic: e,
                params: c,
                verifyContext: w
            }), m && this.client.core.expirer.set(i, m)
        }, this.sendRequest = async t => {
            const {
                topic: i,
                method: e,
                params: c,
                expiry: w,
                relayRpcId: m,
                clientRpcId: y,
                throwOnFailedPublish: I
            } = t, T = ke(e, c, y);
            if (Nt() && pi.includes(e)) {
                const k = Ve(JSON.stringify(T));
                this.client.core.verify.register({
                    attestationId: k
                })
            }
            let P;
            try {
                P = await this.client.core.crypto.encode(i, T)
            } catch (k) {
                throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${i} failed`), k
            }
            const O = pe[e].req;
            return w && (O.ttl = w), m && (O.id = m), this.client.core.history.set(i, T), I ? (O.internal = _e(J({}, O.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(i, P, O)) : this.client.core.relayer.publish(i, P, O).catch(k => this.client.logger.error(k)), T.id
        }, this.sendResult = async t => {
            const {
                id: i,
                topic: e,
                result: c,
                throwOnFailedPublish: w
            } = t, m = Gt(i, c);
            let y;
            try {
                y = await this.client.core.crypto.encode(e, m)
            } catch (P) {
                throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${e} failed`), P
            }
            let I;
            try {
                I = await this.client.core.history.get(e, i)
            } catch (P) {
                throw this.client.logger.error(`sendResult() -> history.get(${e}, ${i}) failed`), P
            }
            const T = pe[I.request.method].res;
            w ? (T.internal = _e(J({}, T.internal), {
                throwOnFailedPublish: !0
            }), await this.client.core.relayer.publish(e, y, T)) : this.client.core.relayer.publish(e, y, T).catch(P => this.client.logger.error(P)), await this.client.core.history.resolve(m)
        }, this.sendError = async (t, i, e) => {
            const c = vt(t, e);
            let w;
            try {
                w = await this.client.core.crypto.encode(i, c)
            } catch (I) {
                throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), I
            }
            let m;
            try {
                m = await this.client.core.history.get(i, t)
            } catch (I) {
                throw this.client.logger.error(`sendError() -> history.get(${i}, ${t}) failed`), I
            }
            const y = pe[m.request.method].res;
            this.client.core.relayer.publish(i, w, y), await this.client.core.history.resolve(c)
        }, this.cleanup = async () => {
            const t = [],
                i = [];
            this.client.session.getAll().forEach(e => {
                let c = !1;
                Ee(e.expiry) && (c = !0), this.client.core.crypto.keychain.has(e.topic) || (c = !0), c && t.push(e.topic)
            }), this.client.proposal.getAll().forEach(e => {
                Ee(e.expiryTimestamp) && i.push(e.id)
            }), await Promise.all([...t.map(e => this.deleteSession({
                topic: e
            })), ...i.map(e => this.deleteProposal(e))])
        }, this.onRelayEventRequest = async t => {
            this.requestQueue.queue.push(t), await this.processRequestsQueue()
        }, this.processRequestsQueue = async () => {
            if (this.requestQueue.state === ue.active) {
                this.client.logger.info("Request queue already active, skipping...");
                return
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0;) {
                this.requestQueue.state = ue.active;
                const t = this.requestQueue.queue.shift();
                if (t) try {
                    this.processRequest(t), await new Promise(i => setTimeout(i, 300))
                } catch (i) {
                    this.client.logger.warn(i)
                }
            }
            this.requestQueue.state = ue.idle
        }, this.processRequest = t => {
            const {
                topic: i,
                payload: e
            } = t, c = e.method;
            switch (c) {
                case "wc_sessionPropose":
                    return this.onSessionProposeRequest(i, e);
                case "wc_sessionSettle":
                    return this.onSessionSettleRequest(i, e);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateRequest(i, e);
                case "wc_sessionExtend":
                    return this.onSessionExtendRequest(i, e);
                case "wc_sessionPing":
                    return this.onSessionPingRequest(i, e);
                case "wc_sessionDelete":
                    return this.onSessionDeleteRequest(i, e);
                case "wc_sessionRequest":
                    return this.onSessionRequest(i, e);
                case "wc_sessionEvent":
                    return this.onSessionEventRequest(i, e);
                default:
                    return this.client.logger.info(`Unsupported request method ${c}`)
            }
        }, this.onRelayEventResponse = async t => {
            const {
                topic: i,
                payload: e
            } = t, c = (await this.client.core.history.get(i, e.id)).request.method;
            switch (c) {
                case "wc_sessionPropose":
                    return this.onSessionProposeResponse(i, e);
                case "wc_sessionSettle":
                    return this.onSessionSettleResponse(i, e);
                case "wc_sessionUpdate":
                    return this.onSessionUpdateResponse(i, e);
                case "wc_sessionExtend":
                    return this.onSessionExtendResponse(i, e);
                case "wc_sessionPing":
                    return this.onSessionPingResponse(i, e);
                case "wc_sessionRequest":
                    return this.onSessionRequestResponse(i, e);
                default:
                    return this.client.logger.info(`Unsupported response method ${c}`)
            }
        }, this.onRelayEventUnknownPayload = t => {
            const {
                topic: i
            } = t, {
                message: e
            } = L("MISSING_OR_INVALID", `Decoded payload on topic ${i} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(e)
        }, this.onSessionProposeRequest = async (t, i) => {
            const {
                params: e,
                id: c
            } = i;
            try {
                this.isValidConnect(J({}, i.params));
                const w = e.expiryTimestamp || le(pe.wc_sessionPropose.req.ttl),
                    m = J({
                        id: c,
                        pairingTopic: t,
                        expiryTimestamp: w
                    }, e);
                await this.setProposal(c, m);
                const y = Ve(JSON.stringify(i)),
                    I = await this.getVerifyContext(y, m.proposer.metadata);
                this.client.events.emit("session_proposal", {
                    id: c,
                    params: m,
                    verifyContext: I
                })
            } catch (w) {
                await this.sendError(c, t, w), this.client.logger.error(w)
            }
        }, this.onSessionProposeResponse = async (t, i) => {
            const {
                id: e
            } = i;
            if (we(i)) {
                const {
                    result: c
                } = i;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: c
                });
                const w = this.client.proposal.get(e);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: w
                });
                const m = w.proposer.publicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: m
                });
                const y = c.responderPublicKey;
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: y
                });
                const I = await this.client.core.crypto.generateSharedKey(m, y);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    sessionTopic: I
                });
                const T = await this.client.core.relayer.subscribe(I);
                this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: T
                }), await this.client.core.pairing.activate({
                    topic: t
                })
            } else if (me(i)) {
                await this.client.proposal.delete(e, ne("USER_DISCONNECTED"));
                const c = U("session_connect");
                if (this.events.listenerCount(c) === 0) throw new Error(`emitting ${c} without any listeners, 954`);
                this.events.emit(U("session_connect"), {
                    error: i.error
                })
            }
        }, this.onSessionSettleRequest = async (t, i) => {
            const {
                id: e,
                params: c
            } = i;
            try {
                this.isValidSessionSettleRequest(c);
                const {
                    relay: w,
                    controller: m,
                    expiry: y,
                    namespaces: I,
                    sessionProperties: T,
                    pairingTopic: P
                } = i.params, O = J({
                    topic: t,
                    relay: w,
                    expiry: y,
                    namespaces: I,
                    acknowledged: !0,
                    pairingTopic: P,
                    requiredNamespaces: {},
                    optionalNamespaces: {},
                    controller: m.publicKey,
                    self: {
                        publicKey: "",
                        metadata: this.client.metadata
                    },
                    peer: {
                        publicKey: m.publicKey,
                        metadata: m.metadata
                    }
                }, T && {
                    sessionProperties: T
                });
                await this.sendResult({
                    id: i.id,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                });
                const k = U("session_connect");
                if (this.events.listenerCount(k) === 0) throw new Error(`emitting ${k} without any listeners 997`);
                this.events.emit(U("session_connect"), {
                    session: O
                }), this.cleanupDuplicatePairings(O)
            } catch (w) {
                await this.sendError(e, t, w), this.client.logger.error(w)
            }
        }, this.onSessionSettleResponse = async (t, i) => {
            const {
                id: e
            } = i;
            we(i) ? (await this.client.session.update(t, {
                acknowledged: !0
            }), this.events.emit(U("session_approve", e), {})) : me(i) && (await this.client.session.delete(t, ne("USER_DISCONNECTED")), this.events.emit(U("session_approve", e), {
                error: i.error
            }))
        }, this.onSessionUpdateRequest = async (t, i) => {
            const {
                params: e,
                id: c
            } = i;
            try {
                const w = `${t}_session_update`,
                    m = Ne.get(w);
                if (m && this.isRequestOutOfSync(m, c)) {
                    this.client.logger.info(`Discarding out of sync request - ${c}`), this.sendError(c, t, ne("INVALID_UPDATE_REQUEST"));
                    return
                }
                this.isValidUpdate(J({
                    topic: t
                }, e));
                try {
                    Ne.set(w, c), await this.client.session.update(t, {
                        namespaces: e.namespaces
                    }), await this.sendResult({
                        id: c,
                        topic: t,
                        result: !0,
                        throwOnFailedPublish: !0
                    })
                } catch (y) {
                    throw Ne.delete(w), y
                }
                this.client.events.emit("session_update", {
                    id: c,
                    topic: t,
                    params: e
                })
            } catch (w) {
                await this.sendError(c, t, w), this.client.logger.error(w)
            }
        }, this.isRequestOutOfSync = (t, i) => parseInt(i.toString().slice(0, -3)) <= parseInt(t.toString().slice(0, -3)), this.onSessionUpdateResponse = (t, i) => {
            const {
                id: e
            } = i, c = U("session_update", e);
            if (this.events.listenerCount(c) === 0) throw new Error(`emitting ${c} without any listeners`);
            we(i) ? this.events.emit(U("session_update", e), {}) : me(i) && this.events.emit(U("session_update", e), {
                error: i.error
            })
        }, this.onSessionExtendRequest = async (t, i) => {
            const {
                id: e
            } = i;
            try {
                this.isValidExtend({
                    topic: t
                }), await this.setExpiry(t, le(Te)), await this.sendResult({
                    id: e,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }), this.client.events.emit("session_extend", {
                    id: e,
                    topic: t
                })
            } catch (c) {
                await this.sendError(e, t, c), this.client.logger.error(c)
            }
        }, this.onSessionExtendResponse = (t, i) => {
            const {
                id: e
            } = i, c = U("session_extend", e);
            if (this.events.listenerCount(c) === 0) throw new Error(`emitting ${c} without any listeners`);
            we(i) ? this.events.emit(U("session_extend", e), {}) : me(i) && this.events.emit(U("session_extend", e), {
                error: i.error
            })
        }, this.onSessionPingRequest = async (t, i) => {
            const {
                id: e
            } = i;
            try {
                this.isValidPing({
                    topic: t
                }), await this.sendResult({
                    id: e,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }), this.client.events.emit("session_ping", {
                    id: e,
                    topic: t
                })
            } catch (c) {
                await this.sendError(e, t, c), this.client.logger.error(c)
            }
        }, this.onSessionPingResponse = (t, i) => {
            const {
                id: e
            } = i, c = U("session_ping", e);
            if (this.events.listenerCount(c) === 0) throw new Error(`emitting ${c} without any listeners`);
            setTimeout(() => {
                we(i) ? this.events.emit(U("session_ping", e), {}) : me(i) && this.events.emit(U("session_ping", e), {
                    error: i.error
                })
            }, 500)
        }, this.onSessionDeleteRequest = async (t, i) => {
            const {
                id: e
            } = i;
            try {
                this.isValidDisconnect({
                    topic: t,
                    reason: i.params
                }), await Promise.all([new Promise(c => {
                    this.client.core.relayer.once(We.publish, async () => {
                        c(await this.deleteSession({
                            topic: t,
                            id: e
                        }))
                    })
                }), this.sendResult({
                    id: e,
                    topic: t,
                    result: !0,
                    throwOnFailedPublish: !0
                }), this.cleanupPendingSentRequestsForTopic({
                    topic: t,
                    error: ne("USER_DISCONNECTED")
                })])
            } catch (c) {
                this.client.logger.error(c)
            }
        }, this.onSessionRequest = async (t, i) => {
            const {
                id: e,
                params: c
            } = i;
            try {
                this.isValidRequest(J({
                    topic: t
                }, c));
                const w = Ve(JSON.stringify(ke("wc_sessionRequest", c, e))),
                    m = this.client.session.get(t),
                    y = await this.getVerifyContext(w, m.peer.metadata),
                    I = {
                        id: e,
                        topic: t,
                        params: c,
                        verifyContext: y
                    };
                await this.setPendingSessionRequest(I), this.addSessionRequestToSessionRequestQueue(I), this.processSessionRequestQueue()
            } catch (w) {
                await this.sendError(e, t, w), this.client.logger.error(w)
            }
        }, this.onSessionRequestResponse = (t, i) => {
            const {
                id: e
            } = i, c = U("session_request", e);
            if (this.events.listenerCount(c) === 0) throw new Error(`emitting ${c} without any listeners`);
            we(i) ? this.events.emit(U("session_request", e), {
                result: i.result
            }) : me(i) && this.events.emit(U("session_request", e), {
                error: i.error
            })
        }, this.onSessionEventRequest = async (t, i) => {
            const {
                id: e,
                params: c
            } = i;
            try {
                const w = `${t}_session_event_${c.event.name}`,
                    m = Ne.get(w);
                if (m && this.isRequestOutOfSync(m, e)) {
                    this.client.logger.info(`Discarding out of sync request - ${e}`);
                    return
                }
                this.isValidEmit(J({
                    topic: t
                }, c)), this.client.events.emit("session_event", {
                    id: e,
                    topic: t,
                    params: c
                }), Ne.set(w, e)
            } catch (w) {
                await this.sendError(e, t, w), this.client.logger.error(w)
            }
        }, this.addSessionRequestToSessionRequestQueue = t => {
            this.sessionRequestQueue.queue.push(t)
        }, this.cleanupAfterResponse = t => {
            this.deletePendingSessionRequest(t.response.id, {
                message: "fulfilled",
                code: 0
            }), setTimeout(() => {
                this.sessionRequestQueue.state = ue.idle, this.processSessionRequestQueue()
            }, j.toMiliseconds(this.requestQueueDelay))
        }, this.cleanupPendingSentRequestsForTopic = ({
            topic: t,
            error: i
        }) => {
            const e = this.client.core.history.pending;
            e.length > 0 && e.filter(c => c.topic === t && c.request.method === "wc_sessionRequest").forEach(c => {
                const w = c.request.id,
                    m = U("session_request", w);
                if (this.events.listenerCount(m) === 0) throw new Error(`emitting ${m} without any listeners`);
                this.events.emit(U("session_request", c.request.id), {
                    error: i
                })
            })
        }, this.processSessionRequestQueue = () => {
            if (this.sessionRequestQueue.state === ue.active) {
                this.client.logger.info("session request queue is already active.");
                return
            }
            const t = this.sessionRequestQueue.queue[0];
            if (!t) {
                this.client.logger.info("session request queue is empty.");
                return
            }
            try {
                this.sessionRequestQueue.state = ue.active, this.client.events.emit("session_request", t)
            } catch (i) {
                this.client.logger.error(i)
            }
        }, this.onPairingCreated = t => {
            if (t.active) return;
            const i = this.client.proposal.getAll().find(e => e.pairingTopic === t.topic);
            i && this.onSessionProposeRequest(t.topic, ke("wc_sessionPropose", {
                requiredNamespaces: i.requiredNamespaces,
                optionalNamespaces: i.optionalNamespaces,
                relays: i.relays,
                proposer: i.proposer,
                sessionProperties: i.sessionProperties
            }, i.id))
        }, this.isValidConnect = async t => {
            if (!oe(t)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
                throw new Error(y)
            }
            const {
                pairingTopic: i,
                requiredNamespaces: e,
                optionalNamespaces: c,
                sessionProperties: w,
                relays: m
            } = t;
            if (ve(i) || await this.isValidPairingTopic(i), !qt(m, !0)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `connect() relays: ${m}`);
                throw new Error(y)
            }!ve(e) && Je(e) !== 0 && this.validateNamespaces(e, "requiredNamespaces"), !ve(c) && Je(c) !== 0 && this.validateNamespaces(c, "optionalNamespaces"), ve(w) || this.validateSessionProps(w, "sessionProperties")
        }, this.validateNamespaces = (t, i) => {
            const e = Ct(t, "connect()", i);
            if (e) throw new Error(e.message)
        }, this.isValidApprove = async t => {
            if (!oe(t)) throw new Error(L("MISSING_OR_INVALID", `approve() params: ${t}`).message);
            const {
                id: i,
                namespaces: e,
                relayProtocol: c,
                sessionProperties: w
            } = t;
            this.checkRecentlyDeleted(i), await this.isValidProposalId(i);
            const m = this.client.proposal.get(i),
                y = $e(e, "approve()");
            if (y) throw new Error(y.message);
            const I = Ye(m.requiredNamespaces, e, "approve()");
            if (I) throw new Error(I.message);
            if (!qe(c, !0)) {
                const {
                    message: T
                } = L("MISSING_OR_INVALID", `approve() relayProtocol: ${c}`);
                throw new Error(T)
            }
            ve(w) || this.validateSessionProps(w, "sessionProperties")
        }, this.isValidReject = async t => {
            if (!oe(t)) {
                const {
                    message: c
                } = L("MISSING_OR_INVALID", `reject() params: ${t}`);
                throw new Error(c)
            }
            const {
                id: i,
                reason: e
            } = t;
            if (this.checkRecentlyDeleted(i), await this.isValidProposalId(i), !Lt(e)) {
                const {
                    message: c
                } = L("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(e)}`);
                throw new Error(c)
            }
        }, this.isValidSessionSettleRequest = t => {
            if (!oe(t)) {
                const {
                    message: I
                } = L("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
                throw new Error(I)
            }
            const {
                relay: i,
                controller: e,
                namespaces: c,
                expiry: w
            } = t;
            if (!xt(i)) {
                const {
                    message: I
                } = L("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
                throw new Error(I)
            }
            const m = Ot(e, "onSessionSettleRequest()");
            if (m) throw new Error(m.message);
            const y = $e(c, "onSessionSettleRequest()");
            if (y) throw new Error(y.message);
            if (Ee(w)) {
                const {
                    message: I
                } = L("EXPIRED", "onSessionSettleRequest()");
                throw new Error(I)
            }
        }, this.isValidUpdate = async t => {
            if (!oe(t)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `update() params: ${t}`);
                throw new Error(y)
            }
            const {
                topic: i,
                namespaces: e
            } = t;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const c = this.client.session.get(i),
                w = $e(e, "update()");
            if (w) throw new Error(w.message);
            const m = Ye(c.requiredNamespaces, e, "update()");
            if (m) throw new Error(m.message)
        }, this.isValidExtend = async t => {
            if (!oe(t)) {
                const {
                    message: e
                } = L("MISSING_OR_INVALID", `extend() params: ${t}`);
                throw new Error(e)
            }
            const {
                topic: i
            } = t;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i)
        }, this.isValidRequest = async t => {
            if (!oe(t)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `request() params: ${t}`);
                throw new Error(y)
            }
            const {
                topic: i,
                request: e,
                chainId: c,
                expiry: w
            } = t;
            this.checkRecentlyDeleted(i), await this.isValidSessionTopic(i);
            const {
                namespaces: m
            } = this.client.session.get(i);
            if (!Xe(m, c)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `request() chainId: ${c}`);
                throw new Error(y)
            }
            if (!Pt(e)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `request() ${JSON.stringify(e)}`);
                throw new Error(y)
            }
            if (!Dt(m, c, e.method)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `request() method: ${e.method}`);
                throw new Error(y)
            }
            if (w && !Tt(w, Be)) {
                const {
                    message: y
                } = L("MISSING_OR_INVALID", `request() expiry: ${w}. Expiry must be a number (in seconds) between ${Be.min} and ${Be.max}`);
                throw new Error(y)
            }
        }, this.isValidRespond = async t => {
            var i;
            if (!oe(t)) {
                const {
                    message: w
                } = L("MISSING_OR_INVALID", `respond() params: ${t}`);
                throw new Error(w)
            }
            const {
                topic: e,
                response: c
            } = t;
            try {
                await this.isValidSessionTopic(e)
            } catch (w) {
                throw (i = t == null ? void 0 : t.response) != null && i.id && this.cleanupAfterResponse(t), w
            }
            if (!At(c)) {
                const {
                    message: w
                } = L("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(c)}`);
                throw new Error(w)
            }
        }, this.isValidPing = async t => {
            if (!oe(t)) {
                const {
                    message: e
                } = L("MISSING_OR_INVALID", `ping() params: ${t}`);
                throw new Error(e)
            }
            const {
                topic: i
            } = t;
            await this.isValidSessionOrPairingTopic(i)
        }, this.isValidEmit = async t => {
            if (!oe(t)) {
                const {
                    message: m
                } = L("MISSING_OR_INVALID", `emit() params: ${t}`);
                throw new Error(m)
            }
            const {
                topic: i,
                event: e,
                chainId: c
            } = t;
            await this.isValidSessionTopic(i);
            const {
                namespaces: w
            } = this.client.session.get(i);
            if (!Xe(w, c)) {
                const {
                    message: m
                } = L("MISSING_OR_INVALID", `emit() chainId: ${c}`);
                throw new Error(m)
            }
            if (!Mt(e)) {
                const {
                    message: m
                } = L("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(e)}`);
                throw new Error(m)
            }
            if (!Vt(w, c, e.name)) {
                const {
                    message: m
                } = L("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(e)}`);
                throw new Error(m)
            }
        }, this.isValidDisconnect = async t => {
            if (!oe(t)) {
                const {
                    message: e
                } = L("MISSING_OR_INVALID", `disconnect() params: ${t}`);
                throw new Error(e)
            }
            const {
                topic: i
            } = t;
            await this.isValidSessionOrPairingTopic(i)
        }, this.getVerifyContext = async (t, i) => {
            const e = {
                verified: {
                    verifyUrl: i.verifyUrl || kt,
                    validation: "UNKNOWN",
                    origin: i.url || ""
                }
            };
            try {
                const c = await this.client.core.verify.resolve({
                    attestationId: t,
                    verifyUrl: i.verifyUrl
                });
                c && (e.verified.origin = c.origin, e.verified.isScam = c.isScam, e.verified.validation = c.origin === new URL(i.url).origin ? "VALID" : "INVALID")
            } catch (c) {
                this.client.logger.info(c)
            }
            return this.client.logger.info(`Verify context: ${JSON.stringify(e)}`), e
        }, this.validateSessionProps = (t, i) => {
            Object.values(t).forEach(e => {
                if (!qe(e, !1)) {
                    const {
                        message: c
                    } = L("MISSING_OR_INVALID", `${i} must be in Record<string, string> format. Received: ${JSON.stringify(e)}`);
                    throw new Error(c)
                }
            })
        }, this.addToRecentlyDeleted = (t, i) => {
            if (this.recentlyDeletedMap.set(t, i), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
                let e = 0;
                const c = this.recentlyDeletedLimit / 2;
                for (const w of this.recentlyDeletedMap.keys()) {
                    if (e++ >= c) break;
                    this.recentlyDeletedMap.delete(w)
                }
            }
        }, this.checkRecentlyDeleted = t => {
            const i = this.recentlyDeletedMap.get(t);
            if (i) {
                const {
                    message: e
                } = L("MISSING_OR_INVALID", `Record was recently deleted - ${i}: ${t}`);
                throw new Error(e)
            }
        }
    }
    async isInitialized() {
        if (!this.initialized) {
            const {
                message: o
            } = L("NOT_INITIALIZED", this.name);
            throw new Error(o)
        }
        await this.client.core.relayer.confirmOnlineStateOrThrow()
    }
    registerRelayerEvents() {
        this.client.core.relayer.on(We.message, async o => {
            const {
                topic: t,
                message: i
            } = o;
            if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(i))) return;
            const e = await this.client.core.crypto.decode(t, i);
            try {
                $t(e) ? (this.client.core.history.set(t, e), this.onRelayEventRequest({
                    topic: t,
                    payload: e
                })) : Ut(e) ? (await this.client.core.history.resolve(e), await this.onRelayEventResponse({
                    topic: t,
                    payload: e
                }), this.client.core.history.delete(t, e.id)) : this.onRelayEventUnknownPayload({
                    topic: t,
                    payload: e
                })
            } catch (c) {
                this.client.logger.error(c)
            }
        })
    }
    registerExpirerEvents() {
        this.client.core.expirer.on(bt.expired, async o => {
            const {
                topic: t,
                id: i
            } = jt(o.target);
            if (i && this.client.pendingRequest.keys.includes(i)) return await this.deletePendingSessionRequest(i, L("EXPIRED"), !0);
            t ? this.client.session.keys.includes(t) && (await this.deleteSession({
                topic: t,
                expirerHasDeleted: !0
            }), this.client.events.emit("session_expire", {
                topic: t
            })) : i && (await this.deleteProposal(i, !0), this.client.events.emit("proposal_expire", {
                id: i
            }))
        })
    }
    registerPairingEvents() {
        this.client.core.pairing.events.on(Ze.create, o => this.onPairingCreated(o)), this.client.core.pairing.events.on(Ze.delete, o => {
            this.addToRecentlyDeleted(o.topic, "pairing")
        })
    }
    isValidPairingTopic(o) {
        if (!qe(o, !1)) {
            const {
                message: t
            } = L("MISSING_OR_INVALID", `pairing topic should be a string: ${o}`);
            throw new Error(t)
        }
        if (!this.client.core.pairing.pairings.keys.includes(o)) {
            const {
                message: t
            } = L("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o}`);
            throw new Error(t)
        }
        if (Ee(this.client.core.pairing.pairings.get(o).expiry)) {
            const {
                message: t
            } = L("EXPIRED", `pairing topic: ${o}`);
            throw new Error(t)
        }
    }
    async isValidSessionTopic(o) {
        if (!qe(o, !1)) {
            const {
                message: t
            } = L("MISSING_OR_INVALID", `session topic should be a string: ${o}`);
            throw new Error(t)
        }
        if (this.checkRecentlyDeleted(o), !this.client.session.keys.includes(o)) {
            const {
                message: t
            } = L("NO_MATCHING_KEY", `session topic doesn't exist: ${o}`);
            throw new Error(t)
        }
        if (Ee(this.client.session.get(o).expiry)) {
            await this.deleteSession({
                topic: o
            });
            const {
                message: t
            } = L("EXPIRED", `session topic: ${o}`);
            throw new Error(t)
        }
        if (!this.client.core.crypto.keychain.has(o)) {
            const {
                message: t
            } = L("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o}`);
            throw await this.deleteSession({
                topic: o
            }), new Error(t)
        }
    }
    async isValidSessionOrPairingTopic(o) {
        if (this.checkRecentlyDeleted(o), this.client.session.keys.includes(o)) await this.isValidSessionTopic(o);
        else if (this.client.core.pairing.pairings.keys.includes(o)) this.isValidPairingTopic(o);
        else if (qe(o, !1)) {
            const {
                message: t
            } = L("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o}`);
            throw new Error(t)
        } else {
            const {
                message: t
            } = L("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o}`);
            throw new Error(t)
        }
    }
    async isValidProposalId(o) {
        if (!Ft(o)) {
            const {
                message: t
            } = L("MISSING_OR_INVALID", `proposal id should be a number: ${o}`);
            throw new Error(t)
        }
        if (!this.client.proposal.keys.includes(o)) {
            const {
                message: t
            } = L("NO_MATCHING_KEY", `proposal id doesn't exist: ${o}`);
            throw new Error(t)
        }
        if (Ee(this.client.proposal.get(o).expiryTimestamp)) {
            await this.deleteProposal(o);
            const {
                message: t
            } = L("EXPIRED", `proposal id: ${o}`);
            throw new Error(t)
        }
    }
}
class yi extends He {
    constructor(o, t) {
        super(o, t, oi, Ke), this.core = o, this.logger = t
    }
}
class Si extends He {
    constructor(o, t) {
        super(o, t, ci, Ke), this.core = o, this.logger = t
    }
}
class Ei extends He {
    constructor(o, t) {
        super(o, t, hi, Ke, i => i.id), this.core = o, this.logger = t
    }
}
class Qe extends dt {
    constructor(o) {
        super(o), this.protocol = ht, this.version = pt, this.name = Ge.name, this.events = new gt.EventEmitter, this.on = (i, e) => this.events.on(i, e), this.once = (i, e) => this.events.once(i, e), this.off = (i, e) => this.events.off(i, e), this.removeListener = (i, e) => this.events.removeListener(i, e), this.removeAllListeners = i => this.events.removeAllListeners(i), this.connect = async i => {
            try {
                return await this.engine.connect(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.pair = async i => {
            try {
                return await this.engine.pair(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.approve = async i => {
            try {
                return await this.engine.approve(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.reject = async i => {
            try {
                return await this.engine.reject(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.update = async i => {
            try {
                return await this.engine.update(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.extend = async i => {
            try {
                return await this.engine.extend(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.request = async i => {
            try {
                return await this.engine.request(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.respond = async i => {
            try {
                return await this.engine.respond(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.ping = async i => {
            try {
                return await this.engine.ping(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.emit = async i => {
            try {
                return await this.engine.emit(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.disconnect = async i => {
            try {
                return await this.engine.disconnect(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.find = i => {
            try {
                return this.engine.find(i)
            } catch (e) {
                throw this.logger.error(e.message), e
            }
        }, this.getPendingSessionRequests = () => {
            try {
                return this.engine.getPendingSessionRequests()
            } catch (i) {
                throw this.logger.error(i.message), i
            }
        }, this.name = (o == null ? void 0 : o.name) || Ge.name, this.metadata = (o == null ? void 0 : o.metadata) || ft();
        const t = typeof(o == null ? void 0 : o.logger) < "u" && typeof(o == null ? void 0 : o.logger) != "string" ? o.logger : Le.pino(Le.getDefaultLoggerOptions({
            level: (o == null ? void 0 : o.logger) || Ge.logger
        }));
        this.core = (o == null ? void 0 : o.core) || new wt(o), this.logger = Le.generateChildLogger(t, this.name), this.session = new Si(this.core, this.logger), this.proposal = new yi(this.core, this.logger), this.pendingRequest = new Ei(this.core, this.logger), this.engine = new mi(this)
    }
    static async init(o) {
        const t = new Qe(o);
        return await t.initialize(), t
    }
    get context() {
        return Le.getLoggerContext(this.logger)
    }
    get pairing() {
        return this.core.pairing.pairings
    }
    async initialize() {
        this.logger.trace("Initialized");
        try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({
                verifyUrl: this.metadata.verifyUrl
            }), this.logger.info("SignClient Initialization Success")
        } catch (o) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o.message), o
        }
    }
}
const ze = v.env.host,
    _i = {
        name: "WalletConnect " + ze.toUpperCase(),
        description: "WalletConnect BCGAME " + ze.toUpperCase(),
        url: ze.toUpperCase(),
        icons: ["https://walletconnect.com/_next/static/media/logo_mark.84dd8525.svg"]
    };
async function Ii() {
    return await Qe.init({
        projectId: v.env.WALLET_CONNECT_PROJECT_ID,
        metadata: _i
    })
}
async function Ri(S, o, t, i) {
    var w;
    const e = zt((w = o == null ? void 0 : o.namespaces.eip155.accounts[0]) != null ? w : ""),
        c = await S.request({
            topic: o.topic,
            chainId: "eip155:1",
            request: {
                method: "personal_sign",
                params: [t, e]
            }
        });
    i(c, e)
}
async function Ni(S, o) {
    const t = new Bt({
            projectId: v.env.WALLET_CONNECT_PROJECT_ID
        }),
        i = await Ii();
    try {
        const {
            uri: e,
            approval: c
        } = await i.connect({
            requiredNamespaces: {
                eip155: {
                    methods: ["eth_sendTransaction", "personal_sign"],
                    chains: ["eip155:1"],
                    events: ["chainChanged", "accountsChanged"]
                }
            }
        });
        if (e) {
            t.openModal({
                uri: e
            });
            const w = await c();
            await Ri(i, w, S, o), t.closeModal()
        }
    } catch (e) {
        e instanceof Error && v.notify(e.message)
    }
}

function at(S) {
    const o = new Date(S),
        t = o.getFullYear(),
        i = String(o.getMonth() + 1).padStart(2, "0"),
        e = String(o.getDate()).padStart(2, "0"),
        c = String(o.getHours()).padStart(2, "0"),
        w = String(o.getMinutes()).padStart(2, "0"),
        m = o.getHours() >= 12 ? "PM" : "AM";
    return `${i}/${e}/${t}, ${c}:${w} ${m}`
}
const vi = function({
        startTime: S,
        endTime: o
    }) {
        const {
            t
        } = v.useTranslation(), i = v.useDialog();
        return q.jsx("div", {
            className: qi,
            children: q.jsx(v.Dialog, {
                title: t("Unable to log in"),
                children: q.jsxs("div", {
                    className: "content",
                    children: [q.jsx("div", {
                        className: "top-line",
                        children: t("Your Self-Exclusion has began, you are unable to signin right now")
                    }), q.jsxs("div", {
                        className: "time-wrap",
                        children: [q.jsxs("div", {
                            className: "time-line",
                            children: [q.jsxs("div", {
                                className: "left-box",
                                children: [q.jsx(v.Icon, {
                                    name: "Clock"
                                }), q.jsx("span", {
                                    children: t("Start time")
                                })]
                            }), q.jsx("div", {
                                className: "time",
                                children: at(S)
                            })]
                        }), q.jsxs("div", {
                            className: "time-line",
                            children: [q.jsxs("div", {
                                className: "left-box",
                                children: [q.jsx(v.Icon, {
                                    name: "Clock"
                                }), q.jsx("span", {
                                    children: t("End time")
                                })]
                            }), q.jsx("div", {
                                className: "time",
                                children: o > S ? at(o) : t("Permanent")
                            })]
                        })]
                    }), q.jsx(v.Button, {
                        onClick: () => {
                            i.close()
                        },
                        type: "conic",
                        children: t("OK")
                    }), q.jsx("div", {
                        children: t("If you did not make this change, please contact us.")
                    })]
                })
            })
        })
    },
    qi = "u843kj4",
    Ci = de.memo(function({
        invitationCode: o = "",
        onEnd: t,
        children: i,
        inDialog: e = !1
    }) {
        const c = v.useIsMobile(),
            w = Se.useRef(null),
            [m, y] = Se.useState(!1),
            [I, T] = Se.useState(!1),
            [P, O] = Se.useState(!1),
            k = v.useDialog();
        Se.useEffect(() => {
            if (m) {
                const R = setTimeout(() => {
                    y(!1)
                }, 3e3);
                return () => {
                    clearTimeout(R)
                }
            }
        }, [m]);
        const $ = async R => {
                const D = await v.http.get(`/account/self-exclusion/status/${R}/`),
                    B = D.startTime + D.period * 30 * 864e5;
                k.push(q.jsx(vi, {
                    startTime: D.startTime,
                    endTime: B
                }))
            },
            Y = async R => {
                y(!0);
                try {
                    v.app.emit("track", "third_register_click", {
                        account_type: "google"
                    }), await et({
                        fullName: R.fullName,
                        idToken: R.idToken,
                        openUserId: R.openUserId,
                        userType: "google",
                        picture: R.picture,
                        invitationCode: o
                    }), t && t()
                } catch (D) {
                    if (D.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const B = D.message.split("|").pop();
                        $(B)
                    } else v.notify(D)
                }
                y(!1)
            },
            Z = async () => {
                y(!0);
                try {
                    v.app.emit("track", "third_register_click", {
                        account_type: "telegram"
                    });
                    const R = await Ue("telegram");
                    await et({
                        fullName: R.first_name,
                        idToken: Object.entries(R).map(([D, B]) => `${D}=${B}`).join(","),
                        openUserId: R.id,
                        userType: "telegram",
                        invitationCode: o
                    }), t && t()
                } catch (R) {
                    if (R.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const D = R.message.split("|").pop();
                        $(D)
                    } else v.notify(R)
                }
                y(!1)
            },
            K = async () => {
                y(!0), O(!0);
                try {
                    v.app.emit("track", "third_register_click", {
                        account_type: "wallet"
                    });
                    const R = await v.requestRecaptcha("login"),
                        D = await tt();
                    O(!1);
                    let {
                        signature: B,
                        publicAddress: s
                    } = await ni(D);
                    await it({
                        signStr: B,
                        walletName: "metamask",
                        codeType: "reCAPTCHA",
                        code: R,
                        walletUnique: s,
                        invitationCode: o
                    }), t && t()
                } catch (R) {
                    if (R.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const D = R.message.split("|").pop();
                        $(D)
                    } else v.notify(R)
                }
                y(!1), O(!1)
            },
            _ = async R => {
                y(!0), R ? O(!0) : T(!0);
                try {
                    v.app.emit("open-wallet-connect-modal"), v.app.emit("track", "third_register_click", {
                        account_type: "wallet"
                    });
                    const D = await v.requestRecaptcha("login"),
                        B = await tt();
                    T(!1), Ni(B, async (s, r) => {
                        await it({
                            signStr: s,
                            codeType: "reCAPTCHA",
                            code: D,
                            walletName: "metamask",
                            walletUnique: r,
                            invitationCode: o
                        }), t && t()
                    })
                } catch (D) {
                    if (D.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const B = D.message.split("|").pop();
                        $(B)
                    } else v.notify(D)
                }
                y(!1), O(!1), T(!1)
            },
            ge = async () => {
                y(!0);
                try {
                    v.app.emit("track", "third_register_click", {
                        account_type: "line"
                    });
                    const R = await Ue("line", o);
                    R ? v.notify(R) : (v.app.emit("signin-success"), t && t())
                } catch (R) {
                    if (R.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const D = R.message.split("|").pop();
                        $(D)
                    } else v.notify(R)
                }
                y(!1)
            },
            ee = async () => {
                y(!0);
                try {
                    v.app.emit("track", "third_register_click", {
                        account_type: "steam"
                    });
                    const R = await Ue("steam", o);
                    R ? v.notify(R) : (v.app.emit("signin-success"), t && t())
                } catch (R) {
                    if (R.code === v.BC.ErrorCode.SELF_EXCLUSION) {
                        const D = R.message.split("|").pop();
                        $(D)
                    } else v.notify(R)
                }
                y(!1)
            };
        return Se.useEffect(() => {
            ei(Y).then(() => {
                try {
                    const R = Zt();
                    w.current = () => {
                        R.click()
                    }
                } catch (R) {}
            }).catch(console.log)
        }, []), q.jsxs("div", {
            className: "third-group-wrap",
            children: [q.jsx("button", {
                id: "gg_login",
                type: "button",
                title: "google",
                disabled: m,
                onClick: () => {
                    w && w.current()
                },
                children: q.jsx(Ht, {})
            }), q.jsx("button", {
                id: "tg_login",
                type: "button",
                title: "telegram",
                onClick: Z,
                disabled: m,
                children: q.jsx(Kt, {})
            }), q.jsx("button", {
                id: "mm_login",
                type: "button",
                title: "metamask",
                disabled: m,
                onClick: () => {
                    c ? _(!0) : K()
                },
                children: e && P ? q.jsx(v.Loading, {}) : q.jsx(Qt, {})
            }), q.jsx("button", {
                id: "wc_login",
                type: "button",
                title: "wallet connect",
                disabled: m,
                onClick: () => _(!1),
                children: e && I ? q.jsx(v.Loading, {}) : q.jsx(Wt, {})
            }), i, q.jsx("button", {
                id: "ln_login",
                type: "button",
                title: "line",
                disabled: m,
                onClick: ge,
                children: q.jsx(Jt, {})
            }), q.jsx("button", {
                id: "st_login",
                type: "button",
                title: "steam",
                disabled: m,
                onClick: ee,
                children: q.jsx(Yt, {})
            })]
        })
    }),
    Di = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: Ci
    }, Symbol.toStringTag, {
        value: "Module"
    }));
export {
    Di as E, Ci as T, vi as U
};